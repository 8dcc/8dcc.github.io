<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding the Y combinator</title>
<meta property="og:title" content="Understanding the Y combinator" />
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png" />
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
  <a accesskey="u" href="index.html">Up</a> | <a accesskey="h" href="../index.html">Home</a>
</div><div id="content" class="content">
<h1 class="title">Understanding the Y combinator</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#quick-introduction-to-lambda-calculus">1. Quick introduction to lambda calculus</a>
<ul>
<li><a href="#rules">1.1. Rules</a></li>
<li><a href="#lambda-terms">1.2. Lambda terms</a></li>
<li><a href="#reduction-operations">1.3. Reduction operations</a></li>
<li><a href="#notation">1.4. Notation</a></li>
</ul>
</li>
<li><a href="#sicp-lisp-and-javascript">2. SICP, Lisp and JavaScript</a></li>
<li><a href="#simple-example-factorial">3. Simple example: Factorial</a></li>
<li><a href="#simple-recursion-with-anonymous-functions">4. Simple recursion with anonymous functions</a></li>
<li><a href="#fixed-points">5. Fixed points</a></li>
<li><a href="#fixed-point-combinators">6. Fixed-point combinators</a></li>
<li><a href="#y-combinator">7. Y combinator</a></li>
<li><a href="#applications-of-the-y-combinator">8. Applications of the Y combinator</a></li>
<li><a href="#implementation-in-scheme">9. Implementation in Scheme</a>
<ul>
<li><a href="#beta-abstraction-in-scheme">9.1. Delaying evaluation with beta abstraction</a></li>
<li><a href="#evaluation-process-of-our-y-combinator">9.2. Evaluation process of our Y combinator</a></li>
<li><a href="#complete-scheme-example">9.3. Complete Scheme example</a></li>
</ul>
</li>
<li><a href="#final-note">10. Final note</a></li>
</ul>
</div>
</div>

<div id="outline-container-quick-introduction-to-lambda-calculus" class="outline-2">
<h2 id="quick-introduction-to-lambda-calculus"><span class="section-number-2">1.</span> Quick introduction to lambda calculus</h2>
<div class="outline-text-2" id="text-quick-introduction-to-lambda-calculus">
<p>
<b>Lambda calculus</b> (&lambda;-calculus) is a mathematical system for computation
based on <b>function abstraction</b> and <b>application</b>, using <b>variable binding</b> and
substitution.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>
</div>

<div id="outline-container-rules" class="outline-3">
<h3 id="rules"><span class="section-number-3">1.1.</span> Rules</h3>
<div class="outline-text-3" id="text-rules">
<p>
The beauty of lambda calculus is its simplicity. These are the only 3 rules:
</p>

<ol class="org-ol">
<li>\(x\): A <b>variable</b> represents a parameter.</li>
<li>\((\lambda x. M)\): A <b>lambda abstraction</b> is an anonymous function, with a
parameter \(x\) (between the &lambda; and the dot), that returns the body \(M\).</li>
<li>\((M\ N)\): An <b>application</b> of function \(M\) to an argument \(N\).</li>
</ol>

<p>
In the last rule, both \(M\) and \(N\) are lambda terms.
</p>
</div>
</div>

<div id="outline-container-lambda-terms" class="outline-3">
<h3 id="lambda-terms"><span class="section-number-3">1.2.</span> Lambda terms</h3>
<div class="outline-text-3" id="text-lambda-terms">
<p>
A <b>lambda term</b> is just a valid expression in the lambda calculus system. Well,
what makes an expression valid? The following 3 rules are used to determine if a
lambda expression is valid:
</p>

<ol class="org-ol">
<li>A <b>variable</b> \(x\) is itself a valid lambda term.</li>
<li>If \(M\) is a lambda term, and \(x\) is a variable, then \((\lambda x. M)\) is also
a lambda term (An <b>abstraction</b>).</li>
<li>If \(M\) and \(N\) are lambda terms, then \((M\ N)\) is also a lambda term (An
<b>application</b>).</li>
</ol>

<p>
You can begin to feel the recursive magic of lambda calculus, before even
getting into an example.
</p>
</div>
</div>

<div id="outline-container-reduction-operations" class="outline-3">
<h3 id="reduction-operations"><span class="section-number-3">1.3.</span> Reduction operations</h3>
<div class="outline-text-3" id="text-reduction-operations">
<p>
Lambda calculus also has 2 main reduction operations:
</p>

<ol class="org-ol">
<li>\((\lambda x. M[x])\) &rarr; \((\lambda y. M[y])\): <b>Alpha conversion</b>
(&alpha;-conversion), renaming the bound variables in the expression. Used to
avoid name collisions.</li>
<li>\(((\lambda x. M) N)\) &rarr; \((M[x := N])\): <b>Beta reduction</b> (&beta;-reduction),
replacing the bound variables (\(x\)) with the argument expression (\(N\)) in the
body (\(M\)) of the abstraction.</li>
</ol>

<p>
There is also <b>eta reduction</b> (&eta;-reduction), which expresses the idea of
<i>extensionality</i>,<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> which applied to
this context establishes that two functions are the same if and only if they
give the same result for all arguments.
</p>

<p>
<a href="#implementation-in-scheme">Later</a> we will also mention the opposite of the beta reduction, the <b>beta
abstraction</b>, which instead of simplifying an expression, it adds an extra
function call that might be useful (e.g. in Lisps) for delaying the evaluation
of the arguments.
</p>
</div>
</div>

<div id="outline-container-notation" class="outline-3">
<h3 id="notation"><span class="section-number-3">1.4.</span> Notation</h3>
<div class="outline-text-3" id="text-notation">
<p>
For understanding lambda notation, you will also have to keep in mind these
conventions:
</p>

<ol class="org-ol">
<li>Outermost parentheses are dropped: \(M N\) instead of \((M N)\).</li>
<li>Applications are assumed to be left associative: \(M N P\) instead of
\(((M N) P)\).</li>
<li>The body of an abstraction extends as far right as possible:
\((\lambda x. M N)\) means \((\lambda x. (M N))\) and not \(((\lambda x. M) N)\).</li>
<li>A sequence of abstractions is contracted:
\((\lambda x. \lambda y. \lambda z. N)\) is abbreviated as
\((\lambda x\ y\ z. N)\).</li>
<li>When all variables are single-letter, the space in applications may be
omitted: \((M N P)\) instead of \((M\ N\ P)\).</li>
</ol>

<p>
Some of these look a bit confusing to me, specially when embedding expressions
in text, so I will try to make each expression as readable as possible.
</p>
</div>
</div>
</div>

<div id="outline-container-sicp-lisp-and-javascript" class="outline-2">
<h2 id="sicp-lisp-and-javascript"><span class="section-number-2">2.</span> SICP, Lisp and JavaScript</h2>
<div class="outline-text-2" id="text-sicp-lisp-and-javascript">
<p>
<a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">Structure and Interpretation of Computer Programs</a> is an amazing book by Harold
Abelson and Gerald Jay Sussman. The book teaches the fundamental principles of
computer programming, including recursion, abstraction, modularity, and much
more. I recommend the book to anyone who is interested in programming, I am sure
they will learn something.
</p>

<p>
This book has two editions. The first one uses <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> (a dialect of <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>), for
its examples and explanations, while the second uses <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>. I have not
programmed much in JavaScript at the time of writing this, but I will try to
provide all examples in both lambda notation, Scheme and JavaScript.
</p>

<p>
At one point, in section 1.3.3, they talk about finding fixed points of
functions. This was the first time I heard about this, and it&rsquo;s what mainly
motivated me to write this article. If you are interested on the general Lisp
approach, and not on the Y combinator itself, I recommend you check it out.
</p>

<p>
One of the most valuable things that SICP has taught me is that sometimes it&rsquo;s
extremely useful to treat functions as black boxes that are able to transform
some inputs into some outputs. They call this <i>wishful thinking</i>, and it has been
useful not only when using functions, but also when designing them.
</p>
</div>
</div>

<div id="outline-container-simple-example-factorial" class="outline-2">
<h2 id="simple-example-factorial"><span class="section-number-2">3.</span> Simple example: Factorial</h2>
<div class="outline-text-2" id="text-simple-example-factorial">
<p>
This is the function for calculating the factorial of a number \(n\), using the
lambda calculus notation:
</p>

<p>
\[
\text{fact} = \lambda n. \Big(\Big(\text{iszero}\ n\Big) 1 \Big(\text{mult}\ n
\ \big(\text{fact}\ (\text{prec}\ n)\big)\Big)\Big)
\]
</p>

<p>
In Scheme:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">fact</span>
  <span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #44bc44;">(</span>n<span style="color: #44bc44;">)</span>
    <span style="color: #44bc44;">(</span><span style="color: #ff6f9f;">if</span> <span style="color: #00eff0;">(</span>equal? n <span style="color: #88ca9f;">0</span><span style="color: #00eff0;">)</span>
        <span style="color: #88ca9f;">1</span>
        <span style="color: #00eff0;">(</span>mult n <span style="color: #338fff;">(</span>fact <span style="color: #ef7fff;">(</span>prec n<span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
Or in JavaScript:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff6f9f;">var</span> <span style="color: #6ae4b9;">fact</span> = (n) =&gt; (n == <span style="color: #88ca9f;">0</span>)
    ? <span style="color: #88ca9f;">1</span>
    : mult(n, (fact(prec(n))));
</pre>
</div>

<p>
We are defining <code>fact</code> as a function that takes a parameter <code>n</code>. This function
returns 1 if <code>n</code> is zero, and otherwise multiplies <code>n</code> by the factorial of the
number preceding <code>n</code>.
</p>

<p>
In this case, we can simply ignore how <code>iszero</code>, <code>mult</code>, <code>prec</code> and even <code>fact</code> work
<i>internally</i>, we just have to trust that they do what we expect. Another useful
way of thinking about lambda calculus and Lisp in general is as a language for
expressing processes.
</p>

<p>
In any case, we don&rsquo;t have those name-defining commodities in lambda calculus. A
function can&rsquo;t call itself by name, so we will have to find an alternative way.
</p>
</div>
</div>

<div id="outline-container-simple-recursion-with-anonymous-functions" class="outline-2">
<h2 id="simple-recursion-with-anonymous-functions"><span class="section-number-2">4.</span> Simple recursion with anonymous functions</h2>
<div class="outline-text-2" id="text-simple-recursion-with-anonymous-functions">
<p>
Before trying to understand the Y combinator, let&rsquo;s have a look at an example of
how an anonymous function might call itself without the need for symbols.
</p>

<p>
\[
(\lambda x. x\ x)(\lambda x. x\ x)
\]
</p>

<p>
Or in Scheme:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #44bc44;">(</span>x<span style="color: #44bc44;">)</span> <span style="color: #44bc44;">(</span>x x<span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span>
 <span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #44bc44;">(</span>x<span style="color: #44bc44;">)</span> <span style="color: #44bc44;">(</span>x x<span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<blockquote>
<p>
<b>Note:</b> Depending on the Lisp, you might need to use <code>(funcall x x)</code> instead of
<code>(x x)</code>, since variables and functions don&rsquo;t share the same namespace. You can
search about the differences between Lisp-1 and Lisp-2.
</p>
</blockquote>

<p>
Or in JavaScript:
</p>

<div class="org-src-container">
<pre class="src src-javascript">((x) =&gt; x(x))((x) =&gt; x(x))
</pre>
</div>

<p>
We can see that the two parenthesized expressions are identical, and that the
first is applied to the second one. Let&rsquo;s try to simplify it by
&beta;-reduction. The first parenthesized expression, is applied to the second
one. We replace each occurrence of \(x\) in the body of the first expression with
the whole second parenthesized expression.
</p>


<div id="fig1" class="figure">
<p><img src="../img/ycombinator1.png" alt="ycombinator1.png" />
</p>
</div>

<p>
We are right back where we started. This function would call itself
indefinitely, and a similar form will be used for the Y combinator below.
</p>
</div>
</div>

<div id="outline-container-fixed-points" class="outline-2">
<h2 id="fixed-points"><span class="section-number-2">5.</span> Fixed points</h2>
<div class="outline-text-2" id="text-fixed-points">
<p>
Before getting into the fixed-point combinators, we need to define what a fixed
point is.
</p>

<p>
A fixed point of function \(f\) is a value that is mapped to itself by the
function.<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> In other words, \(x\) is a
fixed point of \(f\) if \(f(x) = x\). For this to be possible, \(x\) has to belong to
both the <i>domain</i> of \(f\) (set of values that it can take), and the <i>codomain</i> of \(f\)
(set of values that it can return).
</p>

<p>
For example, if \(f(x) = x!\), 1 and 2 are fixed points, since \(f(1) = 1\) and
\(f(2) = 2\).
</p>


<div id="fig2" class="figure">
<p><img src="../img/ycombinator2.png" alt="ycombinator2.png" width="250px" />
</p>
</div>

<p>
The image shows the graph of a function \(f\), with 3 fixed points. When plotting
with \(y = f(x)\), these 3 points were also on the line \(x = y\).
</p>

<p>
For example, for some functions \(f\), we can locate a fixed point by beginning
with an initial guess and applying \(f\) repeatedly.
</p>

<p>
\[
f(x),\quad f(f(x)),\quad f(f(f(x))),\quad \dots,
\]
</p>

<p>
We would do that until the value doesn&rsquo;t change very much, and we are satisfied
with the result.
</p>
</div>
</div>

<div id="outline-container-fixed-point-combinators" class="outline-2">
<h2 id="fixed-point-combinators"><span class="section-number-2">6.</span> Fixed-point combinators</h2>
<div class="outline-text-2" id="text-fixed-point-combinators">
<p>
A <b>fixed-point combinator</b> is a higher-order function (i.e. a function that takes
a function as argument) that returns some fixed point of its argument
function.<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>
</p>

<p>
So, if a function <code>fix</code> is a fixed-point combinator, a function <code>f</code> has one or
more fixed points, then <code>fix(f)</code> is one of these fixed points:
</p>

<p>
\[
f(\text{fix}\ f) = \text{fix}\ f
\]
</p>

<p>
In lambda calculus, every function has a fixed point.
</p>
</div>
</div>

<div id="outline-container-y-combinator" class="outline-2">
<h2 id="y-combinator"><span class="section-number-2">7.</span> Y combinator</h2>
<div class="outline-text-2" id="text-y-combinator">
<p>
An example of a fixed-point combinator is the Y combinator. This is the
definition of \(Y\).
</p>

<p>
\[
Y = \lambda f. \big(\lambda x. f (x\ x)\big) \big(\lambda x. f (x\ x)\big)
\]
</p>

<p>
Or in Scheme:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">Y</span>
  <span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #44bc44;">(</span>f<span style="color: #44bc44;">)</span>
    <span style="color: #44bc44;">(</span><span style="color: #00eff0;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #338fff;">(</span>x<span style="color: #338fff;">)</span> <span style="color: #338fff;">(</span>f <span style="color: #ef7fff;">(</span>x x<span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span>
     <span style="color: #00eff0;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #338fff;">(</span>x<span style="color: #338fff;">)</span> <span style="color: #338fff;">(</span>f <span style="color: #ef7fff;">(</span>x x<span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<blockquote>
<p>
<b>Note:</b> This version is not accurate, see <a href="#implementation-in-scheme">Implementation in Scheme</a> below.
</p>
</blockquote>

<p>
Or in JavaScript:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff6f9f;">var</span> <span style="color: #6ae4b9;">Y</span> = (f) =&gt;
    ((x) =&gt; f(x(x)))(
     (x) =&gt; f(x(x)));
</pre>
</div>

<p>
Since it&rsquo;s a fixed-point combinator, calling \(Y\) with a function as its
argument would be reduced to \(Y\ f = f(Y\ f)\). This is a very interesting and
useful concept, and it&rsquo;s where this image comes from.
</p>


<div id="fig3" class="figure">
<p><img src="../img/ycombinator3.png" alt="ycombinator3.png" width="250px" />
</p>
</div>

<p>
Let&rsquo;s try to understand what it does, and why it&rsquo;s a fixed-point combinator. We
are saying that \(Y\) is a function that takes one parameter \(f\). The body
consists of the same lambda term applied to itself: \((\lambda x. f(x\ x))\). You
may realize why we explained how to do <a href="#simple-recursion-with-anonymous-functions">recursion with anonymous functions</a>
earlier. A similar principle applies here, but we are also calling the \(f\)
function.
</p>

<p>
Let&rsquo;s simplify it with &beta;-reduction step by step:
</p>

\begin{align*}
Y\ g &= \lambda f. \big(\lambda x. f (x\ x)\big) \big(\lambda x. f (x\ x)\big) g
        && \text{By definition of } Y \\
     &= \big(\lambda x. g (x\ x)\big) \big(\lambda x. g (x\ x)\big)
        && \text{By beta reduction: Replacing } f \text{ of } Y \text{ with } g \\
     &= g \Big(\big(\lambda x. g (x\ x)\big) \big(\lambda x. g (x\ x)\big)\Big)
        && \text{By beta reduction: Replacing } x \text{ of the first function with } \big(\lambda x. g (x\ x)\big) \\
     &= g (Y\ g)
        && \text{By equality}
\end{align*}

<p>
Note how the reduction on the third step is applying \(g\) to the same expression
in the second step, which we know is equal to \(Y\ g\). That&rsquo;s how we can verify
that \(Y\ g = g(Y\ g)\).
</p>

<p>
An alternative (and slightly simpler) version of the Y combinator is the
following:
</p>

<p>
\[
X = \lambda f. (\lambda x. x\ x) (\lambda x. f(x\ x))
\]
</p>

<p>
Notice how the first call to \(f\) was not necessary, since this expression also
&beta;-evaluates to the Y combinator.
</p>
</div>
</div>

<div id="outline-container-applications-of-the-y-combinator" class="outline-2">
<h2 id="applications-of-the-y-combinator"><span class="section-number-2">8.</span> Applications of the Y combinator</h2>
<div class="outline-text-2" id="text-applications-of-the-y-combinator">
<p>
You might be wondering what makes the Y combinator so special. As we said,
lambda calculus doesn&rsquo;t have any kind of &ldquo;global symbols&rdquo;, therefore a function
can&rsquo;t reference itself by name. Let&rsquo;s go back to the factorial example in
Scheme.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">fact</span>
  <span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #44bc44;">(</span>n<span style="color: #44bc44;">)</span>
    <span style="color: #44bc44;">(</span><span style="color: #ff6f9f;">if</span> <span style="color: #00eff0;">(</span>equal? n <span style="color: #88ca9f;">0</span><span style="color: #00eff0;">)</span>
        <span style="color: #88ca9f;">1</span>
        <span style="color: #00eff0;">(</span>* n <span style="color: #338fff;">(</span>fact <span style="color: #ef7fff;">(</span>- n <span style="color: #88ca9f;">1</span><span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
This recursive form is possible because the <code>fact</code> function can reference itself
by name. More specifically, because a lambda body is evaluated whenever a <i>call</i>
is made, and by that time the <code>fact</code> symbol is already bound to the lambda, and
therefore the body can reference it. In OCaml, for example, the <code>rec</code> keyword is
needed when defining a recursive function to denote that it will reference
itself, and not an external function with the same name.
</p>

<p>
The Y combinator allows us to call a function recursively in a language that
<i>doesn&rsquo;t implement recursion</i>. Let&rsquo;s have a look at an alternative form of <code>fact</code>.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">fact-generator</span>
  <span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #44bc44;">(</span>self<span style="color: #44bc44;">)</span>        <span style="color: #989898;">; </span><span style="color: #989898;">Outer lambda (fact-generator)</span>
    <span style="color: #44bc44;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #00eff0;">(</span>n<span style="color: #00eff0;">)</span>         <span style="color: #989898;">; </span><span style="color: #989898;">Inner lambda (returned by fact-generator)</span>
      <span style="color: #00eff0;">(</span><span style="color: #ff6f9f;">if</span> <span style="color: #338fff;">(</span>equal? n <span style="color: #88ca9f;">0</span><span style="color: #338fff;">)</span>
          <span style="color: #88ca9f;">1</span>
          <span style="color: #338fff;">(</span>* n <span style="color: #ef7fff;">(</span>self <span style="color: #ff5f59;">(</span>- n <span style="color: #88ca9f;">1</span><span style="color: #ff5f59;">)</span><span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
Let&rsquo;s carefully look at what we just defined. We are defining <code>fact-generator</code> as
the outer lambda, a function with one argument <code>self</code>. This function <i>does not</i>
return the factorial of a number, but instead returns another <i>another lambda
function</i> that will receive a number <code>n</code>, and return its factorial.
</p>

<p>
This inner lambda, the one that will be returned when calling <code>fact-generator</code>, is
essentially the same as our previous <code>fact</code> function, but this time it&rsquo;s able to
use recursion <i>without</i> referencing itself by name by accessing the <code>self</code> parameter
of the outer lambda.
</p>

<p>
The important detail is that <code>fact-generator</code> is supposed to <i>return</i> a factorial
function, but also expects to <i>receive</i> a factorial function as its <code>self</code>
parameter, which will be used whenever the inner lambda wants to make a
&ldquo;recursive&rdquo; call. How could we accomplish this? At first sight, we could try
something like this.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #989898;">;; </span><span style="color: #989898;">Wrong.</span>
<span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">fact</span>
  <span style="color: #cabf00;">(</span>fact-generator fact<span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
The code above is incorrect because of how Scheme evaluates the arguments. When
evaluating the <code>define</code> expression, it will first try to evaluate the call to
<code>fact-generator</code>, but before that it must evaluate its argument, the <code>fact</code>
symbol. Since at this point <code>fact</code> isn&rsquo;t defined (we are trying to do just that),
Scheme will show an &ldquo;Unbound variable&rdquo; error.
</p>

<p>
Since the <code>fact-generator</code> function expects a function for calculating the
factorial, but also returns one, we are looking for something like:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">fact</span>
  <span style="color: #cabf00;">(</span>fact-generator <span style="color: #44bc44;">(</span>fact-generator <span style="color: #00eff0;">(</span>fact-generator ...<span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
Does that look familiar? Indeed, this is just what the Y combinator allows us to
do.
</p>
</div>
</div>

<div id="outline-container-implementation-in-scheme" class="outline-2">
<h2 id="implementation-in-scheme"><span class="section-number-2">9.</span> Implementation in Scheme</h2>
<div class="outline-text-2" id="text-implementation-in-scheme">
<p>
Our Scheme version of the Y combinator was not really correct. Evaluation in
Scheme (and most Lisps) is <i>strict</i>, meaning that each argument is evaluated
<i>before</i> applying the function. This is not a problem in lambda calculus.
</p>
</div>

<div id="outline-container-beta-abstraction-in-scheme" class="outline-3">
<h3 id="beta-abstraction-in-scheme"><span class="section-number-3">9.1.</span> Delaying evaluation with beta abstraction</h3>
<div class="outline-text-3" id="text-beta-abstraction-in-scheme">
<p>
Defining <code>Y</code> like we did before would result in infinite recursive calls when
trying to apply the <code>(x x)</code> expressions. This will be more obvious when analyzing
the combinator below, so let&rsquo;s look at a possible solution first. We can fix our
Y combinator by <b>beta abstracting</b><sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> those two applications.
</p>

<blockquote>
<p>
<b>JAO&rsquo;s blog about the Y-combinator in Scheme (2014)</b>
</p>

<p>
If you have a function <code>F</code> in Scheme, you can define a totally equivalent function
<code>G</code> by <code>(define G (lambda (args) (F args)))</code>. We say that <code>G</code> is a <i>beta abstraction</i> of
<code>F</code>, or that <code>F</code> is a <i>beta reduction</i> of <code>G</code>.
</p>

<p>
The usual reason you would beta abstract a function in Scheme is in order to
delay the evaluation of its body, just what the doctor ordered.
</p>
</blockquote>

<p>
We can add this beta abstraction to the <code>(x x)</code> applications, effectively acting
as a &ldquo;proxy&rdquo;.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">Y</span>
  <span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #44bc44;">(</span>f<span style="color: #44bc44;">)</span>
    <span style="color: #44bc44;">(</span><span style="color: #00eff0;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #338fff;">(</span>x<span style="color: #338fff;">)</span> <span style="color: #338fff;">(</span>f <span style="color: #ef7fff;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #ff5f59;">(</span>n<span style="color: #ff5f59;">)</span> <span style="color: #ff5f59;">(</span><span style="color: #cabf00;">(</span>x x<span style="color: #cabf00;">)</span> n<span style="color: #ff5f59;">)</span><span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span>
     <span style="color: #00eff0;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #338fff;">(</span>x<span style="color: #338fff;">)</span> <span style="color: #338fff;">(</span>f <span style="color: #ef7fff;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #ff5f59;">(</span>n<span style="color: #ff5f59;">)</span> <span style="color: #ff5f59;">(</span><span style="color: #cabf00;">(</span>x x<span style="color: #cabf00;">)</span> n<span style="color: #ff5f59;">)</span><span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
Now, since the <code>(x x)</code> expression is inside the body of this &ldquo;proxy&rdquo; lambda, it
will not be evaluated until the proxy is called. This is not easy to understand,
so so let&rsquo;s try to visualize the evaluation process of a call to our <code>Y</code> function.
</p>
</div>
</div>

<div id="outline-container-evaluation-process-of-our-y-combinator" class="outline-3">
<h3 id="evaluation-process-of-our-y-combinator"><span class="section-number-3">9.2.</span> Evaluation process of our Y combinator</h3>
<div class="outline-text-3" id="text-evaluation-process-of-our-y-combinator">
<p>
The following diagram represents the evaluation of a call to our <code>Y</code>
function. Specifically, applying the first inner lambda to its copy. Note that
this isn&rsquo;t the actual process that a Scheme interpreter would follow, instead I
have decided to make some changes to make it easier to understand.
</p>


<div id="fig4" class="figure">
<p><img src="../img/ycombinator4.svg" alt="ycombinator4.svg" class="org-svg" />
</p>
</div>

<p>
Let me explain briefly each step of the diagram.
</p>

<ol class="org-ol">
<li>The black lambda receives a copy of itself (gray lambda) as the argument
<code>x</code>. We have seen this <a href="#simple-recursion-with-anonymous-functions">above</a> with the \((\lambda x. x\ x)(\lambda x. x\ x)\)
expression.</li>
<li>With some <i>wishful thinkingâ„¢</i>, since we know that <code>x</code> is a copy of the current
expression, we can assume that the result of the green <code>(x x)</code> expression is
whatever the current black expression returns. For now, it&rsquo;s better to assume
that the value returned when calling <code>x</code> is <code>fact</code>, since this will be explained
in more detail below.</li>
<li>The blue <code>(lambda (n) (fact n))</code> expression acts as a proxy, receiving some
arguments, in this case <code>n</code>, and calling <code>fact</code> with them. We name this simple
lambda <code>fact-proxy</code>, since calling it is essentially the same as calling <code>fact</code>.</li>
<li>We know that <code>f</code> is the function that has been passed to <code>Y</code>, in this case
<code>fact-generator</code>. We substitute it for readability, along with substituting
<code>fact-proxy</code> with just <code>fact</code>.</li>
<li>Finally, the expression <code>(fact-generator fact)</code> gets passed to another lambda,
or returned by <code>Y</code>, depending on whether or not we are the first call in the
recursive cycle.</li>
</ol>

<p>
At this point, although there are some parts that might not be very clear, we
can believe that <code>(Y fact-generator)</code> is the same as
<code>(fact-generator (fact-generator ...))</code>, which returns a recursive <code>fact</code>
function, even though <code>fact</code> has not been defined yet.
</p>

<p>
Now that we can see that the black expression effectively returns <code>fact</code>, you can
verify that the second point was true. The <code>(x x)</code> expression is calling <code>x</code> with a
copy of itself (the gray expression) as argument. That argument will be used for
looping recursively, as mentioned in point one. Therefore, the call to <code>x</code> returns
<code>fact</code>, and that&rsquo;s why we were able to replace it on point two.
</p>

<p>
By wishful thinking, we know the <code>(x x)</code> call returns <code>fact</code>, but since evaluation
in Scheme is strict, it will try to evaluate the call to <code>x</code>, which also contains
another call to <code>x</code>, and so on. That&rsquo;s what the <code>fact-proxy</code> is for.
</p>

<p>
With this example, you can also realize that the following expression makes more
sense now.
</p>

\begin{align*}
Y f &= f (Y f) \\
    &= f (f (f (\dots)))
\end{align*}

<p>
Which is just what we wanted to achieve earlier.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">fact</span>
  <span style="color: #cabf00;">(</span>fact-generator <span style="color: #44bc44;">(</span>fact-generator <span style="color: #00eff0;">(</span>fact-generator ...<span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-complete-scheme-example" class="outline-3">
<h3 id="complete-scheme-example"><span class="section-number-3">9.3.</span> Complete Scheme example</h3>
<div class="outline-text-3" id="text-complete-scheme-example">
<p>
Finally, we can <a href="https://try.scheme.org/">try</a> our full example.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">Y</span>
  <span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #44bc44;">(</span>f<span style="color: #44bc44;">)</span>
    <span style="color: #44bc44;">(</span><span style="color: #00eff0;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #338fff;">(</span>x<span style="color: #338fff;">)</span> <span style="color: #338fff;">(</span>f <span style="color: #ef7fff;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #ff5f59;">(</span>n<span style="color: #ff5f59;">)</span> <span style="color: #ff5f59;">(</span><span style="color: #cabf00;">(</span>x x<span style="color: #cabf00;">)</span> n<span style="color: #ff5f59;">)</span><span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span>
     <span style="color: #00eff0;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #338fff;">(</span>x<span style="color: #338fff;">)</span> <span style="color: #338fff;">(</span>f <span style="color: #ef7fff;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #ff5f59;">(</span>n<span style="color: #ff5f59;">)</span> <span style="color: #ff5f59;">(</span><span style="color: #cabf00;">(</span>x x<span style="color: #cabf00;">)</span> n<span style="color: #ff5f59;">)</span><span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>

<span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">fact-generator</span>
  <span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #44bc44;">(</span>self<span style="color: #44bc44;">)</span>
    <span style="color: #44bc44;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #00eff0;">(</span>n<span style="color: #00eff0;">)</span>
      <span style="color: #00eff0;">(</span><span style="color: #ff6f9f;">if</span> <span style="color: #338fff;">(</span>equal? n <span style="color: #88ca9f;">0</span><span style="color: #338fff;">)</span>
          <span style="color: #88ca9f;">1</span>
          <span style="color: #338fff;">(</span>* n <span style="color: #ef7fff;">(</span>self <span style="color: #ff5f59;">(</span>- n <span style="color: #88ca9f;">1</span><span style="color: #ff5f59;">)</span><span style="color: #ef7fff;">)</span><span style="color: #338fff;">)</span><span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>

<span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">fact</span>
  <span style="color: #cabf00;">(</span>Y fact-generator<span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>

<span style="color: #ff5f59;">(</span>fact <span style="color: #88ca9f;">5</span><span style="color: #ff5f59;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-final-note" class="outline-2">
<h2 id="final-note"><span class="section-number-2">10.</span> Final note</h2>
<div class="outline-text-2" id="text-final-note">
<p>
If you reached this far, I hope you have learned something. Everything in this
article is based on what I found while trying to learn about the Y combinator,
so if you feel like some explanations could be improved, feel free to
<a href="../index.html#contributing">contribute</a>.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">See the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">Wikipedia page</a> for lambda calculus.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">See the <a href="https://en.wikipedia.org/wiki/Extensionality">Wikipedia page</a> for extensionality.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">See the <a href="https://en.wikipedia.org/wiki/Fixed_point_(mathematics)">Wikipedia page</a> for fixed point.</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">See the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">Wikipedia page</a> for fixed-point combinator.</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">See <a href="https://jao.io/blog/2014/08/06/spj-s-y-combinator-in-scheme/">jao.io</a> article about the Y combinator
in Scheme, and about how to design good websites.</p></div></div>


</div>
</div></div>
</body>
</html>
