<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding the Y combinator</title>
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../css/main.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Understanding the Y combinator</h1>
<p>
<a href="../index.html">Index</a> | <a href="index.html">Up</a>
</p>

<hr />

<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#quick-introduction-to-lambda-calculus">1. Quick introduction to lambda calculus</a>
<ul>
<li><a href="#rules">1.1. Rules</a></li>
<li><a href="#lambda-terms">1.2. Lambda terms</a></li>
<li><a href="#reduction-operations">1.3. Reduction operations</a></li>
<li><a href="#notation">1.4. Notation</a></li>
</ul>
</li>
<li><a href="#sicp-lisp-and-javascript">2. SICP, Lisp and JavaScript</a></li>
<li><a href="#simple-example-factorial">3. Simple example: Factorial</a></li>
<li><a href="#simple-recursion-with-anonymous-functions">4. Simple recursion with anonymous functions</a></li>
<li><a href="#fixed-points">5. Fixed points</a></li>
<li><a href="#fixed-point-combinators">6. Fixed-point combinators</a></li>
<li><a href="#y-combinator">7. Y combinator</a></li>
</ul>
</div>
</div>

<div id="outline-container-quick-introduction-to-lambda-calculus" class="outline-2">
<h2 id="quick-introduction-to-lambda-calculus"><span class="section-number-2">1.</span> Quick introduction to lambda calculus</h2>
<div class="outline-text-2" id="text-quick-introduction-to-lambda-calculus">
<p>
<b>Lambda calculus</b> (&lambda;-calculus) is a mathematical system for computation
based on <span class="underline">function abstraction</span> and <span class="underline">application</span>, using <span class="underline">variable binding</span> and
substitution.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>
</div>

<div id="outline-container-rules" class="outline-3">
<h3 id="rules"><span class="section-number-3">1.1.</span> Rules</h3>
<div class="outline-text-3" id="text-rules">
<p>
The beauty of lambda calculus is its simplicity. These are the only 3 rules:
</p>

<ol class="org-ol">
<li>\(x\): A <b>variable</b> represents a parameter.</li>
<li>\((\lambda x. M)\): A <b>lambda abstraction</b> is an anonymous function, with a
parameter \(x\) (between the &lambda; and the dot), that returns the body \(M\).</li>
<li>\((M\ N)\): An <b>application</b> of function \(M\) to an argument \(N\).</li>
</ol>

<p>
In the last rule, both \(M\) and \(N\) are lambda terms.
</p>
</div>
</div>

<div id="outline-container-lambda-terms" class="outline-3">
<h3 id="lambda-terms"><span class="section-number-3">1.2.</span> Lambda terms</h3>
<div class="outline-text-3" id="text-lambda-terms">
<p>
A <b>lambda term</b> is just a valid expression in the lambda calculus system. Well,
what makes an expression valid? The following 3 rules are used to determine if a
lambda expression is valid:
</p>

<ol class="org-ol">
<li>A <b>variable</b> \(x\) is itself a valid lambda term.</li>
<li>If \(M\) is a lambda term, and \(x\) is a variable, then \((\lambda x. M)\) is also
a lambda term (An <b>abstraction</b>).</li>
<li>If \(M\) and \(N\) are lambda terms, then \((M\ N)\) is also a lambda term (An
<b>application</b>).</li>
</ol>

<p>
You can begin to feel the recursive magic of lambda calculus, before even
getting into an example.
</p>
</div>
</div>

<div id="outline-container-reduction-operations" class="outline-3">
<h3 id="reduction-operations"><span class="section-number-3">1.3.</span> Reduction operations</h3>
<div class="outline-text-3" id="text-reduction-operations">
<p>
Lambda calculus also has 2 main reduction operations:
</p>

<ol class="org-ol">
<li>\((\lambda x. M[x])\) &rarr; \((\lambda y. M[y])\): <b>Alpha conversion</b>
(&alpha;-conversion), renaming the bound variables in the expression. Used to
avoid name collisions.</li>
<li>\(((\lambda x. M) N)\) &rarr; \((M[x := N])\): <b>Beta reduction</b> (&beta;-reduction),
replacing the bound variables (\(x\)) with the argument expression (\(N\)) in the
body (\(M\)) of the abstraction.</li>
</ol>

<p>
There is also <b>eta reduction</b> (&eta;-reduction), which expresses the idea of
<i>extensionality</i>,<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> which applied to this context establishes that two
functions are the same if and only if they give the same result for all
arguments.
</p>
</div>
</div>

<div id="outline-container-notation" class="outline-3">
<h3 id="notation"><span class="section-number-3">1.4.</span> Notation</h3>
<div class="outline-text-3" id="text-notation">
<p>
For understanding lambda notation, you will also have to keep in mind these
conventions:
</p>

<ol class="org-ol">
<li>Outermost parentheses are dropped: \(M N\) instead of \((M N)\).</li>
<li>Applications are assumed to be left associative: \(M N P\) instead of
\(((M N) P)\).</li>
<li>The body of an abstraction extends as far right as possible:
\((\lambda x. M N)\) means \((\lambda x. (M N))\) and not \(((\lambda x. M) N)\).</li>
<li>A sequence of abstractions is contracted:
\((\lambda x. \lambda y. \lambda z. N)\) is abbreviated as
\((\lambda x\ y\ z. N)\).</li>
<li>When all variables are single-letter, the space in applications may be
omitted: \((M N P)\) instead of \((M\ N\ P)\).</li>
</ol>

<p>
Some of these look a bit confusing to me, specially when embedding expressions
in text, so I will try to make each expression as readable as possible.
</p>
</div>
</div>
</div>

<div id="outline-container-sicp-lisp-and-javascript" class="outline-2">
<h2 id="sicp-lisp-and-javascript"><span class="section-number-2">2.</span> SICP, Lisp and JavaScript</h2>
<div class="outline-text-2" id="text-sicp-lisp-and-javascript">
<p>
<a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">Structure and Interpretation of Computer Programs</a> is an amazing book by Harold
Abelson and Gerald Jay Sussman. The book teaches the fundamental principles of
computer programming, including recursion, abstraction, modularity, and much
more. I recommend the book to anyone who is interested in programming, I am sure
they will learn something.
</p>

<p>
This book has two editions. The first one uses <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> (a dialect of <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>), for
its examples and explanations, while the second uses <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>. I have not
programmed much in JavaScript at the time of writing this, but I will try to
provide all examples in both lambda notation, Scheme and JavaScript.
</p>

<p>
At one point, in section 1.3.3, they talk about finding fixed points of
functions. This was the first time I heard about this, and it's what mainly
motivated me to write this article. If you are interested on the general Lisp
approach, and not on the Y combinator itself, I recommend you check it out.
</p>

<p>
One of the most valuable things that SICP has taught me is that sometimes it's
extremely useful to treat functions as black boxes that are able to transform
some inputs into some outputs. This has been useful not only when using
functions, but also when designing them.
</p>
</div>
</div>

<div id="outline-container-simple-example-factorial" class="outline-2">
<h2 id="simple-example-factorial"><span class="section-number-2">3.</span> Simple example: Factorial</h2>
<div class="outline-text-2" id="text-simple-example-factorial">
<p>
This is the function for calculating the factorial of a number \(n\), using the
lambda calculus notation:
</p>

<p>
\[
\text{fact} = \lambda n. \Big(\Big(\text{iszero}\ n\Big) 1 \Big(\text{mult}\ n
\ \big(\text{fact}\ (\text{prec}\ n)\big)\Big)\Big)
\]
</p>

<p>
In Scheme:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">fact</span>
  <span style="color: #2fafff;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #cabf00;">(</span>n<span style="color: #cabf00;">)</span>
    <span style="color: #cabf00;">(</span><span style="color: #ff6f9f;">if</span> <span style="color: #44bc44;">(</span>equal? n <span style="color: #88ca9f;">0</span><span style="color: #44bc44;">)</span>
        <span style="color: #88ca9f;">1</span>
        <span style="color: #44bc44;">(</span>mult n <span style="color: #ff5f59;">(</span>fact <span style="color: #2fafff;">(</span>prec n<span style="color: #2fafff;">)</span><span style="color: #ff5f59;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #2fafff;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
Or in JavaScript:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff6f9f;">var</span> <span style="color: #6ae4b9;">fact</span> = (n) =&gt; (n == <span style="color: #88ca9f;">0</span>)
    ? <span style="color: #88ca9f;">1</span>
    : mult(n, (fact(prec(n))));
</pre>
</div>

<p>
We are defining <code>fact</code> as a function that takes a parameter <code>n</code>. This function
returns 1 if <code>n</code> is zero, and otherwise multiplies <code>n</code> by the factorial of the
number preceding <code>n</code>.
</p>

<p>
In this case, we can simply ignore how <code>iszero</code>, <code>mult</code>, <code>prec</code> and even <code>fact</code> work
<i>internally</i>, we just have to trust that they do what we expect. Another useful
way of thinking about lambda calculus and Lisp in general is as a language for
expressing processes.
</p>

<p>
In any case, we don't have those name-defining commodities in lambda calculus. A
function can't call itself by name, so we will have to find an alternative way.
</p>
</div>
</div>

<div id="outline-container-simple-recursion-with-anonymous-functions" class="outline-2">
<h2 id="simple-recursion-with-anonymous-functions"><span class="section-number-2">4.</span> Simple recursion with anonymous functions</h2>
<div class="outline-text-2" id="text-simple-recursion-with-anonymous-functions">
<p>
Before trying to understand the Y combinator, let's have a look at an example of
how an anonymous function might call itself without the need for symbols.
</p>

<p>
\[
(\lambda x. x\ x)(\lambda x. x\ x)
\]
</p>

<p>
Or in Scheme:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #2fafff;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #cabf00;">(</span>x<span style="color: #cabf00;">)</span> <span style="color: #cabf00;">(</span>x x<span style="color: #cabf00;">)</span><span style="color: #2fafff;">)</span>
 <span style="color: #2fafff;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #cabf00;">(</span>x<span style="color: #cabf00;">)</span> <span style="color: #cabf00;">(</span>x x<span style="color: #cabf00;">)</span><span style="color: #2fafff;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<blockquote>
<p>
<b>Note:</b> Depending on the Lisp, you might need to use <code>(funcall x x)</code> instead of
<code>(x x)</code>, since variables and functions don't share the same namespace. You can
search about the differences between Lisp-1 and Lisp-2.
</p>
</blockquote>

<p>
Or in JavaScript:
</p>

<div class="org-src-container">
<pre class="src src-javascript">((x) =&gt; x(x))((x) =&gt; x(x))
</pre>
</div>

<p>
We can see that the two parenthesized expressions are identical, and that the
first is applied to the second one. Let's try to simplify it by
&beta;-reduction. The first parenthesized expression, is applied to the second
one. We replace each occurrence of \(x\) in the body of the first expression with
the whole second parenthesized expression.
</p>


<div id="orga425c4c" class="figure">
<p><img src="../img/ycombinator1.png" alt="ycombinator1.png" />
</p>
</div>

<p>
We are right back where we started. This function would call itself
indefinitely, and a similar form will be used for the Y combinator bellow.
</p>
</div>
</div>
<div id="outline-container-fixed-points" class="outline-2">
<h2 id="fixed-points"><span class="section-number-2">5.</span> Fixed points</h2>
<div class="outline-text-2" id="text-fixed-points">
<p>
Before getting into the fixed-point combinators, we need to define what a fixed
point is.
</p>

<p>
A fixed point of function \(f\) is a value that is mapped to itself by the
function.<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> In other words, \(x\) is a fixed point of \(f\) if \(f(x) = x\). For
this to be possible, \(x\) has to belong to both the <span class="underline">domain</span> of \(f\) (set of values
that it can take), and the <span class="underline">codomain</span> of \(f\) (set of values that it can return).
</p>

<p>
For example, if \(f(x) = x!\), 1 and 2 are fixed points, since \(f(1) = 1\) and
\(f(2) = 2\).
</p>


<div id="org4c331b4" class="figure">
<p><img src="../img/ycombinator2.png" alt="ycombinator2.png" width="250px" />
</p>
</div>

<p>
The image shows the graph of a function \(f\), with 3 fixed points. When plotting
with \(y = f(x)\), these 3 points were also on the line \(x = y\).
</p>

<p>
For example, for some functions \(f\), we can locate a fixed point by beginning
with an initial guess and applying \(f\) repeatedly.
</p>

<p>
\[
f(x),\quad f(f(x)),\quad f(f(f(x))),\quad ...,
\]
</p>

<p>
We would do that until the value doesn't change very much, and we are satisfied
with the result.
</p>
</div>
</div>

<div id="outline-container-fixed-point-combinators" class="outline-2">
<h2 id="fixed-point-combinators"><span class="section-number-2">6.</span> Fixed-point combinators</h2>
<div class="outline-text-2" id="text-fixed-point-combinators">
<p>
A <b>fixed-point combinator</b> is a higher-order function (i.e. a function that takes
a function as argument) that returns some fixed point of its argument
function.<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>
</p>

<p>
So, if a function <code>fix</code> is a fixed-point combinator, a function <code>f</code> has one or
more fixed points, then <code>fix(f)</code> is one of these fixed points:
</p>

<p>
\[
f(\text{fix}\ f) = \text{fix}\ f
\]
</p>

<p>
In lambda calculus, every function has a fixed point.
</p>
</div>
</div>

<div id="outline-container-y-combinator" class="outline-2">
<h2 id="y-combinator"><span class="section-number-2">7.</span> Y combinator</h2>
<div class="outline-text-2" id="text-y-combinator">
<p>
An example of a fixed-point combinator is the Y combinator. This is the
definition of \(Y\).
</p>

<p>
\[
Y = \lambda f. \big(\lambda x. f (x\ x)\big) \big(\lambda x. f (x\ x)\big)
\]
</p>

<p>
Or in Scheme:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #ff5f59;">(</span><span style="color: #ff6f9f;">define</span> <span style="color: #4ae2ff;">Y</span>
  <span style="color: #2fafff;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #cabf00;">(</span>f<span style="color: #cabf00;">)</span>
    <span style="color: #cabf00;">(</span><span style="color: #44bc44;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #ff5f59;">(</span>x<span style="color: #ff5f59;">)</span> <span style="color: #ff5f59;">(</span>f <span style="color: #2fafff;">(</span>x x<span style="color: #2fafff;">)</span><span style="color: #ff5f59;">)</span><span style="color: #44bc44;">)</span>
     <span style="color: #44bc44;">(</span><span style="color: #ff6f9f;">lambda</span> <span style="color: #ff5f59;">(</span>x<span style="color: #ff5f59;">)</span> <span style="color: #ff5f59;">(</span>f <span style="color: #2fafff;">(</span>x x<span style="color: #2fafff;">)</span><span style="color: #ff5f59;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #2fafff;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
Or in JavaScript:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff6f9f;">var</span> <span style="color: #6ae4b9;">Y</span> = (f) =&gt; ((x) =&gt; f(x(x)))((x) =&gt; f(x(x)));
</pre>
</div>

<p>
Since it's a fixed-point combinator, calling \(Y\) with a function as its
argument would be reduced to \(Y\ f = f(Y\ f)\). This is a very interesting and
useful concept, and it's where this image comes from.
</p>


<div id="org58d9902" class="figure">
<p><img src="../img/ycombinator3.png" alt="ycombinator3.png" width="250px" />
</p>
</div>

<p>
Let's try to understand what it does, and why it's a fixed-point combinator. We
are saying that \(Y\) is a function that takes one parameter \(f\). The body
consists of the same lambda term applied to itself: \((\lambda x. f(x\ x))\). You
may realize why we explained how to do <a href="#simple-recursion-with-anonymous-functions">recursion with anonymous functions</a>
earlier. A similar principle applies here, but we are also calling the \(f\)
function.
</p>

<p>
Let's simplify it with &beta;-reduction step by step:
</p>

\begin{align*}
Y\ g &= \lambda f. \big(\lambda x. f (x\ x)\big) \big(\lambda x. f (x\ x)\big) g
        && \text{By definition of } Y \\
     &= \big(\lambda x. g (x\ x)\big) \big(\lambda x. g (x\ x)\big)
        && \text{By beta reduction: Replacing } f \text{ of } Y \text{ with } g \\
     &= g \Big(\big(\lambda x. g (x\ x)\big) \big(\lambda x. g (x\ x)\big)\Big)
        && \text{By beta reduction: Replacing } x \text{ of the first function with } \big(\lambda x. g (x\ x)\big) \\
     &= g (Y\ g)
        && \text{By equality}
\end{align*}

<p>
Note how the reduction on the third step is applying \(g\) to the same expression
in the second step, which we know is equal to \(Y\ g\). That's how we can verify
that \(Y\ g = g(Y\ g)\).
</p>

<p>
An alternative (and slightly simpler) version of the Y combinator is the
following:
</p>

<p>
\[
X = \lambda f. (\lambda x. x\ x) (\lambda x. f(x\ x))
\]
</p>

<p>
Notice how the first call to \(f\) was not necessary, since this expression also
&beta;-evaluates to the Y combinator.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
See the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">Wikipedia page</a> for lambda calculus.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
See the <a href="https://en.wikipedia.org/wiki/Extensionality">Wikipedia page</a> for extensionality.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
See the <a href="https://en.wikipedia.org/wiki/Fixed_point_(mathematics)">Wikipedia page</a> for fixed point.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
See the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">Wikipedia page</a> for fixed-point combinator.
</p></div></div>


</div>
</div></div>
</body>
</html>
