<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Writing a simple pool allocator in C</title>
<meta property="og:title" content="Writing a simple pool allocator in C" />
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../css/main.css">
</head>
<body>
<div id="org-div-home-and-up">
  <a accesskey="u" href="index.html">Up</a> | <a accesskey="h" href="../index.html">Home</a>
</div><div id="content" class="content">
<h1 class="title">Writing a simple pool allocator in C</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#writing-the-initial-implementation">2. Writing the initial implementation</a>
<ul>
<li><a href="#the-chunk-type">2.1. The <code>Chunk</code> type</a></li>
<li><a href="#the-pool-structure">2.2. The <code>Pool</code> structure</a></li>
<li><a href="#creating-the-pool">2.3. Creating the pool</a></li>
<li><a href="#allocating-chunks">2.4. Allocating chunks</a></li>
<li><a href="#freeing-chunks">2.5. Freeing chunks</a></li>
<li><a href="#closing-the-pool">2.6. Closing the pool</a></li>
</ul>
</li>
<li><a href="#reallocation-problems">3. Reallocation problems</a></li>
<li><a href="#second-implementation-expanding-the-pool">4. Second implementation: Expanding the pool</a>
<ul>
<li><a href="#keeping-track-of-the-array-starts">4.1. Keeping track of the array starts</a></li>
<li><a href="#changes-to-pool-new-and-pool-close">4.2. Changes to <code>pool_new</code> and <code>pool_close</code></a></li>
<li><a href="#resizing-without-modifying-the-array">4.3. Resizing without modifying the array</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-introduction" class="outline-2">
<h2 id="introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
I found out about <a href="https://en.wikipedia.org/wiki/Memory_pool">pool allocators</a> some time ago, and I really liked its
simplicity and high performance, so I decided to write my own. This article was
initially inspired by <a href="http://dmitrysoshnikov.com/compilers/writing-a-pool-allocator/">Dmitry Soshnikov&rsquo;s article</a>. It&rsquo;s also worth mentioning
that this article was discussed in <a href="https://news.ycombinator.com/item?id=42605848">Hacker News</a>.
</p>

<p>
Similarly to <code>malloc</code>, a pool allocator allows the user to allocate memory at run
time. The pool allocator, however, is much faster than <code>malloc</code>, at the cost of
having a <i>fixed pool size</i>. It allows the user to allocate and free memory blocks
(referred to as <i>chunks</i>, from now on) in <i>O(1)</i> linear time. This implementation
also uses very little memory: when creating the pool, a very small <code>Pool</code>
structure is allocated, along with the pool itself. Free chunks are used to
store information, so the memory impact is minimal.
</p>

<p>
Lastly, I would like to mention that this article is based on my ANSI C library
for pool allocation, <a href="https://github.com/8dcc/libpool">libpool</a>. In the future, I might make small changes to the
code on that repository and they won&rsquo;t be reflected here, so feel free to check
it out as well.
</p>
</div>
</div>

<div id="outline-container-writing-the-initial-implementation" class="outline-2">
<h2 id="writing-the-initial-implementation"><span class="section-number-2">2.</span> Writing the initial implementation</h2>
<div class="outline-text-2" id="text-writing-the-initial-implementation">
<p>
The following implementation corresponds to version <a href="https://github.com/8dcc/libpool/blob/v1.0.0/src/libpool.c"><code>v1.0.0</code></a> of my <code>libpool</code>
library, with some notable &ldquo;visual&rdquo; differences (e.g. without ANSI
restrictions). Some improvements, like being able to resize/reallocate an
existing pool, will also be expanded <a href="#second-implementation-expanding-the-pool">below</a>.
</p>
</div>

<div id="outline-container-the-chunk-type" class="outline-3">
<h3 id="the-chunk-type"><span class="section-number-3">2.1.</span> The <code>Chunk</code> type</h3>
<div class="outline-text-3" id="text-the-chunk-type">
<p>
In our simple implementation, we will declare a <code>Chunk</code> type with a fixed size. In
a more general implementation, we would use a chunk size specified by the
programmer at runtime, but that method adds a lot of casts, and I think it would
make this article more confusing.
</p>

<p>
First, let&rsquo;s have a look at the definition of <code>Chunk</code>.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6740;">#define</span> <span style="color: #6ae4b9;">CHUNK_SZ</span> <span style="color: #88ca9f;">64</span>

<span style="color: #ff6f9f;">typedef</span> <span style="color: #ff6f9f;">union</span> <span style="color: #79a8ff;">Chunk</span> <span style="color: #79a8ff;">Chunk</span>;
<span style="color: #ff6f9f;">union</span> <span style="color: #79a8ff;">Chunk</span> {
    <span style="color: #79a8ff;">Chunk</span>* <span style="color: #6ae4b9;">next</span>;
    <span style="color: #79a8ff;">char</span> <span style="color: #6ae4b9;">arr</span>[CHUNK_SZ];
};
</pre>
</div>

<p>
Notice how we are <code>typedef</code>&rsquo;ing a <code>union</code>, not a <code>struct</code>.
</p>

<p>
If you are not familiar with C <code>union</code>&rsquo;s, they are syntactically similar to
<code>struct</code>&rsquo;s, but they can be used to define variables that may hold (at different
times) objects of different types and sizes; as opposed to structures, which let
the programmer <i>group</i> different data types as a single record. Unions essentially
let the programmer access the data in a <i>single area of storage</i> as if it were
storing one of many <i>data types</i> at a given time. When you access a <i>member</i> of a
union variable (e.g. <code>my_chunk.next</code> or <code>my_chunk.arr</code>), the compiler is responsible
for accessing the <code>union</code> variable as if it were the specified member type (in
that example, either a pointer or an array of <code>CHUNK_SZ</code> characters, never both).
</p>

<p>
In this case, using a <code>union</code> is convenient because it lets us &ldquo;interpret&rdquo; the
<code>Chunk</code> as a pointer to another <code>Chunk</code> depending on the context, while also
specifying the real size of the <code>Chunk</code> (i.e. <code>CHUNK_SZ</code>). Also note that the size
of a union is the size of the <i>biggest possible member</i> (in a 64-bit computer,
<code>sizeof(Chunk*)</code> is 8 bytes, and since the <code>arr</code> member is 64 bytes, that will be
the size of the <code>Chunk</code> union).
</p>

<p>
However, it&rsquo;s still not clear why we would need to interpret the <code>Chunk</code> as a
pointer depending on the context. First, we need to understand that there will
be two (implicit) types of chunks:
</p>

<ol class="org-ol">
<li><b>Free chunks</b>: They are not in use by the program. They will use the <code>next</code>
pointer.</li>
<li><b>Non-free chunks</b>: They have been allocated, so we assume they contain
arbitrary user data. Specifically, in this implementation, each chunk can
contain (at most) <code>CHUNK_SZ</code> bytes of data.</li>
</ol>

<p>
As mentioned, these types are &ldquo;implicit&rdquo;. This means that there isn&rsquo;t any <code>flags</code>
variable that lets us know whether a specified chunk is free; instead, we know
that a chunk is free because it will be inside a <i>linked list</i> of free
chunks. When we initialize the pool, since all chunks are free, we will use the
<code>Chunk.next</code> pointer to link each chunk to its adjacent one, like this:
</p>


<div id="fig1" class="figure">
<p><img src="../img/pool-allocator1.svg" alt="pool-allocator1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 1: </span>Four free chunks right after initializing the pool.</p>
</div>

<p>
The gray area represents the rest of the union that is not used when accessing
<code>Chunk.next</code>, and the incomplete red arrow represents a <code>NULL</code> pointer. The creation
of this linked list, along with its advantages, will be explained when <a href="#creating-the-pool">creating
the pool</a> below.
</p>
</div>
</div>

<div id="outline-container-the-pool-structure" class="outline-3">
<h3 id="the-pool-structure"><span class="section-number-3">2.2.</span> The <code>Pool</code> structure</h3>
<div class="outline-text-3" id="text-the-pool-structure">
<p>
We will also declare a <code>Pool</code> structure, which simply contains:
</p>

<ol class="org-ol">
<li>A pointer to the first element of the linked list of free chunks, which will
be used when the user <a href="#allocating-chunks">allocates a chunk</a>.</li>
<li>A pointer to the first element of the chunk array, which will be used when
<a href="#closing-the-pool">closing the whole pool</a>.</li>
</ol>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">typedef</span> <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">Pool</span> <span style="color: #79a8ff;">Pool</span>;
<span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">Pool</span> {
    <span style="color: #79a8ff;">Chunk</span>* <span style="color: #6ae4b9;">free_chunk</span>;
    <span style="color: #79a8ff;">Chunk</span>* <span style="color: #6ae4b9;">chunk_arr</span>;
};
</pre>
</div>

<p>
Again, other members such as the chunks size might be necessary depending on the
implementation; in this case it&rsquo;s known at compile time.
</p>
</div>
</div>

<div id="outline-container-creating-the-pool" class="outline-3">
<h3 id="creating-the-pool"><span class="section-number-3">2.3.</span> Creating the pool</h3>
<div class="outline-text-3" id="text-creating-the-pool">
<p>
We will define a function for creating a <code>Pool</code> with an arbitrary number of
chunks.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">Pool</span>* <span style="color: #4ae2ff;">pool_new</span>(<span style="color: #79a8ff;">size_t</span> <span style="color: #6ae4b9;">pool_sz</span>) {
    <span style="color: #79a8ff;">Pool</span>* <span style="color: #6ae4b9;">pool</span> = malloc(<span style="color: #ff6f9f;">sizeof</span>(Pool));
    <span style="color: #ff6f9f;">if</span> (pool == <span style="color: #88ca9f;">NULL</span>)
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;

    pool-&gt;chunk_arr = pool-&gt;free_chunk = malloc(pool_sz * <span style="color: #ff6f9f;">sizeof</span>(Chunk));
    <span style="color: #ff6f9f;">if</span> (pool-&gt;chunk_arr == <span style="color: #88ca9f;">NULL</span>) {
        free(pool);
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;
    }

    <span style="color: #ff6f9f;">for</span> (<span style="color: #79a8ff;">size_t</span> <span style="color: #6ae4b9;">i</span> = <span style="color: #88ca9f;">0</span>; i &lt; pool_sz - <span style="color: #88ca9f;">1</span>; i++)
        pool-&gt;chunk_arr[i].next = &amp;pool-&gt;chunk_arr[i + <span style="color: #88ca9f;">1</span>];
    pool-&gt;chunk_arr[pool_sz - <span style="color: #88ca9f;">1</span>].next = <span style="color: #88ca9f;">NULL</span>;

    <span style="color: #ff6f9f;">return</span> pool;
}
</pre>
</div>

<p>
Here&rsquo;s a brief explanation of each step:
</p>

<ol class="org-ol">
<li>We allocate the <code>Pool</code> structure that will be returned, using <code>malloc</code><sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.</li>
<li>We allocate the pool itself, that is, the array of <code>Chunk</code> unions. We
initialize both <code>chunk_arr</code> and <code>free_chunk</code> pointers to the same address, since
all chunks will be free by default.</li>
<li>We build the linked list of free chunks. We set the <code>.next</code> member of the <code>Chunk</code>
union to the address of the adjacent chunk<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>, except for the last free
chunk, which will point to <code>NULL</code>.</li>
</ol>

<p>
This is how the pool looks after being returned from <code>pool_new</code>:
</p>


<div id="fig2" class="figure">
<p><img src="../img/pool-allocator2.svg" alt="pool-allocator2.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 2: </span>Layout of a <code>Pool</code> structure after initialization.</p>
</div>

<p>
And this is how the pool looks after the user has allocated two chunks. This
process will be explained below, but perhaps you are starting to realize the
advantages of this method:
</p>


<div id="fig3" class="figure">
<p><img src="../img/pool-allocator3.svg" alt="pool-allocator3.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 3: </span>Layout of a <code>Pool</code> structure after two allocations.</p>
</div>

<p>
Since this implementation doesn&rsquo;t support pool resizing, the only <i>O(n)</i> algorithm
occurs when creating the pool itself, since we need to iterate each chunk to
build the linked list described above. The chunk allocation process, on the
other hand, has <i>O(1)</i> complexity, since we always have a free chunk waiting for
us at <code>Pool.free_chunk</code>. Freeing a chunk is also done in linear time, since we
just have to prepend an element to this linked list.
</p>
</div>
</div>

<div id="outline-container-allocating-chunks" class="outline-3">
<h3 id="allocating-chunks"><span class="section-number-3">2.4.</span> Allocating chunks</h3>
<div class="outline-text-3" id="text-allocating-chunks">
<p>
Now that the pool has a pointer to a linked list of free chunks, when the user
requests an allocation for a chunk, we just have to:
</p>

<ol class="org-ol">
<li>Ensure that we haven&rsquo;t reached the end of the list, that is, ensure the
<code>Pool.free_chunk</code> pointer is not <code>NULL</code>.</li>
<li>The first element of this &ldquo;free chunks&rdquo; list will be returned. Before that,
remove it from the list by setting the start of the list
(i.e. <code>Pool.free_chunk</code>) to what used to be the second element
(i.e. <code>Pool.free_chunk.next</code>).</li>
</ol>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">void</span>* <span style="color: #4ae2ff;">pool_alloc</span>(<span style="color: #79a8ff;">Pool</span>* <span style="color: #6ae4b9;">pool</span>) {
    <span style="color: #ff6f9f;">if</span> (pool == <span style="color: #88ca9f;">NULL</span> || pool-&gt;free_chunk == <span style="color: #88ca9f;">NULL</span>)
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;

    <span style="color: #79a8ff;">Chunk</span>* <span style="color: #6ae4b9;">result</span>    = pool-&gt;free_chunk;
    pool-&gt;free_chunk = pool-&gt;free_chunk-&gt;next;
    <span style="color: #ff6f9f;">return</span> result;
}
</pre>
</div>

<p>
Now the user can safely overwrite the contents of the pointer returned by
<code>pool_alloc</code>, and it will be essentially setting the <code>arr</code> member of the <code>Chunk</code>
union. This is fine, since that chunk is no longer part of our &ldquo;free chunks&rdquo;
list.
</p>

<p>
Just to emphasize once again, we are not iterating anything, so this process is
<i>linear</i>. Allocating chunks of arbitrary size on linear time obviously has great
advantages, specially when we have to allocate and free many times per second
(e.g. many entities in each tick of a simulation).
</p>
</div>
</div>

<div id="outline-container-freeing-chunks" class="outline-3">
<h3 id="freeing-chunks"><span class="section-number-3">2.5.</span> Freeing chunks</h3>
<div class="outline-text-3" id="text-freeing-chunks">
<p>
Freeing chunks is pretty straight-forward, and if you understood the previous
sections, I recommend you try to write your own function.
</p>

<p>
The freeing process simply consists of adding (prepending) a chunk back into the
linked list of free chunks. As you can probably tell, this is also a linear
process.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">pool_free</span>(<span style="color: #79a8ff;">Pool</span>* <span style="color: #6ae4b9;">pool</span>, <span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">ptr</span>) {
    <span style="color: #ff6f9f;">if</span> (pool == <span style="color: #88ca9f;">NULL</span> || ptr == <span style="color: #88ca9f;">NULL</span>)
        <span style="color: #ff6f9f;">return</span>;

    <span style="color: #79a8ff;">Chunk</span>* <span style="color: #6ae4b9;">freed</span>     = ptr;
    freed-&gt;next      = pool-&gt;free_chunk;
    pool-&gt;free_chunk = freed;
}
</pre>
</div>

<p>
For example, following the <a href="#fig3">previous figure</a>, this would be the layout after the
user frees the first block of memory.
</p>


<div id="fig4" class="figure">
<p><img src="../img/pool-allocator4.svg" alt="pool-allocator4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 4: </span>Layout of a <code>Pool</code> structure after freeing a chunk.</p>
</div>

<p>
Notice how, unlike with arena allocators, we don&rsquo;t have to free in the same
order that we allocated.
</p>
</div>
</div>

<div id="outline-container-closing-the-pool" class="outline-3">
<h3 id="closing-the-pool"><span class="section-number-3">2.6.</span> Closing the pool</h3>
<div class="outline-text-3" id="text-closing-the-pool">
<p>
Finally, once the user is done with the pool itself, it should be able to free
it to the system. This is also pretty intuitive in this implementation, but it
will get a bit trickier <a href="#changes-to-pool-new-and-pool-close">below</a>.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">pool_close</span>(<span style="color: #79a8ff;">Pool</span>* <span style="color: #6ae4b9;">pool</span>) {
    <span style="color: #ff6f9f;">if</span> (pool == <span style="color: #88ca9f;">NULL</span>)
        <span style="color: #ff6f9f;">return</span>;

    free(pool-&gt;chunk_arr);
    free(pool);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-reallocation-problems" class="outline-2">
<h2 id="reallocation-problems"><span class="section-number-2">3.</span> Reallocation problems</h2>
<div class="outline-text-2" id="text-reallocation-problems">
<p>
When using a pool allocator, at some point you will probably want to be able to
resize an existing pool, for example when you run out of chunks. This might not
seem too hard, but there are a few caveats.
</p>

<p>
At first sight, we could <i>reallocate</i> a pool with a few simple steps:
</p>

<ol class="org-ol">
<li>Reallocate the old chunk array (i.e. <code>my_pool.chunk_arr</code>).</li>
<li>Link the new chunks together, just like we did when <a href="#creating-the-pool">creating the pool</a>.</li>
<li>Prepend the new chunks to the list of free chunks, just like we did when
<a href="#freeing-chunks">freeing a previously-allocated chunk</a>.</li>
</ol>

<p>
For example, following the <a href="#fig4">previous figure</a>, if we reallocated the pool to add
two more chunks, we would (at first sight) get the following layout.
</p>


<div id="fig5" class="figure">
<p><img src="../img/pool-allocator5.svg" alt="pool-allocator5.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 5: </span>Layout of a <code>Pool</code> structure after resizing it, with two new chunks.</p>
</div>

<p>
However, there is an important detail that is easy to miss. When we reallocate
the pool (i.e. the array of chunks), the <i>base address</i> of the array might change,
so the address of each chunk will also change. This is a problem because:
</p>

<ol class="org-ol">
<li>The old pointers used to build the linked list of free chunks still point to
the old array, so they become invalid. There are a few possible fixes for
this, like recalculating the offsets<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> from the old <i>base address</i>, storing offsets instead of
pointers, etc.</li>
<li>The pointers we returned when the user <a href="#allocating-chunks">allocated chunks</a> also point to the old
array, so they are also invalid. If the user tries to access or free these
pointers, a segmentation fault might occur.</li>
</ol>

<p>
This is how the layout will probably look like after the
reallocation. Incomplete connections crossed-out with a single line represent
invalid (but non-null) pointers to the old array, which is now invalid.
</p>


<div id="fig6" class="figure">
<p><img src="../img/pool-allocator6.svg" alt="pool-allocator6.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 6: </span>Resizing problems: old pointers may become invalid.</p>
</div>
</div>
</div>

<div id="outline-container-second-implementation-expanding-the-pool" class="outline-2">
<h2 id="second-implementation-expanding-the-pool"><span class="section-number-2">4.</span> Second implementation: Expanding the pool</h2>
<div class="outline-text-2" id="text-second-implementation-expanding-the-pool">
<p>
Instead of <i>modifying</i> the existing chunk array, we can allocate a <i>new array</i> with
the number of chunks we want to add and prepend them to the linked list of free
chunks an existing pool. Although this only let&rsquo;s the pool <i>grow</i> (and not
<i>shrink</i>), I think it&rsquo;s what most implementations will need. Some important
details about this approach will be explained below.
</p>

<p>
The following figure shows how two different <code>Chunk</code> arrays could be allocated
separately. The green area denotes the initial chunk array allocated inside
<code>pool_new</code>, while the blue area denotes a different chunk array allocated when
expanding the pool. The two arrays don&rsquo;t necessarily have to be adjacent in
memory, which is why there is no need for reallocations.
</p>


<div id="fig7" class="figure">
<p><img src="../img/pool-allocator7.svg" alt="pool-allocator7.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 7: </span>Different chunk arrays after expanding a pool.</p>
</div>

<p>
Notice how we have to keep track of the start of each array, since we will need
to free them separately. In the previous figure, we use two <code>chunk_arr0</code> and
<code>chunk_arr1</code> members to denote this, but since we would like to allow the user to
expand the pool an arbitrary number of times, we should be able to keep track of
an indefinite number of pointers (to the start of the chunk arrays) at runtime.
</p>
</div>

<div id="outline-container-keeping-track-of-the-array-starts" class="outline-3">
<h3 id="keeping-track-of-the-array-starts"><span class="section-number-3">4.1.</span> Keeping track of the array starts</h3>
<div class="outline-text-3" id="text-keeping-track-of-the-array-starts">
<p>
For keeping track of these pointers, we will create another linked list of
&ldquo;array starts&rdquo;. We declare a <code>LinkedPtr</code> structure which will contain the address
of the next element in the linked list (or <code>NULL</code>), along with the pointer to the
start of each array.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">typedef</span> <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">LinkedPtr</span> <span style="color: #79a8ff;">LinkedPtr</span>;
<span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">LinkedPtr</span> {
    <span style="color: #79a8ff;">Chunk</span>* <span style="color: #6ae4b9;">ptr</span>;
    <span style="color: #79a8ff;">LinkedPtr</span>* <span style="color: #6ae4b9;">next</span>;
};
</pre>
</div>

<p>
Now, instead of storing a single <code>Chunk*</code> in the <code>Pool</code> structure, we store a
pointer to the linked list of array starts.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">Pool</span> {
    <span style="color: #79a8ff;">Chunk</span>* <span style="color: #6ae4b9;">free_chunk</span>;
    <span style="color: #79a8ff;">LinkedPtr</span>* <span style="color: #6ae4b9;">array_starts</span>; <span style="color: #989898;">/* </span><span style="color: #989898;">Updated</span><span style="color: #989898;"> */</span>
};
</pre>
</div>

<p>
This takes a bit more space in memory, but it&rsquo;s worth it. Even if we don&rsquo;t
resize the pool, only the size 2 more pointers would be needed: one that points
to the <code>LinkedPtr</code> structure itself, and the (unused) <code>.next</code> member.
</p>
</div>
</div>

<div id="outline-container-changes-to-pool-new-and-pool-close" class="outline-3">
<h3 id="changes-to-pool-new-and-pool-close"><span class="section-number-3">4.2.</span> Changes to <code>pool_new</code> and <code>pool_close</code></h3>
<div class="outline-text-3" id="text-changes-to-pool-new-and-pool-close">
<p>
The <code>pool_new</code> and <code>pool_free</code> functions need to be modified according to our new
<code>LinkedPtr</code> structure.
</p>

<p>
When <a href="#creating-the-pool">creating the pool</a>, instead of storing the base address of the chunk array
in <code>pool-&gt;chunk_arr</code>, we will have to allocate a <code>LinkedPtr</code> structure and write it
there.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">Pool</span>* <span style="color: #4ae2ff;">pool_new</span>(<span style="color: #79a8ff;">size_t</span> <span style="color: #6ae4b9;">pool_sz</span>) {
    <span style="color: #79a8ff;">Pool</span>* <span style="color: #6ae4b9;">pool</span> = malloc(<span style="color: #ff6f9f;">sizeof</span>(Pool));
    <span style="color: #ff6f9f;">if</span> (pool == <span style="color: #88ca9f;">NULL</span>)
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;

    <span style="color: #79a8ff;">Chunk</span>* <span style="color: #6ae4b9;">arr</span> = pool-&gt;free_chunk = malloc(pool_sz * <span style="color: #ff6f9f;">sizeof</span>(Chunk));
    <span style="color: #ff6f9f;">if</span> (arr == <span style="color: #88ca9f;">NULL</span>) {
        free(pool);
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;
    }

    <span style="color: #ff6f9f;">for</span> (<span style="color: #79a8ff;">size_t</span> <span style="color: #6ae4b9;">i</span> = <span style="color: #88ca9f;">0</span>; i &lt; pool_sz - <span style="color: #88ca9f;">1</span>; i++)
        arr[i].next = &amp;arr[i + <span style="color: #88ca9f;">1</span>];
    arr[pool_sz - <span style="color: #88ca9f;">1</span>].next = <span style="color: #88ca9f;">NULL</span>;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Added</span><span style="color: #989898;"> */</span>
    pool-&gt;array_starts = malloc(<span style="color: #ff6f9f;">sizeof</span>(LinkedPtr));
    <span style="color: #ff6f9f;">if</span> (pool-&gt;array_starts == <span style="color: #88ca9f;">NULL</span>) {
        free(arr);
        free(pool);
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;
    }

    pool-&gt;array_starts-&gt;next = <span style="color: #88ca9f;">NULL</span>;
    pool-&gt;array_starts-&gt;ptr  = arr;

    <span style="color: #ff6f9f;">return</span> pool;
}
</pre>
</div>

<p>
When <a href="#closing-the-pool">closing the pool</a>, we will also need to traverse this <code>array_starts</code> linked
list, freeing each chunk array and each <code>LinkedPtr</code> structure in the list.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">pool_close</span>(<span style="color: #79a8ff;">Pool</span>* <span style="color: #6ae4b9;">pool</span>) {
    <span style="color: #ff6f9f;">if</span> (pool == <span style="color: #88ca9f;">NULL</span>)
        <span style="color: #ff6f9f;">return</span>;

    <span style="color: #79a8ff;">LinkedPtr</span>* <span style="color: #6ae4b9;">linkedptr</span> = pool-&gt;array_starts;
    <span style="color: #ff6f9f;">while</span> (linkedptr != <span style="color: #88ca9f;">NULL</span>) {
        <span style="color: #79a8ff;">LinkedPtr</span>* <span style="color: #6ae4b9;">next</span> = linkedptr-&gt;next;
        free(linkedptr-&gt;ptr);
        free(linkedptr);
        linkedptr = next;
    }

    free(pool);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-resizing-without-modifying-the-array" class="outline-3">
<h3 id="resizing-without-modifying-the-array"><span class="section-number-3">4.3.</span> Resizing without modifying the array</h3>
<div class="outline-text-3" id="text-resizing-without-modifying-the-array">
<p>
Now that we have a way of storing the start addresses of an indefinite number of
chunk arrays, we can implement the resizing method shown in the <a href="#fig7">previous
figure</a>. The resizing process is the following:
</p>

<ol class="org-ol">
<li>Allocate the array of extra chunks that we are trying to add to the pool.</li>
<li>Link the new chunks together, just like we did when <a href="#creating-the-pool">creating the pool</a>.</li>
<li>Prepend the array of extra chunks to the &ldquo;free chunks&rdquo; list, just like we did
when <a href="#freeing-chunks">freeing chunks</a>.</li>
<li>Allocate a new <code>LinkedPtr</code> structure, and store the start of the new chunk
array in it.</li>
<li>Prepend this new <code>LinkedPtr</code> structure to the linked list of &ldquo;array starts&rdquo;,
stored inside the <code>Pool</code> structure.</li>
</ol>

<p>
And this is the code corresponding to the previous steps.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">bool</span> <span style="color: #4ae2ff;">pool_resize</span>(<span style="color: #79a8ff;">Pool</span>* <span style="color: #6ae4b9;">pool</span>, <span style="color: #79a8ff;">size_t</span> <span style="color: #6ae4b9;">extra_chunk_num</span>) {
    <span style="color: #ff6f9f;">if</span> (pool == <span style="color: #88ca9f;">NULL</span> || extra_chunk_num == <span style="color: #88ca9f;">0</span>)
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">false</span>;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Step 1</span><span style="color: #989898;"> */</span>
    <span style="color: #79a8ff;">Chunk</span>* <span style="color: #6ae4b9;">extra_chunk_arr</span> = malloc(extra_chunk_num * <span style="color: #ff6f9f;">sizeof</span>(Chunk));
    <span style="color: #ff6f9f;">if</span> (extra_chunk_arr == <span style="color: #88ca9f;">NULL</span>)
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">false</span>;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Step 2</span><span style="color: #989898;"> */</span>
    <span style="color: #ff6f9f;">for</span> (<span style="color: #79a8ff;">size_t</span> <span style="color: #6ae4b9;">i</span> = <span style="color: #88ca9f;">0</span>; i &lt; extra_chunk_num - <span style="color: #88ca9f;">1</span>; i++)
        extra_chunk_arr[i].next = &amp;extra_chunk_arr[i + <span style="color: #88ca9f;">1</span>];

    <span style="color: #989898;">/* </span><span style="color: #989898;">Step 3</span><span style="color: #989898;"> */</span>
    extra_chunk_arr[extra_chunk_num - <span style="color: #88ca9f;">1</span>].next = pool-&gt;free_chunk;
    pool-&gt;free_chunk                          = extra_chunk_arr;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Step 4</span><span style="color: #989898;"> */</span>
    <span style="color: #79a8ff;">LinkedPtr</span>* <span style="color: #6ae4b9;">array_start</span> = malloc(<span style="color: #ff6f9f;">sizeof</span>(LinkedPtr));
    <span style="color: #ff6f9f;">if</span> (array_start == <span style="color: #88ca9f;">NULL</span>) {
        free(extra_chunk_arr);
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">false</span>;
    }

    <span style="color: #989898;">/* </span><span style="color: #989898;">Step 5</span><span style="color: #989898;"> */</span>
    array_start-&gt;ptr   = extra_chunk_arr;
    array_start-&gt;next  = pool-&gt;array_starts;
    pool-&gt;array_starts = array_start;

    <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">true</span>;
}
</pre>
</div>

<p>
Just like in the <a href="#fig7">previous figure</a>, the green and blue regions represent arrays
allocated independently, but their respective <code>LinkedPtr</code> structures are also
included in the diagram.
</p>


<div id="fig8" class="figure">
<p><img src="../img/pool-allocator8.svg" alt="pool-allocator8.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 8: </span>Layout of a pool after resizing, showing the linked list of array starts.</p>
</div>

<p>
Naturally, this second implementation is able to allocate and free chunks with
the same <i>O(1)</i> efficiency. The memory impact is <i>slightly</i> bigger, but it&rsquo;s
probably worth it if you ever want to resize a pool.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">We
could allocate the <code>Pool</code> and the chunk array with a single call, but I think
this would make it less readable. Furthermore, since the <code>Pool</code> structure is
small, we could even return it directly on the stack, instead allocating it
and returning a pointer.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">In this case, we store the
&ldquo;absolute address&rdquo; of the adjacent chunk, but we could use less space by
storing an offset relative to the start of the chunk array. This is not a big
deal, though, since we will probably want to use the pool allocator with
chunks bigger than a pointer in the first place.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">An example of this method, which I
wrote before I noticed the second problem, can be seen on commit <a href="https://github.com/8dcc/libpool/blob/bb0c8a2352b38066a8b25440ef9047ea19a34ece/src/libpool.c#L194-L240">bb0c8a2</a> of
my <a href="https://github.com/8dcc">libpool</a> repository. That code doesn&rsquo;t use <code>Chunk</code> unions, so the casts make
it less readable.</p></div></div>


</div>
</div></div>
</body>
</html>
