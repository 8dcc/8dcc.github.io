#+TITLE: Signature scanning
#+AUTHOR: 8dcc
#+OPTIONS: toc:nil
#+STARTUP: showeverything
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />

[[file:../index.org][Index]] | [[file:index.org][Up]]

-----

#+TOC: headlines 2

* What is signature scanning?

First, let's have a look at a sample program:

#+begin_src C
#include <stdio.h>

static int my_func(int x, int y) {
    if (y > x || y < 0 || y > 32)
        return 0;

    puts("Hello from my_func!");

    return (x >> y) * 3;
}

int main(void) {
    int x = 0x100;
    int y = 4;
    printf("%d\n", my_func(x, y));
    return 0;
}
#+end_src

#+RESULTS:
: 48

Imagine we are, for example, injecting a =.dll= or =.so= into a process, and we want
to find a function or a value at runtime. A valid approach would be to scan the
memory of the loaded binary, and search for the bytes corresponding to the
function or variable. Then, depending on what we are actually looking for, we
could read the information, call the function, or even overwrite the bytes
directly from memory (after changing the necessary permissions, of course).

In our case, we would want to look for the bytes of the binary corresponding to
=my_func=.

* Finding the function inside the binary

I will compile the previous source with =gcc 13.2.1=. We need to use =-O0= so the
function call doesn't get optimized. I also used =strip= to "simulate" a real
world scenario where we can't just look at the symbols.

#+begin_src
gcc -Wall -Wextra -O0 -o example.out example.c
strip example.out
#+end_src

Let's have a look at the generated binary using [[https://cutter.re/][cutter]], in my case version
2.3.1. First, we need to change some settings. Go to =Edit > Preferences= and make
sure the following settings are enabled in the disassembly tab:

- /Display the bytes of each instruction:/ Enabled
- /Number of bytes of each instruction:/ 8
- /Align bytes to the left:/ Enabled
- /Separate bytes with whitespace:/ Enabled

You can change the rest of the settings to match your taste. Note that you could
also be using [[https://rizin.re/][rizin]] for all the following steps, the backend and CLI version of
cutter. All the mentioned settings can be changed in rizin by using the name in
parentheses in the cutter menu.

Now that we configured cutter, we can see the assembly bytes of each
instruction. These are the bytes that we will be using for our signature, but
first, we need to find what we are looking for from cutter.

This is the disassembly of the main function:

[[file:../img/signature-scanning1.png]]

As you can see, in =main+0x8= we are loading =0x100= and =4= into the local
variables, and in =main+0x1c= we are loading them into the registers used for
function parameters according to the AMD64 System V ABI. In =main+0x20=, we are
calling =my_func=. Let's double-click it to have a look at the assembly:

[[file:../img/signature-scanning2.png]]

Yeah, that looks like our function.

* Getting the signature

The signature is going to be an arbitrary number of bytes from the target
function. However, some of the bytes will not be constant, so we need to have
that in mind.

For example, the last 4 bytes of =fcn.00001149+0x29= are not guaranteed to be
=8b 0e 00 00=. In our signature, we will have to use something like =? ? ? ?= to
identify it (some signature scanning functions use an extra mask parameter to
indicate which bytes are unknown).

Some plugins like [[https://hex-rays.com/ida-pro/][IDA]]'s [[https://github.com/ajkhoury/SigMaker-x64][sigmaker]] are able to generate the signatures from a
selection. I decided to use cutter just to show that you only need a
disassembler.

[[file:../img/signature-scanning3.png]]

For our signature, we should use enough bytes to make sure they are unique for
the function/variable we are looking for. Here is a signature of the whole
function, but in practice, we shouldn't need more than 10 instructions:

#+begin_example
55 48 89 E5 48 83 EC 10 89 7D FC 89 75 F8 8B 45 F8 3B 45 FC 7F 0C 83 7D F8 00 78
06 83 7D F8 20 7E 07 B8 ? ? ? ? EB 1F 48 8D 05 ? ? ? ? 48 89 C7 E8 ? ? ? ? 8B 45
F8 8B 55 FC 89 C1 D3 FA 89 D0 01 C0 01 D0 C9 C3
#+end_example
