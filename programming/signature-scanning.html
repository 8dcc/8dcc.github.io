<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Signature scanning in C</title>
<meta property="og:title" content="Signature scanning in C" />
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png" />
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Signature scanning in C</h1>
<p>
<a href="../index.html">Index</a> | <a href="index.html">Up</a>
</p>

<hr />

<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#what-is-signature-scanning">1. What is signature scanning?</a></li>
<li><a href="#finding-the-function-inside-the-binary">2. Finding the function inside the binary</a></li>
<li><a href="#getting-the-signature">3. Getting the signature</a></li>
<li><a href="#signature-scanning-function">4. Signature scanning function</a>
<ul>
<li><a href="#parsing-the-ida-pattern-string">4.1. Parsing the IDA pattern string</a></li>
<li><a href="#the-do-scan-function">4.2. The <code>do_scan</code> function</a></li>
<li><a href="#getting-the-bounds-of-a-loaded-module">4.3. Getting the bounds of a loaded module</a>
<ul>
<li><a href="#the-unreliable-method">4.3.1. The unreliable method</a></li>
<li><a href="#parsing-proc-self-maps">4.3.2. Parsing <code>/proc/self/maps</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#using-our-sigscan-function">5. Using our <code>sigscan</code> function</a></li>
<li><a href="#injecting-script-and-final-makefile">6. Injecting script and final Makefile</a></li>
<li><a href="#signature-scanning-library">7. Signature scanning library</a></li>
</ul>
</div>
</div>

<div id="outline-container-what-is-signature-scanning" class="outline-2">
<h2 id="what-is-signature-scanning"><span class="section-number-2">1.</span> What is signature scanning?</h2>
<div class="outline-text-2" id="text-what-is-signature-scanning">
<p>
First, let&rsquo;s have a look at a sample program:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdio.h&gt;</span>

<span style="color: #ff6f9f;">static</span> <span style="color: #79a8ff;">int</span> <span style="color: #4ae2ff;">my_func</span>(<span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">x</span>, <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">y</span>) {
    <span style="color: #ff6f9f;">if</span> (y &gt; x || y &lt; <span style="color: #88ca9f;">0</span> || y &gt; <span style="color: #88ca9f;">32</span>)
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">0</span>;

    puts(<span style="color: #00d3d0;">"Hello from my_func!"</span>);

    <span style="color: #ff6f9f;">return</span> (x &gt;&gt; y) * <span style="color: #88ca9f;">3</span>;
}

<span style="color: #79a8ff;">int</span> <span style="color: #4ae2ff;">main</span>(<span style="color: #79a8ff;">void</span>) {
    <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">x</span> = <span style="color: #88ca9f;">0x100</span>;
    <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">y</span> = <span style="color: #88ca9f;">4</span>;
    printf(<span style="color: #00d3d0;">"</span><span style="color: #ff6f9f;">%d\n</span><span style="color: #00d3d0;">"</span>, my_func(x, y));

    <span style="color: #989898;">/* </span><span style="color: #989898;">Infinite loop for injecting later</span><span style="color: #989898;"> */</span>
    <span style="color: #ff6f9f;">for</span> (;;)
        <span style="color: #cabf00;">;</span>

    <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">0</span>;
}
</pre>
</div>

<p>
Imagine we are, for example, injecting a <code>.dll</code> or <code>.so</code> into a process, and we want
to find a function or a value at runtime. A valid approach would be to scan the
memory of the loaded binary, and search for the bytes corresponding to the
function or variable. Then, depending on what we are actually looking for, we
could read the information, call the function, or even overwrite the bytes
directly from memory (after changing the necessary permissions, of course).
</p>

<p>
In our case, we would want to look for the bytes of the binary corresponding to
<code>my_func</code>.
</p>
</div>
</div>

<div id="outline-container-finding-the-function-inside-the-binary" class="outline-2">
<h2 id="finding-the-function-inside-the-binary"><span class="section-number-2">2.</span> Finding the function inside the binary</h2>
<div class="outline-text-2" id="text-finding-the-function-inside-the-binary">
<p>
I will compile the previous source with <code>gcc 13.2.1</code>. We need to use <code>-O0</code> so the
function call doesn&rsquo;t get optimized. I also used <code>strip</code> to &ldquo;simulate&rdquo; a real
world scenario where we can&rsquo;t just look at the symbols.
</p>

<pre class="example">
gcc -Wall -Wextra -O0 -o example.out example.c
strip example.out
</pre>

<p>
Let&rsquo;s have a look at the generated binary using <a href="https://cutter.re/">cutter</a>, in my case version
2.3.1. First, we need to change some settings. Go to <code>Edit &gt; Preferences</code> and make
sure the following settings are enabled in the disassembly tab:
</p>

<ul class="org-ul">
<li>Display the bytes of each instruction: <i>Enabled</i></li>
<li>Number of bytes of each instruction: <i>8</i></li>
<li>Align bytes to the left: <i>Enabled</i></li>
<li>Separate bytes with whitespace: <i>Enabled</i></li>
</ul>

<p>
You can change the rest of the settings to match your taste. Note that you could
also be using <a href="https://rizin.re/">rizin</a> for all the following steps, the backend and CLI version of
cutter. All the mentioned settings can be changed in rizin by using the name in
parentheses in the cutter menu.
</p>

<p>
Now that we configured cutter, we can see the assembly bytes of each
instruction. These are the bytes that we will be using for our signature, but
first, we need to find what we are looking for from cutter.
</p>

<p>
This is the disassembly of the main function:
</p>


<div id="org037a2a5" class="figure">
<p><img src="../img/signature-scanning1.png" alt="signature-scanning1.png" />
</p>
</div>

<p>
As you can see, in <code>main+0x8</code> we are loading <code>0x100</code> and <code>4</code> into the local
variables, and in <code>main+0x1c</code> we are loading them into the registers used for
function parameters according to the AMD64 System V ABI. In <code>main+0x20</code>, we are
calling <code>my_func</code>. Let&rsquo;s double-click it to have a look at the assembly:
</p>


<div id="org9520ddd" class="figure">
<p><img src="../img/signature-scanning2.png" alt="signature-scanning2.png" />
</p>
</div>

<p>
Yeah, that looks like our function.
</p>
</div>
</div>

<div id="outline-container-getting-the-signature" class="outline-2">
<h2 id="getting-the-signature"><span class="section-number-2">3.</span> Getting the signature</h2>
<div class="outline-text-2" id="text-getting-the-signature">
<p>
The signature is going to be an arbitrary number of bytes from the target
function. However, some of the bytes will not be constant, so we need to have
that in mind.
</p>

<p>
For example, the last 4 bytes of <code>fcn.00001149+0x29</code> are not guaranteed to be
<code>8b 0e 00 00</code>. In our signature, we will have to use something like <code>? ? ? ?</code> to
identify it.
</p>

<p>
Some plugins like <a href="https://hex-rays.com/ida-pro/">IDA</a>&rsquo;s <a href="https://github.com/ajkhoury/SigMaker-x64">sigmaker</a> are able to generate the signatures from a
selection. I decided to use cutter just to show that you only need a
disassembler.
</p>


<div id="orgbc7b3e7" class="figure">
<p><img src="../img/signature-scanning3.png" alt="signature-scanning3.png" />
</p>
</div>

<p>
For our signature, we should use enough bytes to make sure they are unique for
the function/variable we are looking for. Here is a signature of the whole
function, but in practice, we shouldn&rsquo;t need more than 10 instructions.
</p>

<pre class="example" id="org74c1fd0">
55 48 89 E5 48 83 EC 10 89 7D FC 89 75 F8 8B 45 F8 3B 45 FC 7F 0C 83 7D F8 00 78
06 83 7D F8 20 7E 07 B8 ? ? ? ? EB 1F 48 8D 05 ? ? ? ? 48 89 C7 E8 ? ? ? ? 8B 45
F8 8B 55 FC 89 C1 D3 FA 89 D0 01 C0 01 D0 C9 C3
</pre>

<p>
These kind of signature is usually called IDA format, but there are also code
signatures which contain the bytes directly in an array. To differentiate
between <code>'?'</code> and <code>0x3F</code>, these normally use an extra mask parameter to indicate
which bytes are unknown. IDA patterns are usually cleaner, but make the
signature scanning function a bit larger.
</p>
</div>
</div>

<div id="outline-container-signature-scanning-function" class="outline-2">
<h2 id="signature-scanning-function"><span class="section-number-2">4.</span> Signature scanning function</h2>
<div class="outline-text-2" id="text-signature-scanning-function">
<p>
This is a simple function that scans a memory area from <code>start</code> to <code>end</code> and
searches for a <code>pattern</code> in IDA format.
</p>
</div>

<div id="outline-container-parsing-the-ida-pattern-string" class="outline-3">
<h3 id="parsing-the-ida-pattern-string"><span class="section-number-3">4.1.</span> Parsing the IDA pattern string</h3>
<div class="outline-text-3" id="text-parsing-the-ida-pattern-string">
<p>
First, we would need a function to convert those <code>"E5 "</code> strings into <code>0xE5</code>. Here
it is:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdint.h&gt;</span>

<span style="color: #989898;">/* </span><span style="color: #989898;">Used for getting the bytes from IDA patterns.</span>
<span style="color: #989898;"> * Converts: "E0" -&gt; 224</span><span style="color: #989898;"> */</span>
<span style="color: #79a8ff;">uint8_t</span> <span style="color: #4ae2ff;">hex_to_byte</span>(<span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">hex</span>) {
    <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">ret</span> = <span style="color: #88ca9f;">0</span>;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Skip leading spaces, if any</span><span style="color: #989898;"> */</span>
    <span style="color: #ff6f9f;">while</span> (*hex == <span style="color: #00d3d0;">' '</span>)
        hex++;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Store a byte (two digits of string)</span><span style="color: #989898;"> */</span>
    <span style="color: #ff6f9f;">for</span> (<span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">i</span> = <span style="color: #88ca9f;">0</span>; i &lt; <span style="color: #88ca9f;">2</span> &amp;&amp; hex[i] != <span style="color: #00d3d0;">'</span><span style="color: #ff6f9f;">\0</span><span style="color: #00d3d0;">'</span>; i++) {
        <span style="color: #79a8ff;">char</span> <span style="color: #6ae4b9;">c</span> = hex[i];

        <span style="color: #989898;">/* </span><span style="color: #989898;">For example "E ", although the format should always be "0E"</span><span style="color: #989898;"> */</span>
        <span style="color: #ff6f9f;">if</span> (c == <span style="color: #00d3d0;">' '</span>)
            <span style="color: #ff6f9f;">break</span>;

        <span style="color: #79a8ff;">uint8_t</span> <span style="color: #6ae4b9;">n</span> = <span style="color: #88ca9f;">0</span>;
        <span style="color: #ff6f9f;">if</span> (c &gt;= <span style="color: #00d3d0;">'0'</span> &amp;&amp; c &lt;= <span style="color: #00d3d0;">'9'</span>)
            n = c - <span style="color: #00d3d0;">'0'</span>;
        <span style="color: #ff6f9f;">else</span> <span style="color: #ff6f9f;">if</span> (c &gt;= <span style="color: #00d3d0;">'a'</span> &amp;&amp; c &lt;= <span style="color: #00d3d0;">'f'</span>)
            n = <span style="color: #88ca9f;">10</span> + c - <span style="color: #00d3d0;">'a'</span>;
        <span style="color: #ff6f9f;">else</span> <span style="color: #ff6f9f;">if</span> (c &gt;= <span style="color: #00d3d0;">'A'</span> &amp;&amp; c &lt;= <span style="color: #00d3d0;">'F'</span>)
            n = <span style="color: #88ca9f;">10</span> + c - <span style="color: #00d3d0;">'A'</span>;

        <span style="color: #989898;">/* </span><span style="color: #989898;">Shift size of 0xF and add the next half of byte</span><span style="color: #989898;"> */</span>
        ret &lt;&lt;= <span style="color: #88ca9f;">4</span>;
        ret |= n &amp; <span style="color: #88ca9f;">0xF</span>;
    }

    <span style="color: #ff6f9f;">return</span> ret &amp; <span style="color: #88ca9f;">0xFF</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-the-do-scan-function" class="outline-3">
<h3 id="the-do-scan-function"><span class="section-number-3">4.2.</span> The <code>do_scan</code> function</h3>
<div class="outline-text-3" id="text-the-do-scan-function">
<p>
And with that, we can make our <code>do_scan</code> function:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdint.h&gt;</span>

<span style="color: #989898;">/* </span><span style="color: #989898;">Search for `pattern' from `start' to `end'.</span><span style="color: #989898;"> */</span>
<span style="color: #79a8ff;">void</span>* <span style="color: #4ae2ff;">do_scan</span>(<span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">start</span>, <span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">end</span>, <span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">pattern</span>) {
    <span style="color: #ff6f9f;">if</span> (<span style="color: #ff6740; font-weight: bold;">!</span>start || <span style="color: #ff6740; font-weight: bold;">!</span>end)
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Skip preceding spaces from pattern, if any</span><span style="color: #989898;"> */</span>
    <span style="color: #ff6f9f;">while</span> (*pattern == <span style="color: #00d3d0;">' '</span>)
        pattern++;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Current position in memory and current position in pattern</span><span style="color: #989898;"> */</span>
    <span style="color: #79a8ff;">uint8_t</span>* <span style="color: #6ae4b9;">mem_ptr</span>    = start;
    <span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">pat_ptr</span> = pattern;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Iterate until we reach the end of the memory or the end of the pattern</span><span style="color: #989898;"> */</span>
    <span style="color: #ff6f9f;">while</span> ((<span style="color: #79a8ff;">void</span>*)mem_ptr &lt; end &amp;&amp; *pat_ptr != <span style="color: #00d3d0;">'</span><span style="color: #ff6f9f;">\0</span><span style="color: #00d3d0;">'</span>) {
        <span style="color: #989898;">/* </span><span style="color: #989898;">Wildcard, always match</span><span style="color: #989898;"> */</span>
        <span style="color: #ff6f9f;">if</span> (*pat_ptr == <span style="color: #00d3d0;">'?'</span>) {
            mem_ptr++;

            <span style="color: #989898;">/* </span><span style="color: #989898;">"A1 ?? ?? B2" -&gt; "A1 ? ? B2"</span><span style="color: #989898;"> */</span>
            <span style="color: #ff6f9f;">while</span> (*pat_ptr == <span style="color: #00d3d0;">'?'</span>)
                pat_ptr++;

            <span style="color: #989898;">/* </span><span style="color: #989898;">Remove trailing spaces after '?'</span>
<span style="color: #989898;">             * </span><span style="color: #44bc44; font-weight: bold;">NOTE:</span><span style="color: #989898;"> I reused this code, but you could use `goto`</span><span style="color: #989898;"> */</span>
            <span style="color: #ff6f9f;">while</span> (*pat_ptr == <span style="color: #00d3d0;">' '</span>)
                pat_ptr++;

            <span style="color: #ff6f9f;">continue</span>;
        }

        <span style="color: #989898;">/* </span><span style="color: #989898;">Convert "E0" into 224.</span>
<span style="color: #989898;">         * </span><span style="color: #cabf00; font-weight: bold;">TODO:</span><span style="color: #989898;"> Would be better to only do this once at the start of the</span>
<span style="color: #989898;">         * function with some kind of ida2bytes function (We would need a mask</span>
<span style="color: #989898;">         * for the '?' vs. 0x3F).</span><span style="color: #989898;"> */</span>
        <span style="color: #79a8ff;">uint8_t</span> <span style="color: #6ae4b9;">cur_byte</span> = hex_to_byte(pat_ptr);

        <span style="color: #ff6f9f;">if</span> (*mem_ptr == cur_byte) {
            <span style="color: #989898;">/* </span><span style="color: #989898;">Found exact byte match in sequence, go to next byte in memory</span><span style="color: #989898;"> */</span>
            mem_ptr++;

            <span style="color: #989898;">/* </span><span style="color: #989898;">Go to next byte separator in pattern (space)</span><span style="color: #989898;"> */</span>
            <span style="color: #ff6f9f;">while</span> (*pat_ptr != <span style="color: #00d3d0;">' '</span> &amp;&amp; *pat_ptr != <span style="color: #00d3d0;">'</span><span style="color: #ff6f9f;">\0</span><span style="color: #00d3d0;">'</span>)
                pat_ptr++;
        } <span style="color: #ff6f9f;">else</span> {
            <span style="color: #989898;">/* </span><span style="color: #989898;">Byte didn't match, check pattern from the begining on the next</span>
<span style="color: #989898;">             * position in memory</span><span style="color: #989898;"> */</span>
            start++;
            mem_ptr = start;
            pat_ptr = pattern;
        }

        <span style="color: #989898;">/* </span><span style="color: #989898;">Skip trailing spaces</span><span style="color: #989898;"> */</span>
        <span style="color: #ff6f9f;">while</span> (*pat_ptr == <span style="color: #00d3d0;">' '</span>)
            pat_ptr++;
    }

    <span style="color: #989898;">/* </span><span style="color: #989898;">If we reached end of pattern, return the match. Otherwise, NULL</span><span style="color: #989898;"> */</span>
    <span style="color: #ff6f9f;">return</span> (*pat_ptr == <span style="color: #00d3d0;">'</span><span style="color: #ff6f9f;">\0</span><span style="color: #00d3d0;">'</span>) ? start : <span style="color: #88ca9f;">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-getting-the-bounds-of-a-loaded-module" class="outline-3">
<h3 id="getting-the-bounds-of-a-loaded-module"><span class="section-number-3">4.3.</span> Getting the bounds of a loaded module</h3>
<div class="outline-text-3" id="text-getting-the-bounds-of-a-loaded-module">
<p>
To get the <code>start</code> and <code>end</code> addresses, we need to find where the binary was loaded
in memory. I am going to show 2 methods of getting this information.
</p>
</div>

<div id="outline-container-the-unreliable-method" class="outline-4">
<h4 id="the-unreliable-method"><span class="section-number-4">4.3.1.</span> The unreliable method</h4>
<div class="outline-text-4" id="text-the-unreliable-method">
<p>
On linux, we could use <code>dlopen()</code> to get the start and end addresses of a loaded
module if we were, for example, injecting our own shared object.
</p>

<p>
We have to make our own version of <a href="https://man.cx/dlopen"><code>link_map</code></a> to include <code>link-&gt;phdr[0].p_memsz</code> (to
get the size of the loaded module).
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdint.h&gt;</span>
<span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;link.h&gt;</span>
<span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;dlfcn.h&gt;</span>
<span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdio.h&gt;</span>

<span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">our_link_map</span> {
    <span style="color: #989898;">/* </span><span style="color: #989898;">Base from link.h</span><span style="color: #989898;"> */</span>
    <span style="color: #4ae2ff;">ElfW</span>(Addr) l_addr;
    <span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">l_name</span>;
    <span style="color: #4ae2ff;">ElfW</span>(Dyn) * l_ld;
    <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">our_link_map</span>* <span style="color: #6ae4b9;">l_next</span>;
    <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">our_link_map</span>* <span style="color: #6ae4b9;">l_prev</span>;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Added</span><span style="color: #989898;"> */</span>
    <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">our_link_map</span>* <span style="color: #6ae4b9;">real</span>;
    <span style="color: #79a8ff;">long</span> <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">ns</span>;
    <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">libname_list</span>* <span style="color: #6ae4b9;">moduleName</span>;
    <span style="color: #4ae2ff;">ElfW</span>(Dyn) *
      info[DT_NUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];
    <span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">ElfW</span>(<span style="color: #6ae4b9;">Phdr</span>) * phdr;
};

<span style="color: #79a8ff;">void</span>* <span style="color: #4ae2ff;">sigscan</span>(<span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">module</span>, <span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">pattern</span>) {
    <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">our_link_map</span>* <span style="color: #6ae4b9;">link</span> = dlopen(module, RTLD_NOLOAD | RTLD_NOW);
    <span style="color: #ff6f9f;">if</span> (<span style="color: #ff6740; font-weight: bold;">!</span>link) {
        fprintf(<span style="color: #88ca9f;">stderr</span>, <span style="color: #00d3d0;">"Can't open module </span><span style="color: #ff6f9f;">\"%s\"</span><span style="color: #00d3d0;">"</span>, module);
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;
    }

    <span style="color: #79a8ff;">uint8_t</span>* <span style="color: #6ae4b9;">start</span> = (<span style="color: #79a8ff;">uint8_t</span>*)link-&gt;l_addr;
    <span style="color: #79a8ff;">uint8_t</span>* <span style="color: #6ae4b9;">end</span>   = start + link-&gt;phdr[<span style="color: #88ca9f;">0</span>].p_memsz;

    dlclose(link);

    <span style="color: #ff6f9f;">return</span> do_scan(start, end, pattern);
}
</pre>
</div>

<p>
As far as I know, the windows equivalent of <code>dlopen</code> would be <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><code>LoadLibraryA</code></a> and
<a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress"><code>GetProcAddress</code></a>. If you have more information on how this is done on windows,
feel free to <a href="https://github.com/8dcc/8dcc.github.io/pulls">contribute</a>.
</p>

<p>
In theory, if we wanted to get the bounds of the main binary, we could pass <code>NULL</code>
as the first parameter to <code>sigscan</code>, so it gets passed to <code>dlopen</code>.
</p>

<blockquote>
<p>
<b>dlopen(3)</b>
</p>

<p>
If filename is NULL, then the returned handle is for the main program. If
filename contains a slash (&ldquo;/&rdquo;), then it is interpreted as a (relative or
absolute) pathname.
</p>
</blockquote>

<p>
I say <i>in theory</i> because in my experience, this is not the case. Usually
<code>link-&gt;phdr</code> is <code>NULL</code>, so the program crashes. That&rsquo;s why I am going to show a more
reliable way.
</p>
</div>
</div>

<div id="outline-container-parsing-proc-self-maps" class="outline-4">
<h4 id="parsing-proc-self-maps"><span class="section-number-4">4.3.2.</span> Parsing <code>/proc/self/maps</code></h4>
<div class="outline-text-4" id="text-parsing-proc-self-maps">
<p>
The <code>/proc/&lt;pid&gt;/</code> folder contains many useful files, one of them being <code>maps</code>. The
<code>maps</code> file shows information about the currently mapped memory regions and their
access permissions in the following format (without the column names):
</p>

<pre class="example" id="org298aa0a">
address           perms offset  dev   inode       pathname
----------------------------------------------------------------------
00400000-00452000 r-xp 00000000 08:02 173521      /usr/bin/dbus-daemon
00651000-00652000 r--p 00051000 08:02 173521      /usr/bin/dbus-daemon
00652000-00655000 rw-p 00052000 08:02 173521      /usr/bin/dbus-daemon
00e03000-00e24000 rw-p 00000000 00:00 0           [heap]
00e24000-011f7000 rw-p 00000000 00:00 0           [heap]
0ff12000-0ff3e000 rw-p 00000000 00:00 0
...
35b1800000-35b1820000 r-xp 00000000 08:02 135522  /usr/lib64/ld-2.15.so
</pre>

<p>
Note how the pathname <b>can</b> be empty. For more information, see <code>proc_pid_maps(5)</code>.
</p>

<p>
We can access the <code>maps</code> file of our process using the <code>/proc/self/</code> folder, which
resolves to the PID of the current process. See also <code>proc(5)</code>.
</p>

<p>
Of course, now comes the tedious part, parsing it. Fortunately for you, I made a
function that returns a linked list of all these regions. It&rsquo;s a pretty long
function but since it&rsquo;s well commented, I won&rsquo;t dive into too much detail.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdbool.h&gt;</span>
<span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdio.h&gt;</span>  <span style="color: #989898;">/* </span><span style="color: #989898;">fopen(), FILE*</span><span style="color: #989898;"> */</span>
<span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdlib.h&gt;</span> <span style="color: #989898;">/* </span><span style="color: #989898;">strtoull()</span><span style="color: #989898;"> */</span>

<span style="color: #ff6f9f;">typedef</span> <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">ModuleBounds</span> {
    <span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">start</span>;
    <span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">end</span>;
    <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">ModuleBounds</span>* <span style="color: #6ae4b9;">next</span>;
} <span style="color: #79a8ff;">ModuleBounds</span>;

<span style="color: #79a8ff;">ModuleBounds</span>* <span style="color: #4ae2ff;">get_module_bounds</span>(<span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">module_name</span>) {
    <span style="color: #79a8ff;">FILE</span>* <span style="color: #6ae4b9;">fd</span> = fopen(<span style="color: #00d3d0;">"/proc/self/maps"</span>, <span style="color: #00d3d0;">"r"</span>);
    <span style="color: #ff6f9f;">if</span> (<span style="color: #ff6740; font-weight: bold;">!</span>fd)
        <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;

    <span style="color: #989898;">/* </span><span style="color: #989898;">For the first module. Start `ret' as NULL in case no module is valid.</span><span style="color: #989898;"> */</span>
    <span style="color: #79a8ff;">ModuleBounds</span>* <span style="color: #6ae4b9;">ret</span> = <span style="color: #88ca9f;">NULL</span>;
    <span style="color: #79a8ff;">ModuleBounds</span>* <span style="color: #6ae4b9;">cur</span> = ret;

    <span style="color: #989898;">/* </span><span style="color: #989898;">Buffers used in the loop by fgets() and sscanf()</span><span style="color: #989898;"> */</span>
    <span style="color: #ff6f9f;">static</span> <span style="color: #79a8ff;">char</span> <span style="color: #6ae4b9;">line_buf</span>[<span style="color: #88ca9f;">300</span>];
    <span style="color: #ff6f9f;">static</span> <span style="color: #79a8ff;">char</span> <span style="color: #6ae4b9;">rwxp</span>[<span style="color: #88ca9f;">5</span>];
    <span style="color: #ff6f9f;">static</span> <span style="color: #79a8ff;">char</span> <span style="color: #6ae4b9;">pathname</span>[<span style="color: #88ca9f;">200</span>];

    <span style="color: #ff6f9f;">while</span> (fgets(line_buf, <span style="color: #ff6f9f;">sizeof</span>(line_buf), fd)) {
        pathname[<span style="color: #88ca9f;">0</span>] = <span style="color: #00d3d0;">'</span><span style="color: #ff6f9f;">\0</span><span style="color: #00d3d0;">'</span>;

        <span style="color: #989898;">/* </span><span style="color: #989898;">Scan the current line using sscanf(). We need to change address sizes</span>
<span style="color: #989898;">         * depending on the arch.</span><span style="color: #989898;"> */</span>
        <span style="color: #79a8ff;">long</span> <span style="color: #79a8ff;">unsigned</span> <span style="color: #6ae4b9;">start_num</span> = <span style="color: #88ca9f;">0</span>, <span style="color: #6ae4b9;">end_num</span> = <span style="color: #88ca9f;">0</span>, <span style="color: #6ae4b9;">offset</span> = <span style="color: #88ca9f;">0</span>;
        <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">fmt_match_num</span> =
          sscanf(line_buf, <span style="color: #00d3d0;">"</span><span style="color: #ff6f9f;">%lx</span><span style="color: #00d3d0;">-</span><span style="color: #ff6f9f;">%lx</span><span style="color: #00d3d0;"> </span><span style="color: #ff6f9f;">%4s</span><span style="color: #00d3d0;"> </span><span style="color: #ff6f9f;">%lx</span><span style="color: #00d3d0;"> </span><span style="color: #ff6f9f;">%*x</span><span style="color: #00d3d0;">:</span><span style="color: #ff6f9f;">%*x</span><span style="color: #00d3d0;"> </span><span style="color: #ff6f9f;">%*d</span><span style="color: #00d3d0;"> %200[^</span><span style="color: #ff6f9f;">\n</span><span style="color: #00d3d0;">]</span><span style="color: #ff6f9f;">\n</span><span style="color: #00d3d0;">"</span>,
                 &amp;start_num, &amp;end_num, rwxp, &amp;offset, pathname);

        <span style="color: #ff6f9f;">if</span> (fmt_match_num &lt; <span style="color: #88ca9f;">4</span>)
            <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">NULL</span>;

        <span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">start_addr</span> = (<span style="color: #79a8ff;">void</span>*)start_num;
        <span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">end_addr</span>   = (<span style="color: #79a8ff;">void</span>*)end_num;

        <span style="color: #989898;">/* </span><span style="color: #989898;">Parse "rwxp". For now we only care about read permissions.</span><span style="color: #989898;"> */</span>
        <span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">bool</span> <span style="color: #6ae4b9;">is_readable</span> = rwxp[<span style="color: #88ca9f;">0</span>] == <span style="color: #00d3d0;">'r'</span>;

        <span style="color: #989898;">/* </span><span style="color: #989898;">First, we make sure we got a name, and that it doesn't start with</span>
<span style="color: #989898;">         * '\0' or '['. Then, either we don't want to filter by module name</span>
<span style="color: #989898;">         * (module name is NULL) or we checked the module name and it matches.</span><span style="color: #989898;"> */</span>
        <span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">bool</span> <span style="color: #6ae4b9;">name_matches</span> =
          fmt_match_num == <span style="color: #88ca9f;">5</span> &amp;&amp; pathname[<span style="color: #88ca9f;">0</span>] != <span style="color: #00d3d0;">'\0'</span> &amp;&amp; pathname[<span style="color: #88ca9f;">0</span>] != <span style="color: #00d3d0;">'['</span> &amp;&amp;
          (module_name == <span style="color: #88ca9f;">NULL</span> || <span style="color: #ff6740; font-weight: bold;">!</span>strcmp(module_name, pathname));

        <span style="color: #989898;">/* </span><span style="color: #989898;">We can read it, and it's the module we are looking for.</span><span style="color: #989898;"> */</span>
        <span style="color: #ff6f9f;">if</span> (is_readable &amp;&amp; name_matches) {
            <span style="color: #ff6f9f;">if</span> (cur == <span style="color: #88ca9f;">NULL</span>) {
                <span style="color: #989898;">/* </span><span style="color: #989898;">Allocate the first bounds struct</span><span style="color: #989898;"> */</span>
                cur = (<span style="color: #79a8ff;">ModuleBounds</span>*)malloc(<span style="color: #ff6f9f;">sizeof</span>(ModuleBounds));

                <span style="color: #989898;">/* </span><span style="color: #989898;">This one will be returned</span><span style="color: #989898;"> */</span>
                ret = cur;

                <span style="color: #989898;">/* </span><span style="color: #989898;">Save the addresses from this line of maps</span><span style="color: #989898;"> */</span>
                cur-&gt;start = start_addr;
                cur-&gt;end   = end_addr;
            } <span style="color: #ff6f9f;">else</span> <span style="color: #ff6f9f;">if</span> (cur-&gt;end == start_addr &amp;&amp; cur-&gt;end &lt; end_addr) {
                <span style="color: #989898;">/* </span><span style="color: #989898;">If the end address of the last struct is the start of this</span>
<span style="color: #989898;">                 * one, just merge them.</span><span style="color: #989898;"> */</span>
                cur-&gt;end = end_addr;
            } <span style="color: #ff6f9f;">else</span> {
                <span style="color: #989898;">/* </span><span style="color: #989898;">There was a gap between the end of the last block and the</span>
<span style="color: #989898;">                 * start of this one, allocate new struct.</span><span style="color: #989898;"> */</span>
                cur-&gt;next = (<span style="color: #79a8ff;">ModuleBounds</span>*)malloc(<span style="color: #ff6f9f;">sizeof</span>(ModuleBounds));

                <span style="color: #989898;">/* </span><span style="color: #989898;">Set as current</span><span style="color: #989898;"> */</span>
                cur = cur-&gt;next;

                <span style="color: #989898;">/* </span><span style="color: #989898;">Save the addresses from this line of maps</span><span style="color: #989898;"> */</span>
                cur-&gt;start = start_addr;
                cur-&gt;end   = end_addr;
            }

            <span style="color: #989898;">/* </span><span style="color: #989898;">Indicate the end of the linked list</span><span style="color: #989898;"> */</span>
            cur-&gt;next = <span style="color: #88ca9f;">NULL</span>;
        }
    }

    fclose(fd);
    <span style="color: #ff6f9f;">return</span> ret;
}
</pre>
</div>

<p>
This function returns a linked list of <code>ModuleList</code> structures, which contain the
start and end addresses of the readable modules that match the provided
name. You can also pass <code>NULL</code> to return all readable sections (except the ones
whose name start with <code>[</code>, like <code>[heap]</code>, <code>[stack]</code>, etc.).
</p>

<p>
Of course, we would need to free the <code>ModuleBounds</code> structures allocated by
<code>get_module_bounds</code> after we are done with them.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #989898;">/* </span><span style="color: #989898;">Free a linked list of ModuleBounds structures</span><span style="color: #989898;"> */</span>
<span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">free_module_bounds</span>(<span style="color: #79a8ff;">ModuleBounds</span>* <span style="color: #6ae4b9;">bounds</span>) {
    <span style="color: #79a8ff;">ModuleBounds</span>* <span style="color: #6ae4b9;">cur</span> = bounds;
    <span style="color: #ff6f9f;">while</span> (cur != <span style="color: #88ca9f;">NULL</span>) {
        <span style="color: #79a8ff;">ModuleBounds</span>* <span style="color: #6ae4b9;">next</span> = cur-&gt;next;
        free(cur);
        cur = next;
    }
}
</pre>
</div>

<p>
Finally, we can just call <code>get_module_bounds</code> and, while iterating those regions,
scan them using our <code>do_scan</code> function.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #989898;">/* </span><span style="color: #989898;">Search for `ida_pattern' in the specified `module'.</span><span style="color: #989898;"> */</span>
<span style="color: #79a8ff;">void</span>* <span style="color: #4ae2ff;">sigscan</span>(<span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">module</span>, <span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">ida_pattern</span>) {
    <span style="color: #989898;">/* </span><span style="color: #989898;">Get a linked list of ModuleBounds, containing the start and end addresses</span>
<span style="color: #989898;">     * of all the regions that match `module'.</span><span style="color: #989898;"> */</span>
    <span style="color: #79a8ff;">ModuleBounds</span>* <span style="color: #6ae4b9;">bounds</span> = get_module_bounds(module);

    <span style="color: #989898;">/* </span><span style="color: #989898;">Iterate them, and scan each one until we find a match.</span><span style="color: #989898;"> */</span>
    <span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">ret</span> = <span style="color: #88ca9f;">NULL</span>;
    <span style="color: #ff6f9f;">for</span> (<span style="color: #79a8ff;">ModuleBounds</span>* <span style="color: #6ae4b9;">cur</span> = bounds; cur != <span style="color: #88ca9f;">NULL</span>; cur = cur-&gt;next) {
        <span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">cur_result</span> = do_scan(cur-&gt;start, cur-&gt;end, ida_pattern);

        <span style="color: #ff6f9f;">if</span> (cur_result != <span style="color: #88ca9f;">NULL</span>) {
            ret = cur_result;
            <span style="color: #ff6f9f;">break</span>;
        }
    }

    <span style="color: #989898;">/* </span><span style="color: #989898;">Free the ModuleBounds linked list</span><span style="color: #989898;"> */</span>
    free_module_bounds(bounds);

    <span style="color: #ff6f9f;">return</span> ret;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-using-our-sigscan-function" class="outline-2">
<h2 id="using-our-sigscan-function"><span class="section-number-2">5.</span> Using our <code>sigscan</code> function</h2>
<div class="outline-text-2" id="text-using-our-sigscan-function">
<p>
Now that we have the signature and our function for scanning, we just have to
create a shared object that we can inject into a running process.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdio.h&gt;</span>

<span style="color: #989898;">/* </span><span style="color: #989898;">Random '?' just to show wilcards</span><span style="color: #989898;"> */</span>
<span style="color: #ff6740;">#define</span> <span style="color: #6ae4b9;">MY_SIG</span> <span style="color: #00d3d0;">"55 48 89 E5 48 83 EC 10 89 ? ? ? ? F8 8B 45 F8 ? ? FC 7F 0C 83"</span>

<span style="color: #989898;">/* </span><span style="color: #989898;">For readability</span><span style="color: #989898;"> */</span>
<span style="color: #ff6f9f;">typedef</span> <span style="color: #79a8ff;">int</span> (*<span style="color: #79a8ff;">func_ptr_t</span>)(<span style="color: #79a8ff;">int</span>, <span style="color: #79a8ff;">int</span>);

<span style="color: #989898;">/* </span><span style="color: #989898;">Entry point when injected</span><span style="color: #989898;"> */</span>
<span style="color: #ff6f9f;">__attribute__</span>((constructor)) <span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">load</span>(<span style="color: #79a8ff;">void</span>) {
    puts(<span style="color: #00d3d0;">"Library loaded."</span>);

    <span style="color: #79a8ff;">func_ptr_t</span> <span style="color: #6ae4b9;">found_func</span> = sigscan(<span style="color: #88ca9f;">NULL</span>, MY_SIG);
    <span style="color: #ff6f9f;">if</span> (found_func == <span style="color: #88ca9f;">NULL</span>) {
        fprintf(<span style="color: #88ca9f;">stderr</span>, <span style="color: #00d3d0;">"my_lib: Could not find function.</span><span style="color: #ff6f9f;">\n</span><span style="color: #00d3d0;">"</span>);
        <span style="color: #ff6f9f;">return</span>;
    }

    printf(<span style="color: #00d3d0;">"my_lib: Found function at </span><span style="color: #ff6f9f;">%p\n</span><span style="color: #00d3d0;">"</span>, found_func);

    <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">a</span> = found_func(<span style="color: #88ca9f;">0x500</span>, <span style="color: #88ca9f;">4</span>);
    printf(<span style="color: #00d3d0;">"my_lib: Function returned </span><span style="color: #ff6f9f;">%d\n</span><span style="color: #00d3d0;">"</span>, a);

    <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">b</span> = found_func(<span style="color: #88ca9f;">0x1000</span>, <span style="color: #88ca9f;">4</span>);
    printf(<span style="color: #00d3d0;">"my_lib: Function returned </span><span style="color: #ff6f9f;">%d\n</span><span style="color: #00d3d0;">"</span>, b);
}

<span style="color: #989898;">/* </span><span style="color: #989898;">Entry point when unloaded</span><span style="color: #989898;"> */</span>
<span style="color: #ff6f9f;">__attribute__</span>((destructor)) <span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">unload</span>() {
    <span style="color: #989898;">/* </span><span style="color: #cabf00; font-weight: bold;">TODO:</span><span style="color: #989898;"> Clean up stuff, if needed</span><span style="color: #989898;"> */</span>
    puts(<span style="color: #00d3d0;">"Library unloaded."</span>);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-injecting-script-and-final-makefile" class="outline-2">
<h2 id="injecting-script-and-final-makefile"><span class="section-number-2">6.</span> Injecting script and final Makefile</h2>
<div class="outline-text-2" id="text-injecting-script-and-final-makefile">
<p>
We can inject our library into the binary the <a href="https://www.sourceware.org/gdb/">GNU Debugger</a>.
</p>

<p>
First, we attach to the PID of our target process (<code>example.out</code>), and, after
locating <code>dlopen</code> and <code>dlerror</code>, we call <code>dlopen</code> with two arguments: the path of our
library and the number 2, which corresponds to <code>RTLD_NOW</code>.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #6ae4b9;">pid</span>=$(<span style="color: #feacd0;">pidof "example.out"</span>)
<span style="color: #6ae4b9;">libpath</span>=$(<span style="color: #feacd0;">realpath "my_lib.so"</span>)

<span style="color: #ff6f9f;">if</span> [ <span style="color: #00d3d0;">"$pid"</span> == <span style="color: #00d3d0;">""</span> ]; <span style="color: #ff6f9f;">then</span>
   <span style="color: #feacd0;">echo</span> <span style="color: #00d3d0;">"inject.sh: process not running."</span>
   <span style="color: #ff6f9f;">exit</span> <span style="color: #88ca9f;">1</span>
<span style="color: #ff6f9f;">fi</span>

sudo gdb -n -q -batch                                  <span style="color: #00d3d0;">\</span>
    -ex <span style="color: #00d3d0;">"attach $pid"</span>                                  <span style="color: #00d3d0;">\</span>
    -ex <span style="color: #00d3d0;">"set \$dlopen = (void* (*)(char*, int))dlopen"</span> <span style="color: #00d3d0;">\</span>
    -ex <span style="color: #00d3d0;">"set \$dlerror = (char* (*)(void))dlerror"</span>     <span style="color: #00d3d0;">\</span>
    -ex <span style="color: #00d3d0;">"call \$dlopen(\"$libpath\", 2)"</span>               <span style="color: #00d3d0;">\</span>
    -ex <span style="color: #00d3d0;">"call \$dlerror()"</span>                             <span style="color: #00d3d0;">\</span>
    -ex <span style="color: #00d3d0;">"detach"</span>                                       <span style="color: #00d3d0;">\</span>
    -ex <span style="color: #00d3d0;">"quit"</span>
</pre>
</div>

<p>
This is the final Makefile for compiling the example app, the library and for
injecting:
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #6ae4b9;">CC</span>=gcc
<span style="color: #6ae4b9;">CFLAGS</span>=-Wall -Wextra -O0 -fPIC

<span style="color: #4ae2ff;">.PHONY</span>: all inject

<span style="color: #4ae2ff;">all</span>: example.out my_lib.so

<span style="color: #4ae2ff;">example.out</span>: example.c
    $(<span style="color: #6ae4b9;">CC</span>) $(<span style="color: #6ae4b9;">CFLAGS</span>) -o <span style="color: #4ae2ff;">$</span><span style="color: #88ca9f;">@</span> $<span style="color: #88ca9f;">&lt;</span>

<span style="color: #4ae2ff;">my_lib.so</span>: my_lib.c
    $(<span style="color: #6ae4b9;">CC</span>) $(<span style="color: #6ae4b9;">CFLAGS</span>) -shared -o <span style="color: #4ae2ff;">$</span><span style="color: #88ca9f;">@</span> $<span style="color: #88ca9f;">&lt;</span>

<span style="color: #989898;"># </span><span style="color: #44bc44; font-weight: bold;">NOTE:</span><span style="color: #989898;"> Make sure example.out is running</span>
<span style="color: #4ae2ff;">inject</span>: my_lib.so
    bash ./inject.sh
</pre>
</div>
</div>
</div>

<div id="outline-container-signature-scanning-library" class="outline-2">
<h2 id="signature-scanning-library"><span class="section-number-2">7.</span> Signature scanning library</h2>
<div class="outline-text-2" id="text-signature-scanning-library">
<p>
If you just want something that works, I made a lightweight single-header
signature scanning library in pure C for GNU/Linux. This is the <a href="https://github.com/8dcc/libsigscan">link</a>.
</p>

<p>
Since it&rsquo;s a simple single-header library, you just need to copy the
<code>libsigscan.h</code> file to your project and <code>#include</code> it on your sources.
</p>

<p>
The library consists of just 2 functions: <code>sigscan_module()</code> and <code>sigscan()</code>. The
first scans the specified IDA signature in all the modules matching the
specified <i>regex</i> pattern. Note that it uses the <a href="https://www.gnu.org/software/sed/manual/html_node/ERE-syntax.html">Extended Regular Expression</a> (ERE)
syntax, so keep that in mind before escaping certain characters like <code>+</code> and
<code>?</code>. See also <a href="https://www.gnu.org/software/sed/manual/html_node/BRE-vs-ERE.html">BRE vs. ERE</a>.
</p>

<p>
The second function is just a wrapper for passing <code>NULL</code> to the first one,
therefore searching in all loaded modules. Depending on the memory being used by
the process, calling this function might take a few seconds, so it&rsquo;s better to
filter the module name with <code>sigscan_module()</code> whenever possible.
</p>
</div>
</div>
</div>
</body>
</html>
