#+TITLE: Understanding the Y combinator
#+AUTHOR: 8dcc
#+OPTIONS: toc:nil
#+STARTUP: nofold
#+HTML_HEAD: <link rel="icon" type="image/x-icon" href="../img/favicon.png">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css">

[[file:../index.org][Index]] | [[file:index.org][Up]]

-----

#+TOC: headlines 2

* Quick introduction to lambda calculus
:PROPERTIES:
:CUSTOM_ID: quick-introduction-to-lambda-calculus
:END:

*Lambda calculus* (\lambda-calculus) is a mathematical system for computation
based on _function abstraction_ and _application_, using _variable binding_ and
substitution.[fn:1]

** Rules
:PROPERTIES:
:CUSTOM_ID: rules
:END:

The beauty of lambda calculus is its simplicity. These are the only 3 rules:

1. $x$: A *variable* (symbol) represents a parameter.
2. $(\lambda x. M)$: A *lambda abstraction* is an anonymous function, with a
   parameter $x$ (between the \lambda and the dot), that returns the body $M$.
3. $(M\ N)$: An *application* of function $M$ to an argument $N$.

In the last rule, both $M$ and $N$ are lambda terms.

** Lambda terms
:PROPERTIES:
:CUSTOM_ID: lambda-terms
:END:

A *lambda term* is just a valid expression in the lambda calculus system. Well,
what makes an expression valid? The following 3 rules are used to determine if a
lambda expression is valid:

1. A *variable* $x$ is itself a valid lambda term.
2. If $M$ is a lambda term, and $x$ is a variable, then $(\lambda x. M)$ is also
   a lambda term (An *abstraction*).
3. If $M$ and $N$ are lambda terms, then $(M\ N)$ is also a lambda term (An
   *application*).

You can begin to feel the recursive magic of lambda calculus, before even
getting into an example.

** Reduction operations
:PROPERTIES:
:CUSTOM_ID: reduction-operations
:END:

Lambda calculus also has 2 main reduction operations:

1. $(\lambda x. M[x])$ \to $(\lambda y. M[y])$: *Alpha conversion*
   (\alpha-conversion), renaming the bound variables in the expression. Used to
   avoid name collisions.
2. $((\lambda x. M) N)$ \to $(M[x := N])$: *Beta reduction* (\beta-reduction),
   replacing the bound variables ($x$) with the argument expression ($N$) in the
   body ($M$) of the abstraction.

There is also *eta reduction* (\eta-reduction), which expresses the idea of
/extensionality/,[fn:2] which applied to this context establishes that two
functions are the same if and only if they give the same result for all
arguments.

** Notation
:PROPERTIES:
:CUSTOM_ID: notation
:END:

For understanding lambda notation, you will also have to keep in mind these
conventions:

1. Outermost parentheses are dropped: $M N$ instead of $(M N)$.
2. Applications are assumed to be left associative: $M N P$ instead of
   $((M N) P)$.
3. The body of an abstraction extends as far right as possible: $\lambda x. M N$
   means $\lambda x. (M N)$ and not $(\lambda x. M) N).
4. A sequence of abstractions is contracted:
   $(\lambda x. \lambda y. \lambda z. N)$ is abbreviated as
   $(\lambda x y z. N)$.
5. When all variables are single-letter, applications may be omitted: $(M N P)$
   instead of $(M\ N\ P)$.

Some of these look a bit confusing to me, specially when embedding expressions
in text, so I will try to make each expression as readable as possible.

* SICP, Lisp and JavaScript
:PROPERTIES:
:CUSTOM_ID: sicp-lisp-and-javascript
:END:

[[https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs][Structure and Interpretation of Computer Programs]] is an amazing book by Harold
Abelson and Gerald Jay Sussman. The book teaches the fundamental principles of
computer programming, including recursion, abstraction, modularity, and much
more.

This book has two editions. The first one uses [[https://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]] (a dialect of [[https://en.wikipedia.org/wiki/Lisp_(programming_language)][Lisp]]), for
its examples and explanations, while the second uses [[https://en.wikipedia.org/wiki/JavaScript][JavaScript]].

I have not written much JavaScript when writing this, but I will try to write
all examples in both lambda notation, Lisp and JavaScript.

* Simple example: Factorial
:PROPERTIES:
:CUSTOM_ID: simple-example-factorial
:END:

This is the function for calculating the factorial of a number $n$, using the
lambda calculus notation:

$$
\text{fact} = \lambda n. \Big(\big(\text{iszero}\ n\big) 1 \big(\text{mult}\ n
\ (\text{fact}\ (\text{prec}\ n)\big)\Big)
$$

#+begin_comment
NOTE: If this is incorrect or confusing and you have any suggestions, feel free
to make a PR.
#+end_comment

In Lisp:

#+begin_src scheme
(define fact
  (lambda (n)
    (if (equal? n 0)
        1
        (mult n (fact (prec n))))))
#+end_src

Or in JavaScript:

#+begin_src javascript
var fact = (n) => (n == 0)
    ? 1
    : mult(n, (fact(prec(n))));
#+end_src

We are defining =fact= as a function that takes a parameter =n=. This function
returns 1 if =n= is zero, and otherwise multiplies =n= by the factorial of the
number preceding =n=.

One of the most valuable things that SICP teached me is that sometimes it's
extremely useful to treat functions as black boxes that are able to transform
some inputs into some outputs. This has been useful not only when using
functions, but also when designing them.

In this case, we can simply ignore how =iszero=, =mult=, =prec= and even =fact= work
/internally/, we just have to trust that they do what we expect.

In any case, we don't have those name-defining commodities in lambda
calculus. We can't call ourselves by name, so we will have to find an
alternative way.

* Fixed points
:PROPERTIES:
:CUSTOM_ID: fixed-points
:END:

Before getting into the fixed-point combinators, we need to define what a fixed
point is.

A fixed point of function $f$ is a value that is mapped to itself by the
function.[fn:4] In other words, $x$ is a fixed point of $f$ if $f(x) = x$. For
this to be possible, $x$ has to belong to both the _domain_ of $f$ (set of values
that it can take), and the _codomain_ of $f$ (set of values that it can return).

For example, if $f(x) = x!$, 1 and 2 are fixed points, since $f(1) = 1$ and
$f(2) = 2$.

#+ATTR_HTML: :width 250px
[[file:../img/ycombinator1.png]]

The image shows the graph of a function $f$, with 3 fixed points. When plotting,
the point $(x, f(x))$, these 3 points were on the line $x = y$.

* Fixed-point combinators
:PROPERTIES:
:CUSTOM_ID: fixed-point-combinators
:END:

A *fixed-point combinator* is a higher-order function (i.e. a function that takes
a function as argument) that returns some fixed point of its argument
function.[fn:3]

So, if a function =fix= is a fixed-point combinator, a function =f= has one or
more fixed points, then =fix f= is one of these fixed points:

$$
f(\text{fix}\ f) = \text{fix}\ f
$$

* Y combinator
:PROPERTIES:
:CUSTOM_ID: y-combinator
:END:

An example of a fixed-point combinator is the Y combinator:

$$
Y = \lambda f. \big(\lambda x. f (x x)\big) \big(\lambda x. f (x x)\big)
$$

Let's try to understand what it does, and why it's a fixed-point combinator.

TODO

# -----

[fn:1] See the [[https://en.wikipedia.org/wiki/Lambda_calculus][Wikipedia page]] for lambda calculus.
[fn:2] See the [[https://en.wikipedia.org/wiki/Extensionality][Wikipedia page]] for extensionality.
[fn:3] See the [[https://en.wikipedia.org/wiki/Fixed-point_combinator][Wikipedia page]] for fixed-point combinator.
[fn:4] See the [[https://en.wikipedia.org/wiki/Fixed_point_(mathematics)][Wikipedia page]] for fixed point.
