<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding the FAT file system</title>
<meta property="og:title" content="Understanding the FAT file system" />
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../css/main.css">
</head>
<body>
<div id="org-div-home-and-up">
  <a accesskey="u" href="index.html">Up</a> | <a accesskey="h" href="../index.html">Home</a>
</div><div id="content" class="content">
<h1 class="title">Understanding the FAT file system</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#chs-and-lba-notations">2. CHS and LBA notations</a></li>
<li><a href="#boot-sector">3. Boot sector</a>
<ul>
<li><a href="#initial-bytes">3.1. Initial bytes</a></li>
<li><a href="#bios-parameter-block-bpb">3.2. Bios Parameter Block (BPB)</a></li>
<li><a href="#extra-data-and-magic-value">3.3. Extra data and magic value</a></li>
</ul>
</li>
<li><a href="#fsinfo-sector-fat32-only">4. FSInfo sector (FAT32 only)</a></li>
<li><a href="#file-allocation-table-fat">5. File Allocation Table (FAT)</a>
<ul>
<li><a href="#the-purpose-of-the-fat">5.1. The purpose of the FAT</a></li>
<li><a href="#the-layout-of-the-fat">5.2. The layout of the FAT</a></li>
</ul>
</li>
<li><a href="#root-directory">6. Root directory</a>
<ul>
<li><a href="#the-directoryentry-structure">6.1. The <code>DirectoryEntry</code> structure</a></li>
<li><a href="#location-and-size-of-the-root-directory">6.2. Location and size of the root directory</a></li>
</ul>
</li>
<li><a href="#data-region">7. Data region</a>
<ul>
<li><a href="#calculating-the-size-of-the-root-directory">7.1. Calculating the size of the root directory</a></li>
<li><a href="#calculating-the-first-data-sector">7.2. Calculating the first data sector</a></li>
<li><a href="#reading-the-contents-of-a-file">7.3. Reading the contents of a file</a></li>
</ul>
</li>
<li><a href="#final-note">8. Final note</a></li>
</ul>
</div>
</div>

<div id="outline-container-introduction" class="outline-2">
<h2 id="introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
The FAT file system was originally developed by Microsoft for the MS-DOS
operating system. I have been working on a <a href="https://github.com/8dcc/dump-fat">FAT parsing tool</a> for some days, and I
wanted to explain some of the things I have learned.
</p>

<p>
Although I will try to cover all FAT filesystems, note that I currently have
experience with FAT12, which is used in floppy disks; if I work on newer FAT
versions in the future, I will update this article with any relevant
information. The exFAT filesystem is not covered in this article.
</p>

<p>
The following figure shows the general layout of a FAT12/FAT16 volume (although
the FAT32 layout is very similar), each of which will be described in detail
below.
</p>


<div id="fig1" class="figure">
<p><img src="../img/understanding-fat1.svg" alt="understanding-fat1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 1: </span>General layout of a FAT12/FAT16 volume.</p>
</div>

<p>
Throughout this article I might reference the &ldquo;FAT specification&rdquo;, that is,
version 1.03 of the &ldquo;FAT32 File System Specification&rdquo;, which can be found as
<a href="../external/fatgen103.pdf"><code>fatgen103.pdf</code></a>.
</p>
</div>
</div>

<div id="outline-container-chs-and-lba-notations" class="outline-2">
<h2 id="chs-and-lba-notations"><span class="section-number-2">2.</span> CHS and LBA notations</h2>
<div class="outline-text-2" id="text-chs-and-lba-notations">
<p>
When referring to locations of a disk, the term <i>sector</i> is commonly used. A
<a href="https://en.wikipedia.org/wiki/Disk_sector">sector</a> is simply a fixed-size block of contiguous bytes, which is the minimum
storage unit of a hard drive. There are two common notations used to describe
the position of a sector in the disk, <i>Cylinder-Head-Sector</i> and <i>Logical Block
Addressing</i>; although only the latter will be used in this article, both of them
will be briefly explained here.
</p>

<dl class="org-dl">
<dt>Cylinder-Head-Sector (CHS) notation</dt><dd><p>
A group of 3 numbers in used to designate the physical location of a block of
data in a hard disk. The <i>cylinder</i> (or <i>track</i>) indicates the radial coordinate
relative to the center of the platter, the <i>head</i> indicates the platter and side
where the data is, and the <i>sector</i> indicates the angular coordinate relative to
the platter. The following figure shows these 3 coordinates in a hard disk.
</p>


<div id="fig2" class="figure">
<p><img src="../img/understanding-fat2.svg" alt="understanding-fat2.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 2: </span>Cylinder-Head-Sector representation on a hard disk.</p>
</div>

<p>
Note that the cylinder and head numbers start at 0, but the first sector
number in CHS notation is 1, not 0. For more information, see the <a href="https://en.wikipedia.org/wiki/Cylinder-head-sector">Wikipedia
page</a> for Cylinder-Head-Sector, where that image was originally extracted
from.
</p></dd>

<dt>Logical Block Addressing (LBA) notation</dt><dd>A single index, starting from 0, is used to linearly identify a block of data
(usually a single sector) in a hard disk. Therefore, LBA address 0 corresponds
to CHS address <code>0/0/1</code>.</dd>
</dl>
</div>
</div>

<div id="outline-container-boot-sector" class="outline-2">
<h2 id="boot-sector"><span class="section-number-2">3.</span> Boot sector</h2>
<div class="outline-text-2" id="text-boot-sector">
<p>
The first sector of the FAT volume is the <i>Boot Sector</i>. The following
figure<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> shows the highlighted hexdump of a FAT12 boot sector,
showing the different parts that will be explained below.
</p>


<div id="fig3" class="figure">
<p><img src="../img/understanding-fat3.png" alt="understanding-fat3.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Layout of a FAT12 boot sector.</p>
</div>
</div>

<div id="outline-container-initial-bytes" class="outline-3">
<h3 id="initial-bytes"><span class="section-number-3">3.1.</span> Initial bytes</h3>
<div class="outline-text-3" id="text-initial-bytes">
<p>
The first 3 bytes of the sector are a short <code>jmp</code> instruction followed by a <code>nop</code>
byte, used if the volume is bootable. The next 8 bytes are the <a href="https://en.wikipedia.org/wiki/Original_equipment_manufacturer">OEM</a> name, padded
with spaces (<code>0x20</code>). This is usually the name of the tool that was used to build
the filesystem image (e.g. <code>mkfs.fat</code>).
</p>
</div>
</div>

<div id="outline-container-bios-parameter-block-bpb" class="outline-3">
<h3 id="bios-parameter-block-bpb"><span class="section-number-3">3.2.</span> Bios Parameter Block (BPB)</h3>
<div class="outline-text-3" id="text-bios-parameter-block-bpb">
<p>
After the OEM name, it comes the <a href="https://en.wikipedia.org/wiki/BIOS_Parameter_Block">BIOS Parameter Block</a> (BPB), a data structure
describing the layout of the volume. The following table describes the contents
of the base BPB, common in all FAT filesystems.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Layout of the Bios Parameter Block for DOS 3.31.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">BPB Offset</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0x00</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Bytes per logical sector</td>
</tr>

<tr>
<td class="org-left"><code>0x02</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Logical sectors per cluster</td>
</tr>

<tr>
<td class="org-left"><code>0x03</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Reserved logical sectors</td>
</tr>

<tr>
<td class="org-left"><code>0x05</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Number of FATs</td>
</tr>

<tr>
<td class="org-left"><code>0x06</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Root directory entries</td>
</tr>

<tr>
<td class="org-left"><code>0x08</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Total logical sectors</td>
</tr>

<tr>
<td class="org-left"><code>0x0A</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Media descriptor</td>
</tr>

<tr>
<td class="org-left"><code>0x0B</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Logical sectors per FAT</td>
</tr>

<tr>
<td class="org-left"><code>0x0D</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Physical sectors per track</td>
</tr>

<tr>
<td class="org-left"><code>0x0F</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Number of heads</td>
</tr>

<tr>
<td class="org-left"><code>0x11</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Hidden sectors</td>
</tr>

<tr>
<td class="org-left"><code>0x15</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Large total logical sectors</td>
</tr>
</tbody>
</table>

<p>
FAT filesystems extend this structure with different fields, and the final
structure is usually called <i>Extended BIOS Parameter Block</i> (EBPB). Please note
that the term &ldquo;BPB&rdquo; will be used when refering to the base structure described
in the first table, which is shared by all filesystem versions, while the term
&ldquo;EBPB&rdquo; will be used when refering to one of the other two tables and its
contents.
</p>

<p>
The following table describes the extra fields in FAT12 and FAT16 volumes.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Layout of the Extended BPB for DOS 4.0, used in FAT12 and FAT16.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">BPB Offset</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0x19</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Physical drive number</td>
</tr>

<tr>
<td class="org-left"><code>0x1A</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Reserved</td>
</tr>

<tr>
<td class="org-left"><code>0x1B</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Extended boot signature (<code>0x29</code>, see below)</td>
</tr>

<tr>
<td class="org-left"><code>0x1C</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Volume serial number</td>
</tr>

<tr>
<td class="org-left"><code>0x20</code></td>
<td class="org-left"><code>char[11]</code></td>
<td class="org-left">Volume label (padded with spaces)</td>
</tr>

<tr>
<td class="org-left"><code>0x2B</code></td>
<td class="org-left"><code>char[8]</code></td>
<td class="org-left">File-system type (padded with spaces)</td>
</tr>
</tbody>
</table>

<p>
And the next table describes the extra fields in FAT12 volumes.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Layout of the Extended BPB for DOS 4.0, used in FAT12 and FAT16.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">BPB Offset</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0x19</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Logical sectors per FAT</td>
</tr>

<tr>
<td class="org-left"><code>0x1D</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Mirroring flags etc.</td>
</tr>

<tr>
<td class="org-left"><code>0x1F</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Version</td>
</tr>

<tr>
<td class="org-left"><code>0x21</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Root directory cluster</td>
</tr>

<tr>
<td class="org-left"><code>0x25</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Location of FSInfo sector</td>
</tr>

<tr>
<td class="org-left"><code>0x27</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Location of backup sector(s)</td>
</tr>

<tr>
<td class="org-left"><code>0x29</code></td>
<td class="org-left"><code>char[12]</code></td>
<td class="org-left">Reserved</td>
</tr>

<tr>
<td class="org-left"><code>0x35</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Physical drive number</td>
</tr>

<tr>
<td class="org-left"><code>0x36</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Reserved</td>
</tr>

<tr>
<td class="org-left"><code>0x37</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Extended boot signature (<code>0x29</code>)</td>
</tr>

<tr>
<td class="org-left"><code>0x38</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Volume serial number</td>
</tr>

<tr>
<td class="org-left"><code>0x3C</code></td>
<td class="org-left"><code>char[11]</code></td>
<td class="org-left">Volume label (padded with spaces)</td>
</tr>

<tr>
<td class="org-left"><code>0x47</code></td>
<td class="org-left"><code>char[8]</code></td>
<td class="org-left">File-system type (padded with spaces)</td>
</tr>
</tbody>
</table>

<p>
Note that, in both the FAT12/FAT16 and FAT32 versions, the value of the <i>Extended
boot signature</i> field should be <code>0x29</code> to indicate that there are 3 fields left at
that point; a value of <code>0x28</code>, on the other hand, would indicate that there is
only one field left, the <i>Volume serial number</i>. Originally, byte <code>0x28</code> was used to
indicate that the volume was using the DOS 3.4 EBPB, while byte <code>0x29</code> indicated
the EBPB for DOS 4.0 version.
</p>
</div>
</div>

<div id="outline-container-extra-data-and-magic-value" class="outline-3">
<h3 id="extra-data-and-magic-value"><span class="section-number-3">3.3.</span> Extra data and magic value</h3>
<div class="outline-text-3" id="text-extra-data-and-magic-value">
<p>
The remainder of the sector (up to offset 509, included) can be used to store
executable instructions, which are normally the destination of the <code>jmp</code>
instruction mentioned <a href="#initial-bytes">above</a>; or to store any extra data that the system might
need.
</p>

<p>
The bytes at offset 510 and 511 should be <code>0x55</code> and <code>0xAA</code>, respectively, a magic
value that indicates the BIOS that the sector is bootable. Note that this magic
value might be written as <code>0x55AA</code> or <code>0xAA55</code> depending on the machine&rsquo;s
<a href="https://en.wikipedia.org/wiki/Endianness">endianness</a>, but the BIOS will expect byte <code>0x55</code> first, followed by <code>0xAA</code>, so it&rsquo;s
better to write them separately to avoid confusion.
</p>

<p>
These two bytes are usually the last ones of the first sector, since the <i>Bytes
per logical sector</i> field of the BPB structure is usually 512, but they don&rsquo;t
necessarily have to be. The BIOS will check the bytes at offset 510 and 511, not
at the end of the sector.
</p>
</div>
</div>
</div>

<div id="outline-container-fsinfo-sector-fat32-only" class="outline-2">
<h2 id="fsinfo-sector-fat32-only"><span class="section-number-2">4.</span> FSInfo sector (FAT32 only)</h2>
<div class="outline-text-2" id="text-fsinfo-sector-fat32-only">
<p>
This data structure is specific to FAT32, so I haven&rsquo;t used it at this point,
but I will still mention it. It&rsquo;s usually located in the second sector (sector
1), but this is determined by the <i>Location of FSInfo sector</i> field of the FAT32
EBPB.
</p>

<p>
The FSInfo data structure contains, among some hard-coded signatures, the last
known number of free sectors in the volume and the cluster number where the
driver should start looking for free clusters. This information is not strictly
necessary, but it helps with performance, since the 32-bit FAT can be quite
large.
</p>

<p>
For now, you might want to check the <a href="https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#FS_Information_Sector">Wikipedia section</a>, and pages 21-22 of the
FAT32 specification.
</p>
</div>
</div>

<div id="outline-container-file-allocation-table-fat" class="outline-2">
<h2 id="file-allocation-table-fat"><span class="section-number-2">5.</span> File Allocation Table (FAT)</h2>
<div class="outline-text-2" id="text-file-allocation-table-fat">
<p>
The next important data structure is the <i>File Allocation Table</i> itself. There may
be more than one FAT, depending on the fourth field of the BPB, but the first
FAT is always located right after the reserved sectors (such as the boot
sector). We can obtain the number of reserved sectors from the third field of
the BPB.
</p>
</div>

<div id="outline-container-the-purpose-of-the-fat" class="outline-3">
<h3 id="the-purpose-of-the-fat"><span class="section-number-3">5.1.</span> The purpose of the FAT</h3>
<div class="outline-text-3" id="text-the-purpose-of-the-fat">
<p>
The FAT is an array of numbers that is used to define <a href="https://en.wikipedia.org/wiki/Linked_list">linked lists</a> of the
clusters that form the contents of a file. In order to fully understand this
definition, some concepts need to be explained first.
</p>

<p>
Just like a sector is a fixed-size block of contiguous bytes, a <i>cluster</i> is
simply a fixed-size group of contiguous sectors. The number of sectors that form
a cluster can be obtained from the second field of the BPB. For example, if each
cluster is 4 sectors (according to the second field), and each sector is 512
bytes (according to the first field), a cluster would use 2048 contiguous bytes.
</p>

<p>
The meaning of the term <i>file</i> can vary depending on the context and the level of
abstraction, but it will be used in this context to refer to a data structure
that contains information (i.e. <a href="https://en.wikipedia.org/wiki/Metadata">metadata</a>) about some arbitrary amount of data
(i.e. the actual file contents). A file structure, which will take the name
<code>DirectoryEntry</code> below, contains information such as the filename, the size of the
data in bytes, and the creation and access dates.
</p>

<p>
While this file metadata is stored in some place that will be discussed below,
the actual contents of the file are stored in one or more clusters (which are
not necessarily adjacent to each other) in the <i>data region</i>. The data region is
located after the root directory, as shown in <a href="#fig1">Figure 1</a>.
</p>

<p>
For example, if the cluster size was 2KiB and we wanted to store an 11KiB file,
we would need to somehow build a 6-element list that kept track of the clusters
that store that file&rsquo;s data (the last one won&rsquo;t be full, but still &ldquo;owned&rdquo; by
this file).
</p>


<div id="fig4" class="figure">
<p><img src="../img/understanding-fat4.svg" alt="understanding-fat4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 4: </span>File contents stored in 6 non-adjacent clusters.</p>
</div>

<p>
Given a specific cluster index, there would need to be a way of retrieving the
index of the next cluster on its list. To accomplish this, each cluster in the
volume is assigned an entry in the FAT sequentially, so the first cluster would
be assigned to entry 0 of the FAT, the second element to entry 1, and so on
(this is not entirely accurate, as explained below). Each entry in the FAT will
then contain the cluster index of its <i>next</i> element, or a special marker to
indicate the end of the linked list<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>.
</p>

<p>
For example, in order to build the cluster list represented in the previous
figure, the following pseudo-code could be used. In this case, value of the
<i>end-of-chain</i> marker assumes that this is a 16-bit FAT.
</p>

<pre class="example" id="example1">
fat[0] = 2;      /* Cluster 1 is skipped */
fat[2] = 3;
fat[3] = 4;
fat[4] = 5;
fat[5] = 7;      /* Cluster 6 is skipped */
fat[7] = 0xFFFF; /* Mark end of chain */
</pre>

<p>
As shown below, this is not entirely accurate, since the first data cluster is
not mapped to the first element of the FAT. Either way, the important note is
that the FAT is used to keep track of the clusters that store the contents of
files, by building linked lists with their cluster indexes.
</p>
</div>
</div>

<div id="outline-container-the-layout-of-the-fat" class="outline-3">
<h3 id="the-layout-of-the-fat"><span class="section-number-3">5.2.</span> The layout of the FAT</h3>
<div class="outline-text-3" id="text-the-layout-of-the-fat">
<p>
The size of each FAT entry changes depending on the filesystem version, and that
is precisely what the 12/16/32 number indicates: the size of a FAT entry in
bits. The 16-bit version will be used for explaining the layout of the FAT,
since each entry is two bytes, and therefore easier to understand. The layout of
a 32-bit FAT is pretty similar, the size of each element is just twice as
big. The 12-bit version, however, is more tricky since it uses one bit and a
half (i.e. 3 <a href="https://en.wikipedia.org/wiki/Nibble">nibbles</a>), so it will be explained in detail below.
</p>

<p>
The following figure shows the hexdump of the first 64 bytes of a 16-bit
FAT. Each (non-empty) entry has been highlighted to show their linked
list. Please note that the hexadecimal offsets in the following figure are
expressed in bytes, but the FAT stores the linked lists with indexes to other
16-bit entries.
</p>


<div id="fig5" class="figure">
<p><img src="../img/understanding-fat5.png" alt="understanding-fat5.png" />
</p>
<p><span class="figure-number">Figure 5: </span>Layout of a 16-bit File Allocation Table.</p>
</div>

<p>
The first thing that should be noted about the FAT, and about the filesystem in
general, is that it&rsquo;s <i>strictly little-endian</i>, meaning that the least-significant
bytes are stored at a smaller offset in the disk (i.e. the value <code>0xAABBCCDD</code>
would be stored as <code>DD CC BB AA</code>). The previous figure shows a hexdump, and
although the bytes are grouped in pairs, they are dumped one by one, in the
order in which they are stored in the disk. For example, the contents of the
third 16-bit entry are displayed as <code>0300</code>, but actually correspond to the value
<code>0x0003</code>. This will be specially important later when describing the layout of a
12-bit FAT, since each entry is one byte and a half.
</p>

<p>
The first two entries of the FAT are reserved, the first one usually being the
<i>FAT ID</i>, and the second usually being the value used as the <i>end-of-chain</i>
marker. Therefore, the first data cluster would correspond to the third entry of
the FAT, not the first one. Since the linked lists themselves are built using
&ldquo;absolute&rdquo; indexes in the FAT, the real cluster indexes can be calculated by
subtracting 2 from the value stored in the FAT. For example, in the previous
figure, entry 4 of the FAT contains the value 5, so the real index of the next
cluster in the list would be 3, since it&rsquo;s the fourth actual cluster in the
volume.
</p>

<p>
As noted above, the 12-bit FAT is a bit more complicated, because each entry is
one byte and a half. To The following figure shows how the previous 16-bit FAT
would be represented with 12-bits per entry. Since each entry is 3 nibbles, and
the structure is little-endian, nibbles in entries with an odd index have been
highlighted in bold, to hopefully make it easier to visualize.
</p>


<div id="fig6" class="figure">
<p><img src="../img/understanding-fat6.png" alt="understanding-fat6.png" />
</p>
<p><span class="figure-number">Figure 6: </span>Layout of a 12-bit File Allocation Table.</p>
</div>

<p>
Also note how there are 15 bytes per row in this figure, instead of 16 like in
the previous one. This has been done to avoid having one byte of the entry in
one line (e.g. the <code>0x14</code> at offset <code>0x0F</code>) and the third nibble in another line
(e.g. the lower half of the byte at offset <code>0x10</code>).
</p>

<p>
Just to emphasize again, since the byte ordering can be confusing in this
version, the following example shows how the entries are distributed and nibbles
ordered in the 12-bit FAT.
</p>

<pre class="example" id="org945b5dc">
Entry distribution:

  AA BA BB CC DC DD EE FE FF ...
  `------´ `------´ `------´
   Two      Two      Two
   entries  entries  entries

Nibble order:

  23 61 45 89 C7 AB EF 3D 12 ...
  `------´ `------´ `------´
   0x123,   0x789,   0xDEF,
   0x456    0xABC    0x123
</pre>
</div>
</div>
</div>

<div id="outline-container-root-directory" class="outline-2">
<h2 id="root-directory"><span class="section-number-2">6.</span> Root directory</h2>
<div class="outline-text-2" id="text-root-directory">
<p>
As mentioned above, the metadata that was refered to as a <i>file</i> is represented as
a data structure called <code>DirectoryEntry</code>. The root directory is simply an array of
these structures. Before explaining how to determine the array location and
size, the layout of a single element needs to be defined.
</p>
</div>

<div id="outline-container-the-directoryentry-structure" class="outline-3">
<h3 id="the-directoryentry-structure"><span class="section-number-3">6.1.</span> The <code>DirectoryEntry</code> structure</h3>
<div class="outline-text-3" id="text-the-directoryentry-structure">
<p>
The following table shows the fields of the <code>DirectoryEntry</code> structure.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 4:</span> Layout of a Directory Entry.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Offset</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0x00</code></td>
<td class="org-left"><code>char[11]</code></td>
<td class="org-left">Short file name</td>
</tr>

<tr>
<td class="org-left"><code>0x0B</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">File attributes</td>
</tr>

<tr>
<td class="org-left"><code>0x0C</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Reserved</td>
</tr>

<tr>
<td class="org-left"><code>0x0D</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Creation time (tenths of a second)</td>
</tr>

<tr>
<td class="org-left"><code>0x0E</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Creation time (hour, minute, second)</td>
</tr>

<tr>
<td class="org-left"><code>0x10</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Creation date (year, month, day)</td>
</tr>

<tr>
<td class="org-left"><code>0x12</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Last access date (year, month, day)</td>
</tr>

<tr>
<td class="org-left"><code>0x14</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">High word of the first cluster index (for FAT32)</td>
</tr>

<tr>
<td class="org-left"><code>0x16</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Modification time (hour, minute, second)</td>
</tr>

<tr>
<td class="org-left"><code>0x18</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Modification date (year, month, day)</td>
</tr>

<tr>
<td class="org-left"><code>0x1A</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Low word of the first cluster index</td>
</tr>

<tr>
<td class="org-left"><code>0x16</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Size in bytes</td>
</tr>
</tbody>
</table>

<p>
The name field follows the <a href="https://en.wikipedia.org/wiki/8.3_filename">8.3 filename scheme</a>, where the first 8 bytes of the
array are the file name padded with spaces, and the last 3 bytes are the file
extension.
</p>

<p>
Each bit in the <i>File attributes</i> field indicates a different property, according
to the following table.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 5:</span> File attribute bits.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Mask (hex)</th>
<th scope="col" class="org-left">Mask (binary)</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0x01</code></td>
<td class="org-left"><code>0b00000001</code></td>
<td class="org-left">Read only</td>
</tr>

<tr>
<td class="org-left"><code>0x02</code></td>
<td class="org-left"><code>0b00000010</code></td>
<td class="org-left">Hidden</td>
</tr>

<tr>
<td class="org-left"><code>0x04</code></td>
<td class="org-left"><code>0b00000100</code></td>
<td class="org-left">System</td>
</tr>

<tr>
<td class="org-left"><code>0x08</code></td>
<td class="org-left"><code>0b00001000</code></td>
<td class="org-left">Volume ID</td>
</tr>

<tr>
<td class="org-left"><code>0x10</code></td>
<td class="org-left"><code>0b00010000</code></td>
<td class="org-left">Directory</td>
</tr>

<tr>
<td class="org-left"><code>0x20</code></td>
<td class="org-left"><code>0b00100000</code></td>
<td class="org-left">Archive</td>
</tr>

<tr>
<td class="org-left"><code>0x40</code></td>
<td class="org-left"><code>0b01000000</code></td>
<td class="org-left">Reserved (device)</td>
</tr>

<tr>
<td class="org-left"><code>0x80</code></td>
<td class="org-left"><code>0b10000000</code></td>
<td class="org-left">Reserved</td>
</tr>

<tr>
<td class="org-left"><code>0x0F</code></td>
<td class="org-left"><code>0b00001111</code></td>
<td class="org-left">Long name</td>
</tr>
</tbody>
</table>

<p>
The third field of a <code>DirectoryEntry</code> contains the creation time in tenths of a
second, and its value range is <code>[0..199]</code>. The dates and times in the structure
are stored as 16-bit integers with the following layouts:
</p>

<pre class="example" id="example2">
Time: hhhhhhmmmmmsssss
      `----´`---´`---´
       Hour  Min  Sec

Date: yyyyyyymmmmddddd
      `-----´`--´`---´
       Year   Mon Day
</pre>
</div>
</div>

<div id="outline-container-location-and-size-of-the-root-directory" class="outline-3">
<h3 id="location-and-size-of-the-root-directory"><span class="section-number-3">6.2.</span> Location and size of the root directory</h3>
<div class="outline-text-3" id="text-location-and-size-of-the-root-directory">
<p>
Just like the EBPB changes between FAT12/FAT16 and FAT32, the method for
determining the location and size of the root directory also change. These
differences will be explained now.
</p>

<dl class="org-dl">
<dt>Location and size in FAT12 and FAT16</dt><dd><p>
In FAT12 and FAT16, this array is located right after the FAT(s), so
the sector number can be calculated by multiplying the number of FATs by the
size of a FAT, and adding that to the number of reserved sectors. All three of
these values can be obtained from the base BPB.
</p>

<p>
The number of <code>DirectoryEntry</code> elements of the array is determined by the <i>Root
directory entries</i> field of the BPB.
</p></dd>

<dt>Location and size in FAT32</dt><dd><p>
In FAT32 filesystems, the location of the root directory is determined by the
<i>Root directory cluster</i> entry of the EBPB, which usually has a value of 2, but
not necessarily.
</p>

<p>
In FAT32 filesystems, the <i>Root directory entries</i> field of the BPB must be set
to zero, so the number of entries is calculated by following the chain of
cluster indexes that is stored in the FAT, just like any other directory.
</p></dd>
</dl>

<p>
Once the location and size of the root directory is known, it can be accessed
like a normal array, each element being 32 bytes.
</p>
</div>
</div>
</div>

<div id="outline-container-data-region" class="outline-2">
<h2 id="data-region"><span class="section-number-2">7.</span> Data region</h2>
<div class="outline-text-2" id="text-data-region">
<p>
At this point, it has been explained how to access the data in the EBPB, how to
access and navigate the FAT, and how to obtain the array of <code>DirectoryEntry</code>
structures in the root directory. With this information, it should be possible to:
</p>

<ol class="org-ol">
<li>Iterate the root directory, searching for files that match certain properties
(e.g. whose name matches <i>X</i>, that was created before the <i>Y</i> date).</li>
<li>Obtain the first cluster index of that file.</li>
<li>Traverse the linked list of cluster indexes through the FAT.</li>
</ol>

<p>
However, it&rsquo;s necessary to know where these clusters are, and how they can be
accesses to read the actual contents of files. The contents of the files are
stored in the <i>data</i> region, so the sector where this region starts should be
calculated first. Before explaining how the first data sector is calculated,
it&rsquo;s necessary to know how to calculate the size of the root directory.
</p>
</div>

<div id="outline-container-calculating-the-size-of-the-root-directory" class="outline-3">
<h3 id="calculating-the-size-of-the-root-directory"><span class="section-number-3">7.1.</span> Calculating the size of the root directory</h3>
<div class="outline-text-3" id="text-calculating-the-size-of-the-root-directory">
<p>
The size of the root directory in sectors can be calculated by multiplying its
number of entries by the size of a single entry in bytes, dividing that by the
number of bytes per sector, and rounding up:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">uint32_t</span> <span style="color: #6ae4b9;">root_dir_bytes</span> =
    bpb-&gt;root_dir_entry_count * <span style="color: #ff6f9f;">sizeof</span>(<span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">DirectoryEntry</span>);

<span style="color: #79a8ff;">uint32_t</span> <span style="color: #6ae4b9;">root_dir_sectors</span> = root_dir_bytes / bpb-&gt;bytes_per_sector;
<span style="color: #ff6f9f;">if</span> (root_dir_bytes % bpb-&gt;bytes_per_sector != <span style="color: #88ca9f;">0</span>)
    root_dir_sectors++;
</pre>
</div>

<p>
Alternatively, as recommended in page 13 of the FAT specification, one can round
up by adding the number of bytes per sector minus one before performing the
integer division:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">uint32_t</span> <span style="color: #6ae4b9;">root_dir_bytes</span> =
    bpb-&gt;root_dir_entry_count * <span style="color: #ff6f9f;">sizeof</span>(<span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">DirectoryEntry</span>);

<span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">uint32_t</span> <span style="color: #6ae4b9;">root_dir_sectors</span> =
  (root_dir_bytes + (bpb-&gt;bytes_per_sector - <span style="color: #88ca9f;">1</span>)) /
    bpb-&gt;bytes_per_sector;
</pre>
</div>

<p>
Note that, on FAT32, the <i>Root directory entries</i> field of the BPB is zero, so the
result of these operations will also be zero. This is expected when calculating
the first data sector below.
</p>
</div>
</div>

<div id="outline-container-calculating-the-first-data-sector" class="outline-3">
<h3 id="calculating-the-first-data-sector"><span class="section-number-3">7.2.</span> Calculating the first data sector</h3>
<div class="outline-text-3" id="text-calculating-the-first-data-sector">
<p>
The first data sector can be calculated by adding the number of reserved sectors
(such as the boot sector), the number of sectors used by the FAT(s), and the
number of sectors used by the root directory.
</p>

<p>
The number of reserved sectors can be obtained from the third field of the BPB,
as explained when <a href="#file-allocation-table-fat">calculating the location of the FAT</a>. The number of sectors
used by the FAT is determined by either the <i>Logical sectors per FAT</i> field of the
base BPB, or, if it&rsquo;s zero, by the <i>Logical sectors per FAT</i> field of the FAT32
EBPB. The number of sectors of the root directory is calculated using any of the
methods from the <a href="#calculating-the-size-of-the-root-directory">previous section</a>; again, note that this value is expected to be
zero in FAT32.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">size_t</span> <span style="color: #6ae4b9;">sectors_per_fat</span> = (bpb-&gt;sectors_per_fat_16 == <span style="color: #88ca9f;">0</span>)
                                 ? bpb-&gt;sectors_per_fat_16
                                 : ebpb-&gt;sectors_per_fat_32;

<span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">uint16_t</span> <span style="color: #6ae4b9;">reserved_sectors</span>  = bpb-&gt;reserved_sectors;
<span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">uint32_t</span> <span style="color: #6ae4b9;">total_fat_sectors</span> = bpb-&gt;fat_count * sectors_per_fat;
<span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">uint32_t</span> <span style="color: #6ae4b9;">root_dir_sectors</span>  = <span style="color: #989898;">/* </span><span style="color: #989898;">Shown above</span><span style="color: #989898;"> */</span>;

<span style="color: #ff6f9f;">const</span> <span style="color: #79a8ff;">uint32_t</span> <span style="color: #6ae4b9;">first_data_sector</span> =
  reserved_sectors + total_fat_sectors + root_dir_sectors;
</pre>
</div>
</div>
</div>

<div id="outline-container-reading-the-contents-of-a-file" class="outline-3">
<h3 id="reading-the-contents-of-a-file"><span class="section-number-3">7.3.</span> Reading the contents of a file</h3>
<div class="outline-text-3" id="text-reading-the-contents-of-a-file">
<p>
With this information in mind, it should be possible to calculate the clusters
numbers where the file contents are stored, and the sector when the data region
starts, therefore allowing us to read all the necessary sectors that contain the
file contents. This is the general algorithm for accomplishing this:
</p>

<ol class="org-ol">
<li>Obtain the sector where the FAT starts, the sector where the root directory
starts, and the size in sectors of the root directory. All this has been
explained above.</li>
<li>Search for the file by iterating the root directory until the <i>name</i> field of a
<code>DirectoryEntry</code> structure matches the filename you are looking for.</li>
<li>Obtain the <b>first FAT index</b> in the chain of clusters that hold the contents of the
file. This index can be obtained from the <i>Low word of the first cluster index</i>
field of the <code>DirectoryEntry</code>. Note that this index is for the FAT, it&rsquo;s not
the real cluster number in the volume.</li>
<li>Calculate the <b>real cluster number</b> by subtracting 2 (i.e. the number of
reserved FAT entries) from the FAT index that was just obtained.</li>
<li>Calculate the <b>sector number</b> by multiplying the real cluster number by the
number of <i>Logical sectors per cluster</i> (second element of the BPB), and adding
that to the number of sectors before the <i>Data region</i>, as explained above.</li>
<li>Somehow <b>read from the disk</b> a cluster worth of sectors, starting at the sector
number from the previous step.</li>
<li>Obtain the <b>next FAT index</b> by reading the value stored at the FAT entry
corresponding to the current FAT index (i.e. <code>fat_idx = fat[fat_idx]</code>).</li>
<li>If the new FAT index is smaller than the <i>end-of-chain</i> marker, go back to
step 2. Otherwise, we are done with the file.</li>
</ol>

<p>
In FAT32, when reading the FAT index, you will need to also use the <i>High word of
the first cluster index</i> field of the <code>DirectoryEntry</code>.
</p>

<p>
Also note that, as explained above, getting the <i>next FAT index</i> might be more
complicated depending on the endianness of the machine, since all the structures
in the FAT filesystem are little-endian.
</p>
</div>
</div>
</div>

<div id="outline-container-final-note" class="outline-2">
<h2 id="final-note"><span class="section-number-2">8.</span> Final note</h2>
<div class="outline-text-2" id="text-final-note">
<p>
As explained in the introduction, I have only worked with FAT12, and although I
tried to include as much information about FAT16 and FAT32 as possible, it&rsquo;s
very likely that I have made some mistakes or left some information out. If you
find any errors, or have any suggestions, feel free to <a href="../index.html#contributing">contribute</a>.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Some diagrams in this article have been exported as PNG because some
browsers didn&rsquo;t display the text highlighting correctly. The SVG version, which
can be edited using <a href="https://app.diagrams.net/">draw.io</a>, is also available, just change the file extension
from <code>.png</code> to <code>.svg</code>.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">For FAT12, this <i>end-of-chain</i> marker is
any value greater or equal than <code>0xFF8</code>; for FAT16, any value greater or equal
than <code>0xFFF8</code>; and for FAT32, any value greater or equal than <code>0xFFFFFFF8</code>.</p></div></div>


</div>
</div></div>
</body>
</html>
