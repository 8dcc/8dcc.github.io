<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding the FAT file system</title>
<meta property="og:title" content="Understanding the FAT file system" />
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../css/main.css">
</head>
<body>
<div id="org-div-home-and-up">
  <a accesskey="u" href="index.html">Up</a> | <a accesskey="h" href="../index.html">Home</a>
</div><div id="content" class="content">
<h1 class="title">Understanding the FAT file system</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#chs-and-lba-notations">2. CHS and LBA notations</a></li>
<li><a href="#boot-sector">3. Boot sector</a>
<ul>
<li><a href="#initial-bytes">3.1. Initial bytes</a></li>
<li><a href="#bios-parameter-block-bpb">3.2. Bios Parameter Block (BPB)</a></li>
<li><a href="#bootable-code-and-magic-value">3.3. Bootable code and magic value</a></li>
</ul>
</li>
<li><a href="#fsinfo-sector-fat32-only">4. FSInfo sector (FAT32 only)</a></li>
<li><a href="#file-allocation-table-fat">5. File Allocation Table (FAT)</a>
<ul>
<li><a href="#the-purpose-of-the-fat">5.1. The purpose of the FAT</a></li>
<li><a href="#the-layout-of-the-fat">5.2. The layout of the FAT</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-introduction" class="outline-2">
<h2 id="introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
The FAT file system was originally developed by Microsoft for the MS-DOS
operating system. I have been working on a <a href="https://github.com/8dcc/dump-fat">FAT parsing tool</a> for some days, and I
wanted to explain some of the things I have learned.
</p>

<p>
Although I will try to cover all FAT filesystems, note that I currently have
experience with FAT12, which is used in floppy disks; if I work on newer FAT
versions in the future, I will update this article with any relevant
information. The exFAT filesystem is not covered in this article.
</p>

<p>
The following figure shows the general layout of a FAT12/FAT16 volume (although
the FAT32 layout is very similar), each of which will be described in detail
below.
</p>


<div id="fig1" class="figure">
<p><img src="../img/understanding-fat1.svg" alt="understanding-fat1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 1: </span>General layout of a FAT12/FAT16 volume.</p>
</div>

<p>
Throughout this article I might reference the &ldquo;FAT specification&rdquo;, that is,
version 1.03 of the &ldquo;FAT32 File System Specification&rdquo;, which can be found as
<a href="../external/fatgen103.pdf"><code>fatgen103.pdf</code></a>.
</p>
</div>
</div>

<div id="outline-container-chs-and-lba-notations" class="outline-2">
<h2 id="chs-and-lba-notations"><span class="section-number-2">2.</span> CHS and LBA notations</h2>
<div class="outline-text-2" id="text-chs-and-lba-notations">
<p>
When referring to locations of a disk, I will be using one of the following two
notations, so I will describe them briefly.
</p>

<dl class="org-dl">
<dt>Cylinder-Head-Sector (CHS) notation</dt><dd><p>
A group of 3 numbers used to designate the physical location of a block of
data in a hard disk. The <i>cylinder</i> or <i>track</i> indicates the radial coordinate
relative to the center of the platter, the <i>head</i> indicates the platter and side
where the data is, and the <i>sector</i> indicates the angular coordinate relative to
the platter. The following figure shows these 3 coordinates in a hard disk.
</p>


<div id="fig2" class="figure">
<p><img src="../img/understanding-fat2.svg" alt="understanding-fat2.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 2: </span>Cylinder-Head-Sector representation on a hard disk.</p>
</div>

<p>
See also the <a href="https://en.wikipedia.org/wiki/Cylinder-head-sector">Wikipedia page</a> for Cylinder-Head-Sector, where that image is
from.
</p></dd>

<dt>Logical Block Addressing (LBA) notation</dt><dd>Single index, starting from 0, used to linearly identify a block of data
(usually a <a href="https://en.wikipedia.org/wiki/Disk_sector">sector</a>, as described in the CHS notation) in a hard disk.</dd>
</dl>
</div>
</div>

<div id="outline-container-boot-sector" class="outline-2">
<h2 id="boot-sector"><span class="section-number-2">3.</span> Boot sector</h2>
<div class="outline-text-2" id="text-boot-sector">
<p>
The first sector of the FAT volume is the <i>Boot Sector</i>. It has a CHS address of
<code>0/0/1</code>, which is the same as LBA address 0. The following figure<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> shows the highlighted hexdump of a FAT12 boot sector, with the different
parts that will be explained below.
</p>


<div id="fig3" class="figure">
<p><img src="../img/understanding-fat3.png" alt="understanding-fat3.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Layout of a FAT12 boot sector.</p>
</div>
</div>

<div id="outline-container-initial-bytes" class="outline-3">
<h3 id="initial-bytes"><span class="section-number-3">3.1.</span> Initial bytes</h3>
<div class="outline-text-3" id="text-initial-bytes">
<p>
The first 3 bytes of the sector are a short <code>jmp</code> instruction followed by a <code>nop</code>
byte, used if the volume is bootable.
</p>

<p>
The next 8 bytes are the <a href="https://en.wikipedia.org/wiki/Original_equipment_manufacturer">OEM</a> name, padded with spaces (<code>0x20</code>). This is usually
the name of the tool that was used to build the file system image
(e.g. <code>mkfs.fat</code>).
</p>
</div>
</div>

<div id="outline-container-bios-parameter-block-bpb" class="outline-3">
<h3 id="bios-parameter-block-bpb"><span class="section-number-3">3.2.</span> Bios Parameter Block (BPB)</h3>
<div class="outline-text-3" id="text-bios-parameter-block-bpb">
<p>
After the OEM name, it comes the <a href="https://en.wikipedia.org/wiki/BIOS_Parameter_Block">BIOS Parameter Block</a> (BPB), a data structure
describing the layout of the volume. The following table describes the contents
of the base BPB, common in all FAT filesystems.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Layout of the Bios Parameter Block for DOS 3.31.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">BPB Offset</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0x00</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Bytes per logical sector</td>
</tr>

<tr>
<td class="org-left"><code>0x02</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Logical sectors per cluster</td>
</tr>

<tr>
<td class="org-left"><code>0x03</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Reserved logical sectors</td>
</tr>

<tr>
<td class="org-left"><code>0x05</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Number of FATs</td>
</tr>

<tr>
<td class="org-left"><code>0x06</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Root directory entries</td>
</tr>

<tr>
<td class="org-left"><code>0x08</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Total logical sectors</td>
</tr>

<tr>
<td class="org-left"><code>0x0A</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Media descriptor</td>
</tr>

<tr>
<td class="org-left"><code>0x0B</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Logical sectors per FAT</td>
</tr>

<tr>
<td class="org-left"><code>0x0D</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Physical sectors per track</td>
</tr>

<tr>
<td class="org-left"><code>0x0F</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Number of heads</td>
</tr>

<tr>
<td class="org-left"><code>0x11</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Hidden sectors</td>
</tr>

<tr>
<td class="org-left"><code>0x15</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Large total logical sectors</td>
</tr>
</tbody>
</table>

<p>
FAT filesystems extend this structure with different fields, but the final
structure is usually called <i>Extended BIOS Parameter Block</i> (EBPB).
</p>

<p>
The following table describes the extra fields used in FAT12 and FAT16 volumes.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Layout of the Extended BPB for DOS 4.0, used in FAT12 and FAT16.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">BPB Offset</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0x19</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Physical drive number</td>
</tr>

<tr>
<td class="org-left"><code>0x1A</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Reserved</td>
</tr>

<tr>
<td class="org-left"><code>0x1B</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Extended boot signature (<code>0x29</code>, see below)</td>
</tr>

<tr>
<td class="org-left"><code>0x1C</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Volume serial number</td>
</tr>

<tr>
<td class="org-left"><code>0x20</code></td>
<td class="org-left"><code>char[11]</code></td>
<td class="org-left">Volume label (padded with spaces)</td>
</tr>

<tr>
<td class="org-left"><code>0x2B</code></td>
<td class="org-left"><code>char[8]</code></td>
<td class="org-left">File-system type (padded with spaces)</td>
</tr>
</tbody>
</table>

<p>
And the following table describes the extra fields used in FAT12 volumes.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Layout of the Extended BPB for DOS 4.0, used in FAT12 and FAT16.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">BPB Offset</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0x19</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Logical sectors per FAT</td>
</tr>

<tr>
<td class="org-left"><code>0x1D</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Mirroring flags etc.</td>
</tr>

<tr>
<td class="org-left"><code>0x1F</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Version</td>
</tr>

<tr>
<td class="org-left"><code>0x21</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Root directory cluster</td>
</tr>

<tr>
<td class="org-left"><code>0x25</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Location of FSInfo sector</td>
</tr>

<tr>
<td class="org-left"><code>0x27</code></td>
<td class="org-left"><code>uint16_t</code></td>
<td class="org-left">Location of backup sector(s)</td>
</tr>

<tr>
<td class="org-left"><code>0x29</code></td>
<td class="org-left"><code>char[12]</code></td>
<td class="org-left">Reserved</td>
</tr>

<tr>
<td class="org-left"><code>0x35</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Physical drive number</td>
</tr>

<tr>
<td class="org-left"><code>0x36</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Reserved</td>
</tr>

<tr>
<td class="org-left"><code>0x37</code></td>
<td class="org-left"><code>uint8_t</code></td>
<td class="org-left">Extended boot signature (<code>0x29</code>)</td>
</tr>

<tr>
<td class="org-left"><code>0x38</code></td>
<td class="org-left"><code>uint32_t</code></td>
<td class="org-left">Volume serial number</td>
</tr>

<tr>
<td class="org-left"><code>0x3C</code></td>
<td class="org-left"><code>char[11]</code></td>
<td class="org-left">Volume label (padded with spaces)</td>
</tr>

<tr>
<td class="org-left"><code>0x47</code></td>
<td class="org-left"><code>char[8]</code></td>
<td class="org-left">File-system type (padded with spaces)</td>
</tr>
</tbody>
</table>

<p>
Note that, in both the FAT12/FAT16 and FAT32 versions, the value of the <i>Extended
boot signature</i> field should be <code>0x29</code> to indicate that there are 3 fields left,
since a value of <code>0x28</code> indicates that there is only one field left, the <i>Volume
serial number</i>. Originally, byte <code>0x28</code> was used to indicate that the volume was
using the DOS 3.4 EBPB, while byte <code>0x29</code> indicated the EBPB for DOS 4.0 version.
</p>
</div>
</div>

<div id="outline-container-bootable-code-and-magic-value" class="outline-3">
<h3 id="bootable-code-and-magic-value"><span class="section-number-3">3.3.</span> Bootable code and magic value</h3>
<div class="outline-text-3" id="text-bootable-code-and-magic-value">
<p>
The remainder of the sector can be used to store executable instructions, so the
first <a href="#initial-bytes"><code>jmp</code> instruction</a> can jump to them on boot.
</p>

<p>
The bytes at offset 510 and 511 should be <code>0x55</code> and <code>0xAA</code>, respectively, to
indicate the BIOS that the sector is bootable. Note that this magic value might
be written as <code>0x55AA</code> or <code>0xAA55</code> depending on the machine&rsquo;s <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a>, but the
BIOS will expect byte <code>0x55</code> first, followed by <code>0xAA</code>, so it&rsquo;s better to write them
separately to avoid confusion.
</p>

<p>
These two bytes are usually the last ones of the first sector, since the <i>Bytes
per logical sector</i> field of the BPB structure is usually 512, but they don&rsquo;t
necessarily have to be. The BIOS will check the bytes at offset 510 and 511, not
the end of the sector.
</p>
</div>
</div>
</div>

<div id="outline-container-fsinfo-sector-fat32-only" class="outline-2">
<h2 id="fsinfo-sector-fat32-only"><span class="section-number-2">4.</span> FSInfo sector (FAT32 only)</h2>
<div class="outline-text-2" id="text-fsinfo-sector-fat32-only">
<p>
This data structure is specific to FAT32, so I haven&rsquo;t used it at this point,
but I will still mention it. It&rsquo;s usually located in the second sector (sector
1), but this is determined by the <i>Location of FSInfo sector</i> field of the FAT32
EBPB.
</p>

<p>
The FSInfo data structure contains, among some hard-coded signatures, the last
known number of free sectors in the volume and the cluster number where the
driver should start looking for free clusters. This information is not strictly
necessary, but it helps with performance, since the 32-bit FAT can be quite
large.
</p>

<p>
For now, you might want to check the <a href="https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#FS_Information_Sector">Wikipedia section</a>, and pages 21-22 of the
FAT32 specification.
</p>
</div>
</div>

<div id="outline-container-file-allocation-table-fat" class="outline-2">
<h2 id="file-allocation-table-fat"><span class="section-number-2">5.</span> File Allocation Table (FAT)</h2>
<div class="outline-text-2" id="text-file-allocation-table-fat">
<p>
The next important data structure is the <i>File Allocation Table</i> itself. There may
be more than one FAT, depending on the fourth field of the BPB, but the first
FAT is always located right after the reserved sectors (such as the boot
sector). We can obtain the number of reserved sectors from the third field of
the BPB, and we can obtain the FAT offset in bytes by multiplying the <i>Reserved
logical sectors</i> and <i>Bytes per logical sector</i> fields of the BPB.
</p>
</div>

<div id="outline-container-the-purpose-of-the-fat" class="outline-3">
<h3 id="the-purpose-of-the-fat"><span class="section-number-3">5.1.</span> The purpose of the FAT</h3>
<div class="outline-text-3" id="text-the-purpose-of-the-fat">
<p>
The FAT is an array of numbers that is used to define <a href="https://en.wikipedia.org/wiki/Linked_list">linked lists</a> of the
clusters that form the contents of a file. This definition might be a bit
overwhelming, so lets focus on some of these terms first.
</p>

<p>
A <i>cluster</i> is simply a fixed-size group of contiguous sectors. The number of
sectors that form a cluster can be obtained from the second field of the
BPB. For example, if each cluster is 4 sectors (according to the second field),
and each sector is 512 bytes (according to the first field), a cluster would use
2048 contiguous bytes.
</p>

<p>
The meaning of the term <i>file</i> can vary depending on the context and the level of
abstraction, but I will use it to talk about a data structure that contains
information (i.e. <a href="https://en.wikipedia.org/wiki/Metadata">metadata</a>) about its contents (i.e. an arbitrary amount of
data/bytes). A file structure, which will take the name <code>DirectoryEntry</code> below,
contains information such as the filename, the size of the data in bytes, and
the creation and access dates.
</p>

<p>
While this file metadata is stored in some place that will be discussed below,
the actual contents of the file are stored in one or more clusters (not
necessarily adjacent to each other) in the <i>data region</i> (which is located after
the root directory, as shown in <a href="#fig1">Figure 1</a>). For example, if each cluster is 2KiB
and we wanted to store an 11KiB file, we would need to somehow build a 6-element
list that kept track of the sectors that store that file&rsquo;s data (the last one
won&rsquo;t be full, but still &ldquo;owned&rdquo; by this file).
</p>


<div id="fig4" class="figure">
<p><img src="../img/understanding-fat4.svg" alt="understanding-fat4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 4: </span>File contents stored in 6 non-adjacent clusters.</p>
</div>

<p>
Given a specific cluster index, there would need to be some way of retrieving
the index of the next cluster on its list. To accomplish this, each cluster in
the volume is assigned an entry in the FAT sequentially, so the first cluster
would be assigned to the entry 0 of the FAT (this is not entirely accurate, as
explained below). Each entry in the FAT will then contain the cluster index of
its <i>next</i> element, or a special marker to indicate the end of the linked list (a
value bigger or equal than <code>0xFF8</code>).
</p>

<p>
For example, if the contents of a file were stored in clusters 0, 3 and 5, the
first entry of the FAT will contain the number 3, the fourth entry would contain
the number 5, and the sixth entry would contain an <i>end-of-chain</i> indicator such
as <code>0xFFFF</code>.
</p>

<p>
Therefore, the FAT can be used to keep track of the clusters that store the
contents of files, by building linked lists with their cluster indexes.
</p>
</div>
</div>

<div id="outline-container-the-layout-of-the-fat" class="outline-3">
<h3 id="the-layout-of-the-fat"><span class="section-number-3">5.2.</span> The layout of the FAT</h3>
<div class="outline-text-3" id="text-the-layout-of-the-fat">
<p>
The size of each FAT entry changes depending on the filesystem version, and that
is precisely what the 12/16/32 number indicates: the size of a FAT entry in
bits. The 16-bit version will be used for explaining the layout of the FAT,
since each entry is two bytes, and therefore easier to understand. The 12-bit
version, which uses one bit and a half (i.e. 3 <a href="https://en.wikipedia.org/wiki/Nibble">nibbles</a>), is a bit more tricky,
so it will be explained in detail below.
</p>

<p>
The following figure shows the hexdump of the first 64 bytes of a 16-bit
FAT. Each (non-empty) entry has been highlighted to show their linked
list. Please note that the offsets in the previous figure are expressed in
bytes, but the FAT stores the linked lists with indexes to other 16-bit entries.
</p>


<div id="fig5" class="figure">
<p><img src="../img/understanding-fat5.png" alt="understanding-fat5.png" />
</p>
<p><span class="figure-number">Figure 5: </span>Layout of a 16-bit File Allocation Table.</p>
</div>


<p>
The first two entries of the FAT are reserved, the first one usually being the
<i>FAT ID</i>, and the second usually being the <i>end-of-chain</i> marker. Therefore, the
first data cluster would correspond to the third entry of the FAT, not the first
one. Since the linked lists themselves are built using &ldquo;absolute&rdquo; indexes in the
FAT, the real cluster indexes can be calculated by subtracting 2 from the value
stored in the FAT.
</p>

<p>
For example, in the previous figure, entry 4 of the FAT contains the value 5, so
the real index of the next cluster in the list would be 3, since it&rsquo;s the fourth
actual cluster in the volume.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Some
diagrams in this article have been exported as PNG because some browsers didn&rsquo;t
display the text highlighting correctly. The SVG version, which can be edited
using <a href="https://app.diagrams.net/">draw.io</a>, is also available, just change the file extension from <code>.png</code> to
<code>.svg</code>.</p></div></div>


</div>
</div></div>
</body>
</html>
