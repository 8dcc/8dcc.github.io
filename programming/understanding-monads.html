<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding Monads</title>
<meta property="og:title" content="Understanding Monads" />
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../css/main.css">
</head>
<body>
<div id="org-div-home-and-up">
  <a accesskey="u" href="index.html">Up</a> | <a accesskey="h" href="../index.html">Home</a>
</div><div id="content" class="content">
<h1 class="title">Understanding Monads</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#pure-functions">2. Pure functions</a></li>
<li><a href="#from-impure-to-monadic">3. From impure to monadic</a>
<ul>
<li><a href="#a-simple-writer">3.1. A simple writer</a></li>
<li><a href="#making-the-writer-pure">3.2. Making the writer pure</a></li>
<li><a href="#extracting-the-binding-logic">3.3. Extracting the binding logic</a></li>
<li><a href="#making-the-writer-a-monad">3.4. Making the writer a monad</a></li>
<li><a href="#final-code">3.5. Final code</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-introduction" class="outline-2">
<h2 id="introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
This article is about <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">monads</a> in the context of programming, specifically about a
design pattern that is often used in purely functional languages, such as
<a href="https://www.haskell.org/">Haskell</a>. This concept originates from <a href="https://en.wikipedia.org/wiki/Category_theory">category theory</a>, but this article won&rsquo;t be
focusing on that.
</p>

<p>
Although I haven&rsquo;t personally used Haskell a lot, I have known about monads for
a long time, probably since I heard about the <a href="https://en.wikipedia.org/wiki/Xmonad">xmonad</a> window manager. After
researching on this topic for a few days, I decided to write a small article
about what I learned, since it might be useful for some people. This article
won&rsquo;t focus specifically on Haskell, so most concepts can be applied to many
languages, and not a lot of programming background is required from the reader.
</p>

<p>
Lastly, I would like to mention that this article won&rsquo;t be focusing specifically
on Haskell; if you are interested in that, I recommend you check out the
articles on <a href="https://mmhaskell.com/monads">this link</a>.
</p>
</div>
</div>

<div id="outline-container-pure-functions" class="outline-2">
<h2 id="pure-functions"><span class="section-number-2">2.</span> Pure functions</h2>
<div class="outline-text-2" id="text-pure-functions">
<p>
Before trying to understand monads and their use cases, it&rsquo;s important to know
about <a href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a>, and why they are desirable. Pure functions are a kind of
function that satisfy 2 properties:
</p>

<ol class="org-ol">
<li>The value returned by the function depends only on its inputs, so identical
values are returned across multiple calls with identical inputs.</li>
<li>The function must not have <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">side effects</a>, such as modifying global variables,
input/output streams, etc.</li>
</ol>

<p>
For example, the following python functions are pure<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>, since they don&rsquo;t break any of
the rules above.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">double_sum</span>(a, b):
    <span style="color: #ff6f9f;">return</span> (a + b) * <span style="color: #88ca9f;">2</span>

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">count_uppercase</span>(string):
    <span style="color: #6ae4b9;">result</span> = <span style="color: #88ca9f;">0</span>
    <span style="color: #ff6f9f;">for</span> character <span style="color: #ff6f9f;">in</span> string:
        <span style="color: #ff6f9f;">if</span> character.isupper():
            <span style="color: #6ae4b9;">result</span> += <span style="color: #88ca9f;">1</span>
    <span style="color: #ff6f9f;">return</span> result;
</pre>
</div>

<p>
However, the following are not pure, because they are either influenced by the
external program state, or because they alter it.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #6ae4b9;">my_global</span> = <span style="color: #88ca9f;">0</span>

<span style="color: #989898;"># </span><span style="color: #989898;">Accesses external state.</span>
<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">global_sum</span>(n):
    <span style="color: #ff6f9f;">return</span> my_global + n

<span style="color: #989898;"># </span><span style="color: #989898;">Modifies external state (global variable).</span>
<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">impure_sum</span>(a, b):
    <span style="color: #6ae4b9;">my_global</span> = <span style="color: #88ca9f;">123</span>
    <span style="color: #ff6f9f;">return</span> a + b

<span style="color: #989898;"># </span><span style="color: #989898;">Modifies external state (I/O stream).</span>
<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">print_sum</span>(a, b):
    <span style="color: #6ae4b9;">result</span> = a + b
    <span style="color: #feacd0;">print</span>(f<span style="color: #00d3d0;">"Result: </span>{result}<span style="color: #00d3d0;">"</span>)
    <span style="color: #ff6f9f;">return</span> result
</pre>
</div>

<p>
Pure functions offer many advantages over impure functions, for both the machine
(compiler, interpreter) and the human (designing the architecture, programming,
testing, documenting). Some of these advantages include:
</p>

<ul class="org-ul">
<li><b>Result caching</b> (<a href="https://en.wikipedia.org/wiki/Memoization">Memoization</a>): If a pure function is repeatedly called with
the same arguments, since it&rsquo;s guaranteed to return the same result given the
same inputs, it could be stored in a look-up table, for better performance
when called multiple times.</li>
<li><b>Better optimizations</b>: If the compiler/interpreter knows that a function is
pure, it can safely do many more optimizations, including result caching, or
skipping calls altogether<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>.</li>
<li><b>Predictability and security</b>: From the programmer&rsquo;s point of view, it&rsquo;s much
easier to test a pure function than an impure one, since it doesn&rsquo;t depend on
an external environment that might make the tests more unreliable or complex.</li>
</ul>
</div>
</div>

<div id="outline-container-from-impure-to-monadic" class="outline-2">
<h2 id="from-impure-to-monadic"><span class="section-number-2">3.</span> From impure to monadic</h2>
<div class="outline-text-2" id="text-from-impure-to-monadic">
<p>
Before diving into what monads are, it&rsquo;s important to understand the problem
that they attempt to solve. Monads are useful when a series of steps or
computations (e.g. function calls) need to be combined, and when these
computations somehow extend an input type, adding some kind of context. For
example, the programmer might want to combine or link a series of functions
whose arguments are integers, but whose returned data type is a more complex
structure that extends the received integer type.
</p>
</div>

<div id="outline-container-a-simple-writer" class="outline-3">
<h3 id="a-simple-writer"><span class="section-number-3">3.1.</span> A simple writer</h3>
<div class="outline-text-3" id="text-a-simple-writer">
<p>
To illustrate this problem, along with a possible solution, the <i>writer</i> monad
will be used, which allows functions to extend a base type with a series of logs
that will be appended together into a list. Below is some Python code that
implements this <i>writer</i> functionality without using a monad. Each function
performs some computation (in this case, simple arithmetic operations), while
also logging a string into a global list variable.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #6ae4b9;">global_log_list</span> = []

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">add</span>(a, b):
    global_log_list.append(f<span style="color: #00d3d0;">"Added </span>{a}<span style="color: #00d3d0;"> to </span>{b}<span style="color: #00d3d0;">"</span>)
    <span style="color: #ff6f9f;">return</span> a + b

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">sub</span>(a, b):
    global_log_list.append(f<span style="color: #00d3d0;">"Subtracted </span>{a}<span style="color: #00d3d0;"> from </span>{b}<span style="color: #00d3d0;">"</span>)
    <span style="color: #ff6f9f;">return</span> a - b

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">mul</span>(a, b):
    global_log_list.append(f<span style="color: #00d3d0;">"Multiplied </span>{a}<span style="color: #00d3d0;"> to </span>{b}<span style="color: #00d3d0;">"</span>)
    <span style="color: #ff6f9f;">return</span> a * b

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">div</span>(a, b):
    global_log_list.append(f<span style="color: #00d3d0;">"Divided </span>{a}<span style="color: #00d3d0;"> by </span>{b}<span style="color: #00d3d0;">"</span>)
    <span style="color: #ff6f9f;">return</span> a / b
</pre>
</div>

<p>
To combine calls to these functions with the current design, one may store the
result of each call in a variable, pass it to the next function as an argument,
and overwrite the stored result with the new returned value. After the chain of
computations is done, the final result is stored, along with the list of logs
that were generated by the functions.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #6ae4b9;">result</span> = add(<span style="color: #88ca9f;">6</span>, <span style="color: #88ca9f;">5</span>)
<span style="color: #6ae4b9;">result</span> = sub(result, <span style="color: #88ca9f;">4</span>)
<span style="color: #6ae4b9;">result</span> = mul(result, <span style="color: #88ca9f;">3</span>)
<span style="color: #6ae4b9;">result</span> = div(result, <span style="color: #88ca9f;">2</span>)

<span style="color: #feacd0;">print</span>(f<span style="color: #00d3d0;">"Final result: </span>{result}<span style="color: #00d3d0;">"</span>)
<span style="color: #feacd0;">print</span>(<span style="color: #00d3d0;">"Logs:"</span>)
<span style="color: #ff6f9f;">for</span> line <span style="color: #ff6f9f;">in</span> global_log_list:
    <span style="color: #feacd0;">print</span>(f<span style="color: #00d3d0;">"  * </span>{line}<span style="color: #00d3d0;">"</span>)
</pre>
</div>

<p>
The previous code would print the following output:
</p>

<pre class="example" id="example1">
Final result: 10.5
Logs:
  * Added 6 to 5
  * Subtracted 11 from 4
  * Multiplied 7 to 3
  * Divided 21 by 2
</pre>

<p>
Notice how the internal structure of those functions is very similar, and since
much behavior is shared, they could be further abstracted. Also note how the
functions are not pure because they produce side effects by modifying a
global variable.
</p>
</div>
</div>

<div id="outline-container-making-the-writer-pure" class="outline-3">
<h3 id="making-the-writer-pure"><span class="section-number-3">3.2.</span> Making the writer pure</h3>
<div class="outline-text-3" id="text-making-the-writer-pure">
<p>
Instead of modifying a global list, these functions could return their log line
as part of the result, making them pure. In order to chain multiple functions,
combining their logs, they could also receive the previous log list as part of
their arguments.
</p>

<p>
First, a new data type should be defined, which extends the integer type by
adding the log list.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff6f9f;">class</span> <span style="color: #79a8ff;">LoggedInt</span>:
    <span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">__init__</span>(<span style="color: #ff6f9f;">self</span>, val, logs):
        <span style="color: #ff6f9f;">self</span>.<span style="color: #6ae4b9;">val</span> = val
        <span style="color: #ff6f9f;">self</span>.<span style="color: #6ae4b9;">logs</span> = logs

<span style="color: #989898;"># </span><span style="color: #989898;">Example</span>
<span style="color: #6ae4b9;">logged_int</span> = LoggedInt(<span style="color: #88ca9f;">5</span>, [<span style="color: #00d3d0;">"Some log line"</span>, <span style="color: #00d3d0;">"Another log line"</span>])
</pre>
</div>

<p>
The arithmetic functions can be modified to receive and return this new data
type, appending the new log line to the previous log list. Note how the first
argument of the following functions is a <code>LoggedInt</code>, but the second argument is
still a simple integer.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">add</span>(logged_a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        logged_a.val + b,  <span style="color: #989898;"># </span><span style="color: #989898;">New value</span>
        logged_a.logs + [f<span style="color: #00d3d0;">"Added </span>{logged_a.val}<span style="color: #00d3d0;"> to </span>{b}<span style="color: #00d3d0;">"</span>]  <span style="color: #989898;"># </span><span style="color: #989898;">Extended log list</span>
    )

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">sub</span>(logged_a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        logged_a.val - b,
        logged_a.logs + [f<span style="color: #00d3d0;">"Subtracted </span>{logged_a.val}<span style="color: #00d3d0;"> from </span>{b}<span style="color: #00d3d0;">"</span>]
    )

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">mul</span>(logged_a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        logged_a.val * b,
        logged_a.logs + [f<span style="color: #00d3d0;">"Multiplied </span>{logged_a.val}<span style="color: #00d3d0;"> to </span>{b}<span style="color: #00d3d0;">"</span>]
    )

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">div</span>(logged_a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        logged_a.val / b,
        logged_a.logs + [f<span style="color: #00d3d0;">"Divided </span>{logged_a.val}<span style="color: #00d3d0;"> by </span>{b}<span style="color: #00d3d0;">"</span>]
    )
</pre>
</div>

<p>
The usage of these functions is similar to the previous ones, but since they now
receive a <code>LoggedInt</code> as their first argument, the first input integer needs to be
<i>promoted</i> to a <code>LoggedInt</code>, initially with an empty log list.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #6ae4b9;">logged_result</span> = LoggedInt(<span style="color: #88ca9f;">6</span>, [])
<span style="color: #6ae4b9;">logged_result</span> = add(logged_result, <span style="color: #88ca9f;">5</span>)
<span style="color: #6ae4b9;">logged_result</span> = sub(logged_result, <span style="color: #88ca9f;">4</span>)
<span style="color: #6ae4b9;">logged_result</span> = mul(logged_result, <span style="color: #88ca9f;">3</span>)
<span style="color: #6ae4b9;">logged_result</span> = div(logged_result, <span style="color: #88ca9f;">2</span>)

<span style="color: #feacd0;">print</span>(f<span style="color: #00d3d0;">"Final result: </span>{logged_result.val}<span style="color: #00d3d0;">"</span>)
<span style="color: #feacd0;">print</span>(<span style="color: #00d3d0;">"Logs:"</span>)
<span style="color: #ff6f9f;">for</span> line <span style="color: #ff6f9f;">in</span> logged_result.logs:
    <span style="color: #feacd0;">print</span>(f<span style="color: #00d3d0;">"  * </span>{line}<span style="color: #00d3d0;">"</span>)
</pre>
</div>

<p>
With this simple change, the functions are now pure. At this point, however,
this design pattern isn&rsquo;t exactly a monad, and some of the shared logic can be
extracted into separate functions.
</p>
</div>
</div>

<div id="outline-container-extracting-the-binding-logic" class="outline-3">
<h3 id="extracting-the-binding-logic"><span class="section-number-3">3.3.</span> Extracting the binding logic</h3>
<div class="outline-text-3" id="text-extracting-the-binding-logic">
<p>
The previous code can be further abstracted by moving the &ldquo;combination logic&rdquo;
into a separate <i>binding function</i>. Before defining this <code>bind</code> function, the
arithmetic functions should be modified so they return a <code>LoggedInt</code> while still
receiving unwrapped integers.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">add</span>(a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        a + b,  <span style="color: #989898;"># </span><span style="color: #989898;">New value</span>
        [f<span style="color: #00d3d0;">"Added </span>{a}<span style="color: #00d3d0;"> to </span>{b}<span style="color: #00d3d0;">"</span>]  <span style="color: #989898;"># </span><span style="color: #989898;">Written log line</span>
    )

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">sub</span>(a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        a - b,
        [f<span style="color: #00d3d0;">"Subtracted </span>{a}<span style="color: #00d3d0;"> from </span>{b}<span style="color: #00d3d0;">"</span>]
    )

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">mul</span>(a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        a * b,
        [f<span style="color: #00d3d0;">"Multiplied </span>{a}<span style="color: #00d3d0;"> to </span>{b}<span style="color: #00d3d0;">"</span>]
    )

<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">div</span>(a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        a / b,
        [f<span style="color: #00d3d0;">"Divided </span>{a}<span style="color: #00d3d0;"> by </span>{b}<span style="color: #00d3d0;">"</span>]
    )
</pre>
</div>

<p>
The functions now receive two simple integers, and return a new <code>LoggedInt</code> that
contains the result value and the log line written by that specific
function. Note how the log line needs to be wrapped in a one-element list, since
the <code>LoggedInt</code> type expects a log <i>list</i>, not a string.
</p>

<p>
Now that the combination logic has been removed from the arithmetic functions,
the <code>bind</code> function can be implemented, which receives a <code>LoggedInt</code> value (<code>a</code>), one of
the arithmetic functions, and a simple integer (<code>b</code>). It performs the following steps:
</p>

<ol class="org-ol">
<li>Unwrap/extract the original integer value from <code>a</code>, the received <code>LoggedInt</code>.</li>
<li>Call the transformation function with the unwrapped value and <code>b</code>, the received
simple integer.</li>
<li>Combine the logs of the received <code>LoggedInt</code> with the logs of the <code>LoggedInt</code>
that was returned by transformation function.</li>
</ol>

<p>
Through this process, it applies the received function to the other two values,
and combines that result with the original <code>LoggedInt</code> value.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">bind</span>(old_logged_int, function, b):
    <span style="color: #6ae4b9;">unwrapped_val</span> = old_logged_int.val
    <span style="color: #6ae4b9;">new_logged_int</span> = function(unwrapped_val, b)
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        new_logged_int.val,
        old_logged_int.logs + new_logged_int.logs
    )
</pre>
</div>

<p>
Instead of calling the arithmetic functions directly, they are now passed as
arguments to <code>bind</code>, which will call the function and combine the logs, returning
a new <code>LoggedInt</code> result.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #6ae4b9;">logged_result</span> = LoggedInt(<span style="color: #88ca9f;">6</span>, [])
<span style="color: #6ae4b9;">logged_result</span> = bind(logged_result, add, <span style="color: #88ca9f;">5</span>)
<span style="color: #6ae4b9;">logged_result</span> = bind(logged_result, sub, <span style="color: #88ca9f;">4</span>)
<span style="color: #6ae4b9;">logged_result</span> = bind(logged_result, mul, <span style="color: #88ca9f;">3</span>)
<span style="color: #6ae4b9;">logged_result</span> = bind(logged_result, div, <span style="color: #88ca9f;">2</span>)

<span style="color: #feacd0;">print</span>(f<span style="color: #00d3d0;">"Final result: </span>{logged_result.val}<span style="color: #00d3d0;">"</span>)
<span style="color: #feacd0;">print</span>(<span style="color: #00d3d0;">"Logs:"</span>)
<span style="color: #ff6f9f;">for</span> line <span style="color: #ff6f9f;">in</span> logged_result.logs:
    <span style="color: #feacd0;">print</span>(f<span style="color: #00d3d0;">"  * </span>{line}<span style="color: #00d3d0;">"</span>)
</pre>
</div>

<p>
Furthermore, the first input doesn&rsquo;t need to be promoted into a <code>LoggedInt</code>
explicitly anymore, since the transformation functions now receive simple
integers.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #6ae4b9;">logged_result</span> = add(<span style="color: #88ca9f;">6</span>, <span style="color: #88ca9f;">5</span>)  <span style="color: #989898;"># </span><span style="color: #989898;">No explicit call to 'LoggedInt'</span>
<span style="color: #6ae4b9;">logged_result</span> = bind(logged_result, sub, <span style="color: #88ca9f;">4</span>)
<span style="color: #6ae4b9;">logged_result</span> = bind(logged_result, mul, <span style="color: #88ca9f;">3</span>)
<span style="color: #989898;"># </span><span style="color: #989898;">...</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-making-the-writer-a-monad" class="outline-3">
<h3 id="making-the-writer-a-monad"><span class="section-number-3">3.4.</span> Making the writer a monad</h3>
<div class="outline-text-3" id="text-making-the-writer-a-monad">
<p>
In order to turn the writer code into a monad, there is one last change that
needs to be made. The current <code>bind</code> function receives 3 arguments, the last one
being a simple integer because it&rsquo;s what the arithmetic functions expect. The
<code>bind</code> function of a proper monad should only receive 2 arguments: a value, whose
type is <i>monadic</i> (e.g. <code>LoggedInt</code>), and a transformation function, which receives
a simple value (e.g. an integer) and returns a new monadic value.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">bind</span>(old_logged_int, function): <span style="color: #989898;"># </span><span style="color: #989898;">Receives two arguments</span>
    <span style="color: #6ae4b9;">unwrapped_val</span> = old_logged_int.val
    <span style="color: #6ae4b9;">new_logged_int</span> = function(unwrapped_val)  <span style="color: #989898;"># </span><span style="color: #989898;">Called with one argument</span>
    <span style="color: #ff6f9f;">return</span> LoggedInt(
        new_logged_int.val,
        old_logged_int.logs + new_logged_int.logs
    )
</pre>
</div>

<p>
After this change, how could the new <code>bind</code> function receive the arithmetic
functions, if they receive two arguments, <code>a</code> and <code>b</code>? This problem has an easy
solution, although it&rsquo;s not particularly pretty depending on the programming
language. All functions can be converted into one-argument functions by
returning a lambda. For example, the following two function calls are
equivalent.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #989898;"># </span><span style="color: #989898;">Define a function that receives integers 'a', 'b' and 'c', and returns an</span>
<span style="color: #989898;"># </span><span style="color: #989898;">integer with the result.</span>
<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">foo</span>(a, b, c):
    <span style="color: #ff6f9f;">return</span> a + b * c

<span style="color: #989898;"># </span><span style="color: #989898;">Define a function that receives an integer 'a', and returns an anonymous</span>
<span style="color: #989898;"># </span><span style="color: #989898;">function that receives an integer 'b', and returns and anonymous function that</span>
<span style="color: #989898;"># </span><span style="color: #989898;">receives an integer 'c' and returns an integer with the result.</span>
<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">bar</span>(a):
    <span style="color: #ff6f9f;">return</span> <span style="color: #ff6f9f;">lambda</span> b: <span style="color: #ff6f9f;">lambda</span> c: a + b * c

<span style="color: #989898;"># </span><span style="color: #989898;">Example calls.</span>
foo(<span style="color: #88ca9f;">5</span>, <span style="color: #88ca9f;">6</span>, <span style="color: #88ca9f;">7</span>)
bar(<span style="color: #88ca9f;">5</span>)(<span style="color: #88ca9f;">6</span>)(<span style="color: #88ca9f;">7</span>)
</pre>
</div>

<p>
Therefore, the arithmetic functions themselves don&rsquo;t need to be modified, since
the following expressions would be equivalent:
</p>

<div class="org-src-container">
<pre class="src src-python">add(<span style="color: #88ca9f;">5</span>, <span style="color: #88ca9f;">6</span>)

<span style="color: #989898;"># </span><span style="color: #989898;">Equivalent one argument function.</span>
<span style="color: #6ae4b9;">add_six</span> = <span style="color: #ff6f9f;">lambda</span> a: add(a, <span style="color: #88ca9f;">6</span>)
add_six(<span style="color: #88ca9f;">5</span>)
</pre>
</div>

<p>
This is how the bind functions would be called to match the previous example.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #6ae4b9;">logged_result</span> = add(<span style="color: #88ca9f;">6</span>, <span style="color: #88ca9f;">5</span>)
<span style="color: #6ae4b9;">logged_result</span> = bind(logged_result, <span style="color: #ff6f9f;">lambda</span> a: sub(a, <span style="color: #88ca9f;">4</span>))
<span style="color: #6ae4b9;">logged_result</span> = bind(logged_result, <span style="color: #ff6f9f;">lambda</span> a: mul(a, <span style="color: #88ca9f;">3</span>))
<span style="color: #6ae4b9;">logged_result</span> = bind(logged_result, <span style="color: #ff6f9f;">lambda</span> a: div(a, <span style="color: #88ca9f;">2</span>))
</pre>
</div>

<p>
Furthermore, using an object-oriented approach, the <code>bind</code> function can be
converted to a method of <code>LoggedInt</code>, allowing the caller to bind functions with a
cleaner notation, since it now accesses the instance of the object.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #ff6f9f;">class</span> <span style="color: #79a8ff;">LoggedInt</span>:
    <span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">__init__</span>(<span style="color: #ff6f9f;">self</span>, val, logs):  <span style="color: #989898;"># </span><span style="color: #989898;">Unchanged</span>
        <span style="color: #ff6f9f;">self</span>.<span style="color: #6ae4b9;">val</span> = val
        <span style="color: #ff6f9f;">self</span>.<span style="color: #6ae4b9;">logs</span> = logs

    <span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">bind</span>(<span style="color: #ff6f9f;">self</span>, function):
        <span style="color: #6ae4b9;">new_logged_int</span> = function(<span style="color: #ff6f9f;">self</span>.val)
        <span style="color: #ff6f9f;">return</span> LoggedInt(
            new_logged_int.val,
            <span style="color: #ff6f9f;">self</span>.logs + new_logged_int.logs
        )

<span style="color: #989898;"># </span><span style="color: #989898;">Example usage.</span>
<span style="color: #6ae4b9;">logged_result</span> = (
    add(<span style="color: #88ca9f;">6</span>, <span style="color: #88ca9f;">5</span>).bind(<span style="color: #ff6f9f;">lambda</span> a: sub(a, <span style="color: #88ca9f;">4</span>))
             .bind(<span style="color: #ff6f9f;">lambda</span> a: mul(a, <span style="color: #88ca9f;">3</span>))
             .bind(<span style="color: #ff6f9f;">lambda</span> a: div(a, <span style="color: #88ca9f;">2</span>))
)
</pre>
</div>
</div>
</div>

<div id="outline-container-final-code" class="outline-3">
<h3 id="final-code"><span class="section-number-3">3.5.</span> Final code</h3>
<div class="outline-text-3" id="text-final-code">
<p>
This is the final python code for the <i>writer</i> monad.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #989898;"># </span><span style="color: #989898;">Monadic type, expands a base integer type to add logging functionality.</span>
<span style="color: #ff6f9f;">class</span> <span style="color: #79a8ff;">LoggedInt</span>:
    <span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">__init__</span>(<span style="color: #ff6f9f;">self</span>, val, logs):
        <span style="color: #ff6f9f;">self</span>.<span style="color: #6ae4b9;">val</span> = val
        <span style="color: #ff6f9f;">self</span>.<span style="color: #6ae4b9;">logs</span> = logs

    <span style="color: #989898;"># </span><span style="color: #989898;">Applies a one-argument transformation function to the current instance,</span>
    <span style="color: #989898;"># </span><span style="color: #989898;">and combines the result with the existing log list.</span>
    <span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">bind</span>(<span style="color: #ff6f9f;">self</span>, function):
        <span style="color: #6ae4b9;">new_logged_int</span> = function(<span style="color: #ff6f9f;">self</span>.val)
        <span style="color: #ff6f9f;">return</span> LoggedInt(
            new_logged_int.val,
            <span style="color: #ff6f9f;">self</span>.logs + new_logged_int.logs
        )

<span style="color: #989898;"># </span><span style="color: #989898;">Transformation functions.</span>
<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">add</span>(a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(a + b, [f<span style="color: #00d3d0;">"Added </span>{a}<span style="color: #00d3d0;"> to </span>{b}<span style="color: #00d3d0;">"</span>])
<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">sub</span>(a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(a - b, [f<span style="color: #00d3d0;">"Subtracted </span>{a}<span style="color: #00d3d0;"> from </span>{b}<span style="color: #00d3d0;">"</span>])
<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">mul</span>(a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(a * b, [f<span style="color: #00d3d0;">"Multiplied </span>{a}<span style="color: #00d3d0;"> to </span>{b}<span style="color: #00d3d0;">"</span>])
<span style="color: #ff6f9f;">def</span> <span style="color: #4ae2ff;">div</span>(a, b):
    <span style="color: #ff6f9f;">return</span> LoggedInt(a / b, [f<span style="color: #00d3d0;">"Divided </span>{a}<span style="color: #00d3d0;"> by </span>{b}<span style="color: #00d3d0;">"</span>])

<span style="color: #989898;"># </span><span style="color: #989898;">Example usage.</span>
<span style="color: #6ae4b9;">logged_result</span> = (
    add(<span style="color: #88ca9f;">6</span>, <span style="color: #88ca9f;">5</span>).bind(<span style="color: #ff6f9f;">lambda</span> a: sub(a, <span style="color: #88ca9f;">4</span>))
             .bind(<span style="color: #ff6f9f;">lambda</span> a: mul(a, <span style="color: #88ca9f;">3</span>))
             .bind(<span style="color: #ff6f9f;">lambda</span> a: div(a, <span style="color: #88ca9f;">2</span>))
)

<span style="color: #feacd0;">print</span>(f<span style="color: #00d3d0;">"Final result: </span>{logged_result.val}<span style="color: #00d3d0;">"</span>)
<span style="color: #feacd0;">print</span>(<span style="color: #00d3d0;">"Logs:"</span>)
<span style="color: #ff6f9f;">for</span> line <span style="color: #ff6f9f;">in</span> logged_result.logs:
    <span style="color: #feacd0;">print</span>(f<span style="color: #00d3d0;">"  * </span>{line}<span style="color: #00d3d0;">"</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">On lower-level
programming languages, like C, one might argue that string-manipulation
functions are not actually pure, since they often receive a pointer whose value
might change across calls. I decided to still categorize the <code>count_uppercase</code>
function as pure, in higher-level programming languages, since it produces the
same results when given the same <i>string</i> inputs.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">For example, if the length of the same string is
calculated multiple times, and the string doesn&rsquo;t change, the
compiler/interpreter could perform a single call and reuse that value</p></div></div>


</div>
</div></div>
</body>
</html>
