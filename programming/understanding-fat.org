#+TITLE: Understanding the FAT file system
#+AUTHOR: 8dcc
#+STARTUP: nofold
#+HTML_HEAD: <link rel="icon" type="image/x-icon" href="../img/favicon.png">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css">
#+HTML_LINK_UP: index.html
#+HTML_LINK_HOME: ../index.html

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

The FAT file system was originally developed by Microsoft for the MS-DOS
operating system. I have been working on a [[https://github.com/8dcc/dump-fat][FAT parsing tool]] for some days, and I
wanted to explain some of the things I have learned.

Although I will try to cover all FAT filesystems, note that I currently have
experience with FAT12, which is used in floppy disks; if I work on newer FAT
versions in the future, I will update this article with any relevant
information. The exFAT filesystem is not covered in this article.

The following figure shows the general layout of a FAT12/FAT16 volume (although
the FAT32 layout is very similar), each of which will be described in detail
below.

#+NAME: fig1
#+CAPTION: General layout of a FAT12/FAT16 volume.
[[file:../img/understanding-fat1.svg]]

Throughout this article I might reference the "FAT specification", that is,
version 1.03 of the "FAT32 File System Specification", which can be found as
[[file:../external/fatgen103.pdf][=fatgen103.pdf=]].

* CHS and LBA notations
:PROPERTIES:
:CUSTOM_ID: chs-and-lba-notations
:END:

When referring to locations of a disk, I will be using one of the following two
notations, so I will describe them briefly.

- Cylinder-Head-Sector (CHS) notation ::

  A group of 3 numbers used to designate the physical location of a block of
  data in a hard disk. The /cylinder/ or /track/ indicates the radial coordinate
  relative to the center of the platter, the /head/ indicates the platter and side
  where the data is, and the /sector/ indicates the angular coordinate relative to
  the platter. The following figure shows these 3 coordinates in a hard disk.

  #+NAME: fig2
  #+CAPTION: Cylinder-Head-Sector representation on a hard disk.
  [[file:../img/understanding-fat2.svg]]

  See also the [[https://en.wikipedia.org/wiki/Cylinder-head-sector][Wikipedia page]].

- Logical Block Addressing (LBA) notation ::

  Single index, starting from 0, used to linearly identify a block of data
  (usually a [[https://en.wikipedia.org/wiki/Disk_sector][sector]], as described in the CHS notation) in a hard disk.

#+begin_comment org
TODO: Perhaps add conversion formulas, although they are easy to find.
#+end_comment

* Boot sector
:PROPERTIES:
:CUSTOM_ID: boot-sector
:END:

The first sector of the FAT volume is the /Boot Sector/. It has a CHS address of
~0/0/1~, which is the same as LBA address 0. The following figure shows the
highlighted hexdump of a FAT12 boot sector, with the different parts that will
be explained below.

#+NAME: fig3
#+CAPTION: Layout of a FAT12 boot sector.
[[file:../img/understanding-fat3.svg]]

#+begin_comment org
TODO: Export to PNG, keep both versions.
#+end_comment

** Initial bytes
:PROPERTIES:
:CUSTOM_ID: initial-bytes
:END:

The first 3 bytes of the sector are a short =jmp= instruction followed by a =nop=
byte, used if the volume is bootable.

The next 8 bytes are the [[https://en.wikipedia.org/wiki/Original_equipment_manufacturer][OEM]] name, padded with spaces (~0x20~). This is usually
the name of the tool that was used to build the file system image
(e.g. =mkfs.fat=).

** Bios Parameter Block (BPB)
:PROPERTIES:
:CUSTOM_ID: bios-parameter-block-bpb
:END:

After the OEM name, it comes the [[https://en.wikipedia.org/wiki/BIOS_Parameter_Block][BIOS Parameter Block]] (BPB), a data structure
describing the layout of the volume. The following table describes the contents
of the base BPB, common in all FAT filesystems.

#+CAPTION: Layout of the Bios Parameter Block for DOS 3.31.
| BPB Offset | Type     | Description                               |
|------------+----------+-------------------------------------------|
| ~0x00~       | ~uint16_t~ | Bytes per logical sector                  |
| ~0x02~       | ~uint8_t~  | Logical sectors per cluster               |
| ~0x03~       | ~uint16_t~ | Reserved logical sectors                  |
| ~0x05~       | ~uint8_t~  | Number of FATs                            |
| ~0x06~       | ~uint16_t~ | Root directory entries                    |
| ~0x08~       | ~uint16_t~ | Total logical sectors                     |
| ~0x0A~       | ~uint8_t~  | Media descriptor                          |
| ~0x0B~       | ~uint16_t~ | Logical sectors per FAT                   |
| ~0x0D~       | ~uint16_t~ | Physical sectors per track                |
| ~0x0F~       | ~uint16_t~ | Number of heads                           |
| ~0x11~       | ~uint32_t~ | Hidden sectors                            |
| ~0x15~       | ~uint32_t~ | Large total logical sectors               |

FAT filesystems extend this structure with different fields, but the final
structure is usually called /Extended BIOS Parameter Block/ (EBPB).

#+begin_comment org
TODO: Determining the FAT type.
#+end_comment

The following table describes the extra fields used in FAT12 and FAT16 volumes.

#+CAPTION: Layout of the Extended BPB for DOS 4.0, used in FAT12 and FAT16.
| BPB Offset | Type     | Description                               |
|------------+----------+-------------------------------------------|
| ~0x19~       | ~uint8_t~  | Physical drive number                     |
| ~0x1A~       | ~uint8_t~  | Reserved                                  |
| ~0x1B~       | ~uint8_t~  | Extended boot signature (~0x29~, see below) |
| ~0x1C~       | ~uint32_t~ | Volume serial number                      |
| ~0x20~       | ~char[11]~ | Volume label (padded with spaces)         |
| ~0x2B~       | ~char[8]~  | File-system type (padded with spaces)     |

And the following table describes the extra fields used in FAT12 volumes.

#+CAPTION: Layout of the Extended BPB for DOS 4.0, used in FAT12 and FAT16.
| BPB Offset | Type     | Description                           |
|------------+----------+---------------------------------------|
| ~0x19~       | ~uint32_t~ | Logical sectors per FAT               |
| ~0x1D~       | ~uint16_t~ | Mirroring flags etc.                  |
| ~0x1F~       | ~uint16_t~ | Version                               |
| ~0x21~       | ~uint32_t~ | Root directory cluster                |
| ~0x25~       | ~uint16_t~ | Location of FSInfo sector             |
| ~0x27~       | ~uint16_t~ | Location of backup sector(s)          |
| ~0x29~       | ~char[12]~ | Reserved                              |
| ~0x35~       | ~uint8_t~  | Physical drive number                 |
| ~0x36~       | ~uint8_t~  | Reserved                              |
| ~0x37~       | ~uint8_t~  | Extended boot signature (~0x29~)        |
| ~0x38~       | ~uint32_t~ | Volume serial number                  |
| ~0x3C~       | ~char[11]~ | Volume label (padded with spaces)     |
| ~0x47~       | ~char[8]~  | File-system type (padded with spaces) |

Note that, in both the FAT12/FAT16 and FAT32 versions, the value of the /Extended
boot signature/ field should be ~0x29~ to indicate that there are 3 fields left,
since a value of ~0x28~ indicates that there is only one field left, the /Volume
serial number/. Originally, byte ~0x28~ was used to indicate that the volume was
using the DOS 3.4 EBPB, while byte ~0x29~ indicated the EBPB for DOS 4.0 version.

** Bootable code and magic value
:PROPERTIES:
:CUSTOM_ID: bootable-code-and-magic-value
:END:

The remainder of the sector can be used to store executable instructions, so the
first [[*Initial bytes][=jmp= instruction]] can jump to them on boot.

The bytes at offset 510 and 511 should be ~0x55~ and ~0xAA~, respectively, to
indicate the BIOS that the sector is bootable. Note that this magic value might
be written as ~0x55AA~ or ~0xAA55~ depending on the machine's [[https://en.wikipedia.org/wiki/Endianness][endianness]], but the
BIOS will expect byte ~0x55~ first, followed by ~0xAA~, so it's better to write them
separately to avoid confusion.

These two bytes are usually the last ones of the first sector, since the /Bytes
per logical sector/ field of the BPB structure is usually 512, but they don't
necessarily have to be. The BIOS will check the bytes at offset 510 and 511, not
the end of the sector.

* FSInfo sector (FAT32 only)
:PROPERTIES:
:CUSTOM_ID: fsinfo-sector-fat32-only
:END:

This data structure is specific to FAT32, so I haven't used it at this point,
but I will still mention it. It's usually located in the second sector (sector
1), but this is determined by the /Location of FSInfo sector/ field of the FAT32
EBPB.

The FSInfo data structure contains, among some hard-coded signatures, the last
known number of free sectors in the volume and the cluster number where the
driver should start looking for free clusters. This information is not strictly
necessary, but it helps with performance, since the 32-bit FAT can be quite
large.

For now, you might want to check the [[https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#FS_Information_Sector][Wikipedia section]], and pages 21-22 of the
FAT32 specification.

* File Allocation Table (FAT)
:PROPERTIES:
:CUSTOM_ID: file-allocation-table-fat
:END:

The next important data structure is the /File Allocation Table/ itself. There may
be more than one FAT, depending on the fourth field of the BPB, but the first
FAT is always located right after the reserved sectors (such as the boot
sector). We can obtain the number of reserved sectors from the third field of
the BPB, and we can obtain the FAT offset in bytes by multiplying the /Reserved
logical sectors/ and /Bytes per logical sector/ fields of the BPB.

** The purpose of the FAT
:PROPERTIES:
:CUSTOM_ID: the-purpose-of-the-fat
:END:

The FAT is an array of entries that are used to defined a [[https://en.wikipedia.org/wiki/Linked_list][linked list]] of the
clusters that form the contents of a file. This definition might be a bit
overwhelming, so lets focus on some of these terms first.

A /cluster/ is simply a fixed-size group of contiguous sectors. The number of
sectors that form a cluster can be obtained from the second field of the
BPB. For example, if each cluster is 4 sectors (according to the second field),
and each sector is 512 bytes (according to the first field), a cluster would use
2048 contiguous bytes.

The meaning of the term /file/ can vary depending on the context and the level of
abstraction, but I will use it to talk about a data structure that contains
information (i.e. [[https://en.wikipedia.org/wiki/Metadata][metadata]]) about its contents (i.e. an arbitrary amount of
data/bytes). A file structure, which will take the name =DirectoryEntry= below,
contains information such as the filename, the size of the data in bytes, or the
creation and access dates.

While this file metadata is stored in some place that will be discussed below,
the actual contents of the file are stored in one or more clusters (not
necessarily adjacent to each other) in the /data region/ (located after the root
directory, as shown in [[fig1][Figure 1]]). For example, if each cluster is 2KiB and we
wanted to store an 11KiB file, the FAT would need to somehow build a 6-element
list that kept track of the sectors that store this file's data (the last one
won't be full, but still "owned" by this file).

#+begin_comment org
TODO: Figure of the previous example, dividing a file into 5.5 blocks:

X Y X X
Y X X X
#+end_comment

Given a specific cluster index, there would need to be some way of retrieving
the index of the next cluster on its list. To accomplish this, each cluster in
the volume is assigned an entry in the FAT sequentially, so the first cluster
would be assigned to the entry 0 of the FAT (this is not entirely accurate, as
explained below). Each entry in the FAT will then contain the cluster index of
its next element, or a special marker to indicate the end of the linked list (a
value bigger or equal than ~0xFF8~).

For example, if the contents of a file were stored in clusters 0, 3 and 5, the
first entry of the FAT will contain the number 3, the fourth entry would contain
the number 5, and the sixth entry would contain an /end-of-chain/ indicator such
as ~0xFFFF~.

Therefore, the FAT can be used to keep track of the clusters that store the
contents of files, by building linked lists with their cluster indexes.

** The layout of the FAT
:PROPERTIES:
:CUSTOM_ID: the-layout-of-the-fat
:END:

The size of each FAT entry changes depending on the filesystem version, and that
is precisely what the 12/16/32 number indicates: the size of a FAT entry in
bits. The 16-bit version will be used for explaining the layout of the FAT,
since each entry is two bytes, and therefore easier to understand. The 12-bit
version, which uses one bit and a half (i.e. 3 [[https://en.wikipedia.org/wiki/Nibble][nibbles]]), is a bit more tricky,
so it will be explained in detail below.

The following figure shows the hexdump of the first 64 bytes of a 16-bit
FAT. Each (non-empty) entry has been highlighted to show their linked
list. Please note that the offsets in the previous figure are expressed in
bytes, but the FAT stores the linked lists with indexes to other 16-bit entries.

#+NAME: fig4
#+CAPTION: Layout of a 16-bit File Allocation Table.
[[file:../img/understanding-fat4.png]]


#+begin_comment org
TODO: Mention endianness, always little-endian.
#+end_comment

The first two entries of the FAT are reserved, the first one usually being the
/FAT ID/, and the second usually being the /end-of-chain/ marker. Therefore, the
first data cluster would correspond to the third entry of the FAT, not the first
one. Since the linked lists themselves are built using "absolute" indexes in the
FAT, the real cluster indexes can be calculated by subtracting 2 from the value
stored in the FAT.

For example, in the previous figure, entry 4 of the FAT contains the value 5, so
the real index of the next cluster in the list would be 3, since it's the fourth
actual cluster in the volume.

* COMMENT Root directory

https://en.wikipedia.org/wiki/8.3_filename
