#+TITLE: Understanding the FAT file system
#+AUTHOR: 8dcc
#+STARTUP: nofold
#+HTML_HEAD: <link rel="icon" type="image/x-icon" href="../img/favicon.png">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css">
#+HTML_LINK_UP: index.html
#+HTML_LINK_HOME: ../index.html

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

The FAT file system was originally developed by Microsoft for the MS-DOS
operating system. I have been working on a [[https://github.com/8dcc/dump-fat][FAT parsing tool]] for some days, and I
wanted to explain some of the things I have learned.

Although I will try to cover all FAT filesystems, note that I currently have
experience with FAT12, which is used in floppy disks; if I work on newer FAT
versions in the future, I will update this article with any relevant
information. The exFAT filesystem is not covered in this article.

The following figure shows the general layout of a FAT12/FAT16 volume (although
the FAT32 layout is very similar), each of which will be described in detail
below.

#+NAME: fig1
#+CAPTION: General layout of a FAT12/FAT16 volume.
[[file:../img/understanding-fat1.svg]]

Throughout this article I might reference the "FAT specification", that is,
version 1.03 of the "FAT32 File System Specification", which can be found as
[[file:../external/fatgen103.pdf][=fatgen103.pdf=]].

* CHS and LBA notations
:PROPERTIES:
:CUSTOM_ID: chs-and-lba-notations
:END:

When referring to locations of a disk, I will be using one of the following two
notations, so I will describe them briefly.

- Cylinder-Head-Sector (CHS) notation ::

  A group of 3 numbers used to designate the physical location of a block of
  data in a hard disk. The /cylinder/ or /track/ indicates the radial coordinate
  relative to the center of the platter, the /head/ indicates the platter and side
  where the data is, and the /sector/ indicates the angular coordinate relative to
  the platter. The following figure shows these 3 coordinates in a hard disk.

  #+NAME: fig2
  #+CAPTION: Cylinder-Head-Sector representation on a hard disk.
  [[file:../img/understanding-fat2.svg]]

  See also the [[https://en.wikipedia.org/wiki/Cylinder-head-sector][Wikipedia page]] for Cylinder-Head-Sector, where that image is
  from.

- Logical Block Addressing (LBA) notation ::

  Single index, starting from 0, used to linearly identify a block of data
  (usually a [[https://en.wikipedia.org/wiki/Disk_sector][sector]], as described in the CHS notation) in a hard disk.

#+begin_comment org
TODO: Perhaps add conversion formulas, although they are easy to find.
#+end_comment

* Boot sector
:PROPERTIES:
:CUSTOM_ID: boot-sector
:END:

The first sector of the FAT volume is the /Boot Sector/. It has a CHS address of
~0/0/1~, which is the same as LBA address 0. The following figure[fn::Some
diagrams in this article have been exported as PNG because some browsers didn't
display the text highlighting correctly. The SVG version, which can be edited
using [[https://app.diagrams.net/][draw.io]], is also available, just change the file extension from =.png= to
=.svg=.] shows the highlighted hexdump of a FAT12 boot sector, with the different
parts that will be explained below.

#+NAME: fig3
#+CAPTION: Layout of a FAT12 boot sector.
[[file:../img/understanding-fat3.png]]

#+begin_comment org
TODO: Export to PNG, keep both versions.
#+end_comment

** Initial bytes
:PROPERTIES:
:CUSTOM_ID: initial-bytes
:END:

The first 3 bytes of the sector are a short =jmp= instruction followed by a =nop=
byte, used if the volume is bootable.

The next 8 bytes are the [[https://en.wikipedia.org/wiki/Original_equipment_manufacturer][OEM]] name, padded with spaces (~0x20~). This is usually
the name of the tool that was used to build the file system image
(e.g. =mkfs.fat=).

** Bios Parameter Block (BPB)
:PROPERTIES:
:CUSTOM_ID: bios-parameter-block-bpb
:END:

After the OEM name, it comes the [[https://en.wikipedia.org/wiki/BIOS_Parameter_Block][BIOS Parameter Block]] (BPB), a data structure
describing the layout of the volume. The following table describes the contents
of the base BPB, common in all FAT filesystems.

#+CAPTION: Layout of the Bios Parameter Block for DOS 3.31.
| BPB Offset | Type     | Description                               |
|------------+----------+-------------------------------------------|
| ~0x00~       | ~uint16_t~ | Bytes per logical sector                  |
| ~0x02~       | ~uint8_t~  | Logical sectors per cluster               |
| ~0x03~       | ~uint16_t~ | Reserved logical sectors                  |
| ~0x05~       | ~uint8_t~  | Number of FATs                            |
| ~0x06~       | ~uint16_t~ | Root directory entries                    |
| ~0x08~       | ~uint16_t~ | Total logical sectors                     |
| ~0x0A~       | ~uint8_t~  | Media descriptor                          |
| ~0x0B~       | ~uint16_t~ | Logical sectors per FAT                   |
| ~0x0D~       | ~uint16_t~ | Physical sectors per track                |
| ~0x0F~       | ~uint16_t~ | Number of heads                           |
| ~0x11~       | ~uint32_t~ | Hidden sectors                            |
| ~0x15~       | ~uint32_t~ | Large total logical sectors               |

FAT filesystems extend this structure with different fields, but the final
structure is usually called /Extended BIOS Parameter Block/ (EBPB). Please note
that the term "BPB" will be used when refering to the base structure from the
first table, which is shared by all filesystem versions, while the term "EBPB"
will be used when refering to one of the other two tables and its contents.

#+begin_comment org
TODO: Determining the FAT type.
#+end_comment

The following table describes the extra fields used in FAT12 and FAT16 volumes.

#+CAPTION: Layout of the Extended BPB for DOS 4.0, used in FAT12 and FAT16.
| BPB Offset | Type     | Description                               |
|------------+----------+-------------------------------------------|
| ~0x19~       | ~uint8_t~  | Physical drive number                     |
| ~0x1A~       | ~uint8_t~  | Reserved                                  |
| ~0x1B~       | ~uint8_t~  | Extended boot signature (~0x29~, see below) |
| ~0x1C~       | ~uint32_t~ | Volume serial number                      |
| ~0x20~       | ~char[11]~ | Volume label (padded with spaces)         |
| ~0x2B~       | ~char[8]~  | File-system type (padded with spaces)     |

And the following table describes the extra fields used in FAT12 volumes.

#+CAPTION: Layout of the Extended BPB for DOS 4.0, used in FAT12 and FAT16.
| BPB Offset | Type     | Description                           |
|------------+----------+---------------------------------------|
| ~0x19~       | ~uint32_t~ | Logical sectors per FAT               |
| ~0x1D~       | ~uint16_t~ | Mirroring flags etc.                  |
| ~0x1F~       | ~uint16_t~ | Version                               |
| ~0x21~       | ~uint32_t~ | Root directory cluster                |
| ~0x25~       | ~uint16_t~ | Location of FSInfo sector             |
| ~0x27~       | ~uint16_t~ | Location of backup sector(s)          |
| ~0x29~       | ~char[12]~ | Reserved                              |
| ~0x35~       | ~uint8_t~  | Physical drive number                 |
| ~0x36~       | ~uint8_t~  | Reserved                              |
| ~0x37~       | ~uint8_t~  | Extended boot signature (~0x29~)        |
| ~0x38~       | ~uint32_t~ | Volume serial number                  |
| ~0x3C~       | ~char[11]~ | Volume label (padded with spaces)     |
| ~0x47~       | ~char[8]~  | File-system type (padded with spaces) |

Note that, in both the FAT12/FAT16 and FAT32 versions, the value of the /Extended
boot signature/ field should be ~0x29~ to indicate that there are 3 fields left,
since a value of ~0x28~ indicates that there is only one field left, the /Volume
serial number/. Originally, byte ~0x28~ was used to indicate that the volume was
using the DOS 3.4 EBPB, while byte ~0x29~ indicated the EBPB for DOS 4.0 version.

** Bootable code and magic value
:PROPERTIES:
:CUSTOM_ID: bootable-code-and-magic-value
:END:

The remainder of the sector can be used to store executable instructions, so the
first [[*Initial bytes][=jmp= instruction]] can jump to them on boot.

The bytes at offset 510 and 511 should be ~0x55~ and ~0xAA~, respectively, to
indicate the BIOS that the sector is bootable. Note that this magic value might
be written as ~0x55AA~ or ~0xAA55~ depending on the machine's [[https://en.wikipedia.org/wiki/Endianness][endianness]], but the
BIOS will expect byte ~0x55~ first, followed by ~0xAA~, so it's better to write them
separately to avoid confusion.

These two bytes are usually the last ones of the first sector, since the /Bytes
per logical sector/ field of the BPB structure is usually 512, but they don't
necessarily have to be. The BIOS will check the bytes at offset 510 and 511, not
the end of the sector.

* FSInfo sector (FAT32 only)
:PROPERTIES:
:CUSTOM_ID: fsinfo-sector-fat32-only
:END:

This data structure is specific to FAT32, so I haven't used it at this point,
but I will still mention it. It's usually located in the second sector (sector
1), but this is determined by the /Location of FSInfo sector/ field of the FAT32
EBPB.

The FSInfo data structure contains, among some hard-coded signatures, the last
known number of free sectors in the volume and the cluster number where the
driver should start looking for free clusters. This information is not strictly
necessary, but it helps with performance, since the 32-bit FAT can be quite
large.

For now, you might want to check the [[https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#FS_Information_Sector][Wikipedia section]], and pages 21-22 of the
FAT32 specification.

* File Allocation Table (FAT)
:PROPERTIES:
:CUSTOM_ID: file-allocation-table-fat
:END:

The next important data structure is the /File Allocation Table/ itself. There may
be more than one FAT, depending on the fourth field of the BPB, but the first
FAT is always located right after the reserved sectors (such as the boot
sector). We can obtain the number of reserved sectors from the third field of
the BPB, and we can obtain the FAT offset in bytes by multiplying the /Reserved
logical sectors/ and /Bytes per logical sector/ fields of the BPB.

** The purpose of the FAT
:PROPERTIES:
:CUSTOM_ID: the-purpose-of-the-fat
:END:

The FAT is an array of numbers that is used to define [[https://en.wikipedia.org/wiki/Linked_list][linked lists]] of the
clusters that form the contents of a file. This definition might be a bit
overwhelming, so lets focus on some of these terms first.

A /cluster/ is simply a fixed-size group of contiguous sectors. The number of
sectors that form a cluster can be obtained from the second field of the
BPB. For example, if each cluster is 4 sectors (according to the second field),
and each sector is 512 bytes (according to the first field), a cluster would use
2048 contiguous bytes.

The meaning of the term /file/ can vary depending on the context and the level of
abstraction, but I will use it to talk about a data structure that contains
information (i.e. [[https://en.wikipedia.org/wiki/Metadata][metadata]]) about its contents (i.e. an arbitrary amount of
data/bytes). A file structure, which will take the name =DirectoryEntry= below,
contains information such as the filename, the size of the data in bytes, and
the creation and access dates.

While this file metadata is stored in some place that will be discussed below,
the actual contents of the file are stored in one or more clusters (not
necessarily adjacent to each other) in the /data region/ (which is located after
the root directory, as shown in [[fig1][Figure 1]]). For example, if each cluster is 2KiB
and we wanted to store an 11KiB file, we would need to somehow build a 6-element
list that kept track of the sectors that store that file's data (the last one
won't be full, but still "owned" by this file).

#+NAME: fig4
#+CAPTION: File contents stored in 6 non-adjacent clusters.
[[file:../img/understanding-fat4.svg]]

Given a specific cluster index, there would need to be a way of retrieving the
index of the next cluster on its list. To accomplish this, each cluster in the
volume is assigned an entry in the FAT sequentially, so the first cluster would
be assigned to entry 0 of the FAT, the second element to entry 1, and so on
(this is not entirely accurate, as explained below). Each entry in the FAT will
then contain the cluster index of its /next/ element, or a special marker to
indicate the end of the linked list[fn::For FAT12, this /end-of-chain/ marker is
any value greater or equal than ~0xFF8~; for FAT16, any value greater or equal
than ~0xFFF8~; and for FAT32, any value greater or equal than ~0xFFFFFFF8~.].

For example, in order to build the cluster list represented in the previous
figure, the following pseudo-code could be used, assuming the =fat= variable is an
array of 16-bit unsigned integers.

#+NAME: example1
#+begin_example
fat[0] = 2;      /* Cluster 1 is skipped */
fat[2] = 3;
fat[3] = 4;
fat[4] = 5;
fat[5] = 7;      /* Cluster 6 is skipped */
fat[7] = 0xFFFF; /* Mark end of chain */
#+end_example

As shown below, this is not entirely accurate, since the first data cluster is
not mapped to the first element of the FAT. Either way, the FAT is used to keep
track of the clusters that store the contents of files, by building linked lists
with their cluster indexes.

** The layout of the FAT
:PROPERTIES:
:CUSTOM_ID: the-layout-of-the-fat
:END:

The size of each FAT entry changes depending on the filesystem version, and that
is precisely what the 12/16/32 number indicates: the size of a FAT entry in
bits. The 16-bit version will be used for explaining the layout of the FAT,
since each entry is two bytes, and therefore easier to understand. The 12-bit
version, which uses one bit and a half (i.e. 3 [[https://en.wikipedia.org/wiki/Nibble][nibbles]]), is a bit more tricky,
so it will be explained in detail below.

The following figure shows the hexdump of the first 64 bytes of a 16-bit
FAT. Each (non-empty) entry has been highlighted to show their linked
list. Please note that the offsets in the previous figure are expressed in
bytes, but the FAT stores the linked lists with indexes to other 16-bit entries.

#+NAME: fig5
#+CAPTION: Layout of a 16-bit File Allocation Table.
[[file:../img/understanding-fat5.png]]

The first thing that should be noted about the FAT, and about the filesystem in
general, is that it's /strictly little-endian/, meaning that the least-significant
bytes are stored at a smaller offset in the disk (i.e. the value ~0xAABBCCDD~
would be stored as ~DD CC BB AA~). The previous figure shows a hexdump, and
although the bytes are grouped in pairs, they are dumped one by one, in the
order in which they are stored in the disk. For example, the contents of the
third 16-bit entry are displayed as ~0300~, but actually corresponds to the value
~0x0003~. This will be specially important later when describing the layout of a
12-bit FAT, since each entry is one byte and a half.

The first two entries of the FAT are reserved, the first one usually being the
/FAT ID/, and the second usually being the value used as the /end-of-chain/
marker. Therefore, the first data cluster would correspond to the third entry of
the FAT, not the first one. Since the linked lists themselves are built using
"absolute" indexes in the FAT, the real cluster indexes can be calculated by
subtracting 2 from the value stored in the FAT. For example, in the previous
figure, entry 4 of the FAT contains the value 5, so the real index of the next
cluster in the list would be 3, since it's the fourth actual cluster in the
volume.

#+begin_comment org
TODO: At this point of the article, some concepts haven't been shown yet, so
this whole list might be better in another section.
#+end_comment

This is the general algorithm for reading the contents of a file:

1. Somehow obtain the *first FAT index* for the file (this will be explained
   below). Note that this index won't be the cluster index in the volume
   (i.e. the subtraction is not yet made).
2. Calculate the *cluster index* by subtracting 2 (i.e. the number of reserved FAT
   entries) from the FAT index.
3. Calculate the *sector number* by multiplying the cluster index by the number of
   /Logical sectors per cluster/ (second element of the BPB), and adding that to
   the number of sectors before the /Data region/ (obtaining this value will be
   shown below as well).
4. Somehow read the cluster from the disk, starting at that sector.
5. Obtain the *next FAT index* by reading the value stored at the FAT entry
   corresponding to the current FAT index (i.e. ~fat_idx = fat[fat_idx]~). Again,
   note that this step might be more complicated depending on the endianness of
   the machine.
6. If the new FAT index is smaller than the /end-of-chain/ marker, go back to
   step 2. Otherwise, we are done with the file.

* COMMENT Root directory

https://en.wikipedia.org/wiki/8.3_filename
