<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The pros and cons of Cons</title>
<meta property="og:title" content="The pros and cons of Cons" />
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../css/main.css">
</head>
<body>
<div id="org-div-home-and-up">
  <a accesskey="u" href="index.html">Up</a> | <a accesskey="h" href="../index.html">Home</a>
</div><div id="content" class="content">
<h1 class="title">The pros and cons of Cons</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#introduction">1. Introduction</a>
<ul>
<li><a href="#cons-cells">1.1. Cons cells</a></li>
<li><a href="#lists-and-syntactic-sugar">1.2. Lists and syntactic sugar</a></li>
</ul>
</li>
<li><a href="#the-initial-approach">2. The initial approach</a>
<ul>
<li><a href="#a-basic-expr-structure">2.1. A basic <code>Expr</code> structure</a></li>
<li><a href="#combining-expressions-with-linked-lists">2.2. Combining expressions with linked lists</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-introduction" class="outline-2">
<h2 id="introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
This article is about the advantages and disadvantages of using <i>cons cells</i> in
the <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> programming language.
</p>

<p>
I have been working on a <a href="https://github.com/8dcc/sl">simple Lisp interpreter</a> for some months now, and I have
learned many things from my mistakes. I recently changed how lists are
internally stored in my interpreter, and I wanted to explain why I decided to
use my old approach in the beginning, and why I decided to eventually change.
</p>
</div>

<div id="outline-container-cons-cells" class="outline-3">
<h3 id="cons-cells"><span class="section-number-3">1.1.</span> Cons cells</h3>
<div class="outline-text-3" id="text-cons-cells">
<p>
If you are familiar with Lisp languages, you probably know what cons cells are,
but I will still give a brief explanation.
</p>

<p>
The term &ldquo;cons&rdquo; is a bit ambiguous in Lisp, because it&rsquo;s commonly used when
talking about a data type, but it&rsquo;s also the name of procedure that creates an
object with that type. Although basically all Lisp dialects have a <code>cons</code>
function, the name used to refer to the data type changes among them: Scheme
calls them <i>pairs</i>, Emacs Lisp calls them <i>cons cells</i>, and Common Lisp simply calls
them <i>cons</i>. In this article, I will use the term &ldquo;cons cell&rdquo; when referring to
the data type to avoid confusion.
</p>

<p>
A cons cell is a Lisp object that simply consists of two pointers to Lisp
objects. For historical reasons, the first pointer is called the <i>CAR</i>, and the
second pointer is called the <i>CDR</i><sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>. These CAR and CDR terms are not only
used when talking about the pointers themselves, but also when talking about the
values that they point to.
</p>


<div id="fig1" class="figure">
<p><img src="../img/cons-of-cons1.svg" alt="cons-of-cons1.svg" class="org-svg" />
</p>
</div>

<p>
These kind of diagrams are called <i>box-and-pointer</i>, <i>box-and-arrow</i>, or simply <i>box
diagrams</i>, and they are very useful for understanding how complex data structures
are stored internally.
</p>

<p>
The procedures for accessing the CAR and the CDR of a cons cell are called <code>car</code>
and <code>cdr</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #ff5f59;">(</span>car <span style="color: #cabf00;">(</span>cons <span style="color: #88ca9f;">10</span> <span style="color: #88ca9f;">20</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
  &#8658; <span style="color: #88ca9f;">10</span>

<span style="color: #ff5f59;">(</span>cdr <span style="color: #cabf00;">(</span>cons <span style="color: #88ca9f;">10</span> <span style="color: #88ca9f;">20</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
  &#8658; <span style="color: #88ca9f;">20</span>
</pre>
</div>

<p>
Finally, I would like to mention <i>dotted pair</i> or <i>cons pair</i> notation. When a dot
is encountered inside of a list (i.e. between parentheses), the interpreter
assumes that the element before the dot is the CAR of the current pair, and the
one after the dot is the CDR.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #ff5f59;">(</span>car '<span style="color: #cabf00;">(</span><span style="color: #88ca9f;">10</span> . <span style="color: #88ca9f;">20</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
  &#8658; <span style="color: #88ca9f;">10</span>

<span style="color: #ff5f59;">(</span>cdr '<span style="color: #cabf00;">(</span><span style="color: #88ca9f;">10</span> . <span style="color: #88ca9f;">20</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
  &#8658; <span style="color: #88ca9f;">20</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-lists-and-syntactic-sugar" class="outline-3">
<h3 id="lists-and-syntactic-sugar"><span class="section-number-3">1.2.</span> Lists and syntactic sugar</h3>
<div class="outline-text-3" id="text-lists-and-syntactic-sugar">
<p>
When people mention <i>lists</i> in the Lisp context, they are usually talking about
something that looks like:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #ff5f59;">(</span>a b <span style="color: #88ca9f;">1</span> <span style="color: #88ca9f;">2</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
These are called <i>proper lists</i>, but it&rsquo;s important to understand that (usually)
the lists are internally stored as <i>chained cons cells</i>, and that the previous
notation is just syntactic sugar for:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #ff5f59;">(</span>a . <span style="color: #cabf00;">(</span>b . <span style="color: #44bc44;">(</span><span style="color: #88ca9f;">1</span> . <span style="color: #00eff0;">(</span><span style="color: #88ca9f;">2</span> . nil<span style="color: #00eff0;">)</span><span style="color: #44bc44;">)</span><span style="color: #cabf00;">)</span><span style="color: #ff5f59;">)</span>
</pre>
</div>

<p>
As you can see, each element of our list is stored in the CAR of a cons cell,
and the CDR points to another cons cell which contains the next element. The CDR
of the inner-most cons cell is the symbol <code>nil</code>, used to terminate
lists<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> Although not all Lisp dialects use the
symbol <code>nil</code>, there is always a unique value used to terminate proper lists. In
box diagrams, a crossed box is used to represent this terminator.
</p>


<div id="fig2" class="figure">
<p><img src="../img/cons-of-cons2.svg" alt="cons-of-cons2.svg" class="org-svg" />
</p>
</div>

<p>
Let me emphasize that there is no &ldquo;list type&rdquo;, it&rsquo;s just a data structure that
is built out of cons cells.
</p>
</div>
</div>
</div>

<div id="outline-container-the-initial-approach" class="outline-2">
<h2 id="the-initial-approach"><span class="section-number-2">2.</span> The initial approach</h2>
<div class="outline-text-2" id="text-the-initial-approach">
<p>
Now that we know how lists are conventionally represented in Lisps, let&rsquo;s have a
look at an alternative implementation.
</p>

<p>
One of the books that inspired me to write a Lisp was <a href="https://www.buildyourownlisp.com/">Build Your Own Lisp</a> by
Daniel Holden. The author doesn&rsquo;t use the cons cell approach described above,
and although I didn&rsquo;t follow the book, at first glance it didn&rsquo;t seem like a bad
idea.
</p>
</div>

<div id="outline-container-a-basic-expr-structure" class="outline-3">
<h3 id="a-basic-expr-structure"><span class="section-number-3">2.1.</span> A basic <code>Expr</code> structure</h3>
<div class="outline-text-3" id="text-a-basic-expr-structure">
<p>
First, let&rsquo;s have a look at how a very basic Lisp expression would look like
from C, using a <i>tagged union</i>:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">enum</span> <span style="color: #79a8ff;">EExprType</span> {
    <span style="color: #6ae4b9;">EXPR_INTEGER</span>,
    <span style="color: #6ae4b9;">EXPR_FLOAT</span>,
    <span style="color: #6ae4b9;">EXPR_SYMBOL</span>,
};

<span style="color: #ff6f9f;">typedef</span> <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">Expr</span> {
    <span style="color: #ff6f9f;">enum</span> <span style="color: #79a8ff;">EExprType</span> <span style="color: #6ae4b9;">type</span>;

    <span style="color: #ff6f9f;">union</span> {
        <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">n</span>;
        <span style="color: #79a8ff;">float</span> <span style="color: #6ae4b9;">f</span>;
        <span style="color: #79a8ff;">char</span>* <span style="color: #6ae4b9;">s</span>;
    } <span style="color: #6ae4b9;">val</span>;
} <span style="color: #79a8ff;">Expr</span>;
</pre>
</div>

<p>
I will not spend too much time explaining why tagged unions are useful, since it
is not the scope of this article, but in case you are not familiar with them,
just know that they generally have a lower memory impact, and that we could
access the appropriate value of an expression by checking its <code>type</code> member:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">int</span> <span style="color: #4ae2ff;">f</span>(<span style="color: #79a8ff;">Expr</span>* <span style="color: #6ae4b9;">expr</span>) {
    <span style="color: #ff6f9f;">switch</span> (expr-&gt;type) {
        <span style="color: #ff6f9f;">case</span> EXPR_INTEGER: <span style="color: #ff6f9f;">return</span> expr-&gt;val.n;
        <span style="color: #ff6f9f;">case</span> EXPR_FLOAT:   <span style="color: #ff6f9f;">return</span> (<span style="color: #79a8ff;">int</span>)expr-&gt;val.f;
        <span style="color: #ff6f9f;">case</span> EXPR_SYMBOL:  <span style="color: #ff6f9f;">return</span> strlen(expr-&gt;val.s);
        <span style="color: #ff6f9f;">default</span>:           abort(); <span style="color: #989898;">/* </span><span style="color: #989898;">???</span><span style="color: #989898;"> */</span>
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-combining-expressions-with-linked-lists" class="outline-3">
<h3 id="combining-expressions-with-linked-lists"><span class="section-number-3">2.2.</span> Combining expressions with linked lists</h3>
<div class="outline-text-3" id="text-combining-expressions-with-linked-lists">
<p>
Now let&rsquo;s have a look at how we could combine simple expressions into more
complex structures using <i>linked lists</i>. The premise of a linked list is that each
object in the list contains a pointer to the next one, therefore allowing the
programmer to link objects that are not adjacent in memory (unlike simple
arrays). The following diagram shows the memory layout when using a linked list
of 3 elements.
</p>


<div id="fig3" class="figure">
<p><img src="../img/cons-of-cons3.svg" alt="cons-of-cons3.svg" class="org-svg" />
</p>
</div>

<p>
We could use this linked list method for joining an arbitrary number of
expressions together. Also note that the lists themselves (just like the cons
cells in conventional implementations) are expressions, so we would need to add
a new expression type whose value is a pointer to the start of a linked list of
expressions. This is how the new <code>Expr</code> structure would look like after adding
the necessary members:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">enum</span> <span style="color: #79a8ff;">EExprType</span> {
    <span style="color: #989898;">/* </span><span style="color: #989898;">...</span><span style="color: #989898;"> */</span>
    <span style="color: #6ae4b9;">EXPR_LIST</span>,
};

<span style="color: #ff6f9f;">typedef</span> <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">Expr</span> {
    <span style="color: #ff6f9f;">enum</span> <span style="color: #79a8ff;">EExprType</span> <span style="color: #6ae4b9;">type</span>;

    <span style="color: #ff6f9f;">union</span> {
        <span style="color: #989898;">/* </span><span style="color: #989898;">...</span><span style="color: #989898;"> */</span>
        <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">Expr</span>* <span style="color: #6ae4b9;">children</span>;
    } <span style="color: #6ae4b9;">val</span>;

    <span style="color: #ff6f9f;">struct</span> <span style="color: #79a8ff;">Expr</span>* <span style="color: #6ae4b9;">next</span>;
} <span style="color: #79a8ff;">Expr</span>;
</pre>
</div>

<p>
Notice how <code>children</code> is a member of the union, but <code>next</code> is a member of the <code>Expr</code>
structure, so the size of each expression just increased by <code>sizeof(Expr*)</code>, not
by <code>2 * sizeof(Expr*)</code>.
</p>

<p>
The following code shows how we would manually create the list <code>(a b 1 2)</code> from C,
assuming we defined some <code>expr_new</code> function for allocating an expression with the
specified type, and assuming we can safely store string literals in our
expression<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">Expr</span>* <span style="color: #6ae4b9;">list</span> = expr_new(EXPR_LIST);
list-&gt;next = <span style="color: #88ca9f;">NULL</span>;

list-&gt;val.children = expr_new(EXPR_SYMBOL);
list-&gt;val.children-&gt;val.s = <span style="color: #00d3d0;">"a"</span>;

list-&gt;val.children-&gt;next = expr_new(EXPR_SYMBOL);
list-&gt;val.children-&gt;next-&gt;val.s = <span style="color: #00d3d0;">"b"</span>;

list-&gt;val.children-&gt;next-&gt;next = expr_new(EXPR_INTEGER);
list-&gt;val.children-&gt;next-&gt;next-&gt;val.s = <span style="color: #88ca9f;">1</span>;

list-&gt;val.children-&gt;next-&gt;next-&gt;next = expr_new(EXPR_INTEGER);
list-&gt;val.children-&gt;next-&gt;next-&gt;next-&gt;val.s = <span style="color: #88ca9f;">2</span>;

<span style="color: #989898;">/* </span><span style="color: #989898;">Terminate the linked list</span><span style="color: #989898;"> */</span>
list-&gt;val.children-&gt;next-&gt;next-&gt;next-&gt;next = <span style="color: #88ca9f;">NULL</span>;
</pre>
</div>

<p>
And the following diagram shows how it would be stored in memory with our new
structure.
</p>


<div id="fig4" class="figure">
<p><img src="../img/cons-of-cons4.svg" alt="cons-of-cons4.svg" class="org-svg" />
</p>
</div>

<p>
As you can see, each expression has a <code>next</code> member, so it will be <i>implicitly</i> in a
list, even if it&rsquo;s isolated like the first expression. This has some important
consequences that will be explained below.
</p>

<p>
Before getting into the advantages and disadvantages of the implementation, I
would like to note that the author of the book I mentioned probably chose this
approach to deliberately explain how linked lists work (since the book is also
meant for people learning C).
</p>

<p>
I would also like to mention that Clojure, a Lisp dialect<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>, uses a similar linked list approach through <i>sequences</i>, as described
in <a href="https://insideclojure.org/2015/01/02/sequences/">this article</a>. And indeed, this can be seen in the Java source code where the
<a href="https://github.com/clojure/clojure/blob/fb22fd778a272b034684a4ee94509552b46ee8a9/src/jvm/clojure/lang/Cons.java#L21-L27">Cons class</a> is defined.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Since Lisp was originally implemented on
the IBM 704 computer, CAR stood for <i>Contents of the Address part of the
Register</i>, and CDR stood for <i>Contents of the Decrement part of the Register</i>. See
<a href="https://www-formal.stanford.edu/jmc/history/lisp/lisp.html">John McCarthy, History of Lisp (1979)</a>.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Generally, <code>nil</code> is a pretty special symbol: It is considered both a
symbol and a list (although it&rsquo;s not considered a cons cell according to Common
Lisp&rsquo;s <code>consp</code> or Scheme&rsquo;s <code>pair?</code>), it usually evaluates to itself, and in many
dialects both <code>(car nil)</code> and <code>(cdr nil)</code> evaluate to <code>nil</code>. It is also often used to
denote <i>false</i> in boolean operations.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">This is naturally a big assumption, one that doesn&rsquo;t even match
our previous definition of <code>Expr</code>, since string literals are read-only and we are
storing them in a non-constant <code>char*</code>. We would probably need to use some
function that allocates the string on the heap, like <a href="https://man.cx/strdup(3)"><code>strdup(3)</code></a>. Again, I
omited this for making the code slightly more readable.</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Although Richard
Stallman doesn&rsquo;t agree with this statement, precisely because there aren&rsquo;t
proper cons cells in Clojure. See <a href="https://stallman.org/stallman-computing.html">How I do my computing</a>, retreived in February
of 2025.</p></div></div>


</div>
</div></div>
</body>
</html>
