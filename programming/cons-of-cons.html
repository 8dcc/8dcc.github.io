<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The pros and cons of Cons</title>
<meta property="og:title" content="The pros and cons of Cons" />
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../css/main.css">
</head>
<body>
<div id="org-div-home-and-up">
  <a accesskey="u" href="index.html">Up</a> | <a accesskey="h" href="../index.html">Home</a>
</div><div id="content" class="content">
<h1 class="title">The pros and cons of Cons</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#introduction">1. Introduction</a>
<ul>
<li><a href="#cons-cells">1.1. Cons cells</a></li>
<li><a href="#lists-and-syntactic-sugar">1.2. Lists and syntactic sugar</a></li>
</ul>
</li>
<li><a href="#the-initial-approach">2. The initial approach</a>
<ul>
<li><a href="#a-basic-expr-structure">2.1. A basic <code>Expr</code> structure</a></li>
<li><a href="#combining-expressions-with-linked-lists">2.2. Combining expressions with linked lists</a></li>
</ul>
</li>
<li><a href="#the-conventional-cons-cell-approach">3. The conventional cons cell approach</a></li>
<li><a href="#comparing-the-two-methods">4. Comparing the two methods</a>
<ul>
<li><a href="#disadvantage-memory-impact">4.1. Disadvantage: Memory impact</a></li>
<li><a href="#advantage-improper-lists">4.2. Advantage: Improper lists</a></li>
<li><a href="#advantage-context-independence-reusing-references">4.3. Advantage: Context independence, reusing references</a></li>
<li><a href="#advantage-consistent-nil">4.4. Advantage: Consistent <code>nil</code></a></li>
<li><a href="#advantage-no-list-wrappers">4.5. Advantage: No list wrappers</a></li>
<li><a href="#advantage-lisp-like-c-code">4.6. Advantage: Lisp-like C code</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-introduction" class="outline-2">
<h2 id="introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
This article is about the advantages and disadvantages of using <i>cons cells</i> when
implementing a <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>-like programming language.
</p>

<p>
I have been working on a <a href="https://github.com/8dcc/sl">simple Lisp interpreter</a> for some months now, and I have
learned many things from my mistakes. I recently changed how lists are
internally stored in my interpreter, and I wanted to explain why I decided to
use my old approach in the beginning, and why I decided to eventually change
into a more conventional cons cell approach.
</p>

<p>
Throughout this article I will use the Lisp syntax from my interpreter, but the
examples can be run in most Lisp dialects with some minor modifications. Just
keep in mind that, unlike in Lisp<sub>2</sub> dialects (e.g. Common Lisp), there isn&rsquo;t a
separate namespace for functions, so you won&rsquo;t see <code>funcall</code>.
</p>

<p>
First of all, I would like to credit <a href="https://turtleware.eu/">Daniel Kochma≈Ñski</a> for his help some months
ago, and for linking me this <a href="https://www.xach.com/naggum/articles/3092837184154309@naggum.no.html">email by Erik Naggum</a>, which you might find useful.
</p>
</div>

<div id="outline-container-cons-cells" class="outline-3">
<h3 id="cons-cells"><span class="section-number-3">1.1.</span> Cons cells</h3>
<div class="outline-text-3" id="text-cons-cells">
<p>
If you are familiar with Lisp languages, you probably know what cons cells are,
but I will still give a brief explanation.
</p>

<p>
The term &ldquo;cons&rdquo; is a bit ambiguous in Lisp, because it&rsquo;s commonly used when
talking about a data type, but it&rsquo;s also the name of a procedure that creates an
object of that type. Although basically all Lisp dialects have a <code>cons</code> function,
the name used to refer to the data type changes among them: Scheme calls them
<i>pairs</i>, Emacs Lisp calls them <i>cons cells</i>, and Common Lisp simply calls them
<i>cons</i>. In this article, I will use the term &ldquo;cons cell&rdquo; when referring to the
data type to avoid confusion.
</p>

<p>
A cons cell is a Lisp object that simply points to another two to Lisp
objects. For historical reasons, the first pointer is called the <i>CAR</i>, and the
second pointer is called the <i>CDR</i><sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>. These CAR and CDR terms are not only
used when talking about the pointers themselves, but also when talking about the
values that they point to.
</p>


<div id="fig1" class="figure">
<p><img src="../img/cons-of-cons1.svg" alt="cons-of-cons1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 1: </span>Box diagram of a cons cell.</p>
</div>

<p>
These kinds of diagrams are called <i>box-and-pointer</i>, <i>box-and-arrow</i>, or simply <i>box
diagrams</i>, and they are very useful for understanding how complex data structures
are stored internally.
</p>

<p>
The procedures for accessing the CAR and the CDR of a cons cell are called <code>car</code>
and <code>cdr</code>. There are also wrappers for combining them, so <code>(caddr x)</code> would return
the <code>car</code> of the <code>cdr</code> of the <code>cdr</code> of <code>x</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #a60000;">(</span>car <span style="color: #695500;">(</span>cons <span style="color: #2a5045;">10</span> <span style="color: #2a5045;">20</span><span style="color: #695500;">)</span><span style="color: #a60000;">)</span>
  &#8658; <span style="color: #2a5045;">10</span>

<span style="color: #a60000;">(</span>cdr <span style="color: #695500;">(</span>cons <span style="color: #2a5045;">10</span> <span style="color: #2a5045;">20</span><span style="color: #695500;">)</span><span style="color: #a60000;">)</span>
  &#8658; <span style="color: #2a5045;">20</span>
</pre>
</div>

<p>
Finally, I would like to mention <i>dotted pair</i> or <i>cons pair</i> notation. When a dot
is encountered inside a list (i.e. between parentheses), the interpreter assumes
that the element before the dot is the CAR of the current pair, and the one
after the dot is the CDR.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #a60000;">(</span>car '<span style="color: #695500;">(</span><span style="color: #2a5045;">10</span> . <span style="color: #2a5045;">20</span><span style="color: #695500;">)</span><span style="color: #a60000;">)</span>
  &#8658; <span style="color: #2a5045;">10</span>

<span style="color: #a60000;">(</span>cdr '<span style="color: #695500;">(</span><span style="color: #2a5045;">10</span> . <span style="color: #2a5045;">20</span><span style="color: #695500;">)</span><span style="color: #a60000;">)</span>
  &#8658; <span style="color: #2a5045;">20</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-lists-and-syntactic-sugar" class="outline-3">
<h3 id="lists-and-syntactic-sugar"><span class="section-number-3">1.2.</span> Lists and syntactic sugar</h3>
<div class="outline-text-3" id="text-lists-and-syntactic-sugar">
<p>
When people mention <i>lists</i> in the context of Lisp, they are usually talking about
something that looks like:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #a60000;">(</span>a b <span style="color: #2a5045;">1</span> <span style="color: #2a5045;">2</span><span style="color: #a60000;">)</span>
</pre>
</div>

<p>
These are called <i>proper lists</i>, but it&rsquo;s important to understand that (usually)
the lists are internally stored as <i>chained cons cells</i>, and that the previous
notation is just syntactic sugar for:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #a60000;">(</span>a . <span style="color: #695500;">(</span>b . <span style="color: #006800;">(</span><span style="color: #2a5045;">1</span> . <span style="color: #008899;">(</span><span style="color: #2a5045;">2</span> . nil<span style="color: #008899;">)</span><span style="color: #006800;">)</span><span style="color: #695500;">)</span><span style="color: #a60000;">)</span>
</pre>
</div>

<p>
As you can see, each element of our list is stored in the CAR of a cons cell,
and the CDR points to another cons cell which contains the next element. The CDR
of the innermost cons cell is the symbol <code>nil</code>, used to terminate
lists<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>. Although not all Lisp dialects use the
symbol <code>nil</code>, there is always a unique value used to terminate proper lists. In
box diagrams, a crossed box is used to represent this terminator.
</p>


<div id="fig2" class="figure">
<p><img src="../img/cons-of-cons2.svg" alt="cons-of-cons2.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 2: </span>Box diagram of a proper list.</p>
</div>

<p>
Let me emphasize that there is no &ldquo;list type&rdquo;, it&rsquo;s just a data structure that
is built out of cons cells.
</p>
</div>
</div>
</div>

<div id="outline-container-the-initial-approach" class="outline-2">
<h2 id="the-initial-approach"><span class="section-number-2">2.</span> The initial approach</h2>
<div class="outline-text-2" id="text-the-initial-approach">
<p>
Now that we know how lists are conventionally represented in Lisps, let&rsquo;s have a
look at an alternative implementation.
</p>

<p>
One of the books that inspired me to write a Lisp interpreter was <a href="https://www.buildyourownlisp.com/">Build Your Own
Lisp</a> by Daniel Holden. The author doesn&rsquo;t use the cons cell approach described
above, and although I didn&rsquo;t follow the book, at first glance it didn&rsquo;t seem
like a bad idea. This article tries to precisely show its advantages and
limitations when compared to the traditional approach explained above.
</p>
</div>

<div id="outline-container-a-basic-expr-structure" class="outline-3">
<h3 id="a-basic-expr-structure"><span class="section-number-3">2.1.</span> A basic <code>Expr</code> structure</h3>
<div class="outline-text-3" id="text-a-basic-expr-structure">
<p>
First, let&rsquo;s have a look at how a very basic Lisp expression would look like
from C, using a <i>tagged union</i>.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #972500;">enum</span> <span style="color: #0031a9;">EExprType</span> {
    <span style="color: #005f5f;">EXPR_INTEGER</span>,
    <span style="color: #005f5f;">EXPR_FLOAT</span>,
    <span style="color: #005f5f;">EXPR_SYMBOL</span>,
};

<span style="color: #972500;">typedef</span> <span style="color: #972500;">struct</span> <span style="color: #0031a9;">Expr</span> {
    <span style="color: #972500;">enum</span> <span style="color: #0031a9;">EExprType</span> <span style="color: #005f5f;">type</span>;

    <span style="color: #972500;">union</span> {
        <span style="color: #0031a9;">int</span> <span style="color: #005f5f;">n</span>;
        <span style="color: #0031a9;">float</span> <span style="color: #005f5f;">f</span>;
        <span style="color: #0031a9;">char</span>* <span style="color: #005f5f;">s</span>;
    } <span style="color: #005f5f;">val</span>;
} <span style="color: #0031a9;">Expr</span>;
</pre>
</div>

<p>
I will not spend too much time explaining why tagged unions are useful, since it
is not the scope of this article, but in case you are not familiar with them,
just know that they generally have a lower memory impact, and that we could
access the appropriate value of an expression by first checking its <code>type</code> member.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #0031a9;">int</span> <span style="color: #3f578f;">f</span>(<span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">expr</span>) {
    <span style="color: #972500;">switch</span> (expr-&gt;type) {
        <span style="color: #972500;">case</span> EXPR_INTEGER: <span style="color: #972500;">return</span> expr-&gt;val.n;
        <span style="color: #972500;">case</span> EXPR_FLOAT:   <span style="color: #972500;">return</span> (<span style="color: #0031a9;">int</span>)expr-&gt;val.f;
        <span style="color: #972500;">case</span> EXPR_SYMBOL:  <span style="color: #972500;">return</span> strlen(expr-&gt;val.s);
        <span style="color: #972500;">default</span>:           abort(); <span style="color: #595959;">/* </span><span style="color: #595959;">???</span><span style="color: #595959;"> */</span>
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-combining-expressions-with-linked-lists" class="outline-3">
<h3 id="combining-expressions-with-linked-lists"><span class="section-number-3">2.2.</span> Combining expressions with linked lists</h3>
<div class="outline-text-3" id="text-combining-expressions-with-linked-lists">
<p>
Now let&rsquo;s have a look at how we could combine simple expressions into more
complex structures using <i>linked lists</i>. The premise of a linked list is that each
object in the list contains a pointer to the next one, therefore allowing the
programmer to link objects that are not adjacent in memory, which is a
limitation when using simple arrays.
</p>


<div id="fig3" class="figure">
<p><img src="../img/cons-of-cons3.svg" alt="cons-of-cons3.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 3: </span>Memory layout of a generic linked list of 3 elements.</p>
</div>

<p>
We could use this linked list method for joining an arbitrary number of
expressions together. Keep in mind that the lists themselves (just like the cons
cells in conventional implementations) are expressions, so we would need to add
a new expression type whose value is a pointer to the start of a linked list of
expressions. The following code shows how the new <code>Expr</code> structure would look like
after adding the necessary members.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #972500;">enum</span> <span style="color: #0031a9;">EExprType</span> {
    <span style="color: #595959;">/* </span><span style="color: #595959;">...</span><span style="color: #595959;"> */</span>
    <span style="color: #005f5f;">EXPR_LIST</span>,
};

<span style="color: #972500;">typedef</span> <span style="color: #972500;">struct</span> <span style="color: #0031a9;">Expr</span> {
    <span style="color: #972500;">enum</span> <span style="color: #0031a9;">EExprType</span> <span style="color: #005f5f;">type</span>;

    <span style="color: #972500;">union</span> {
        <span style="color: #595959;">/* </span><span style="color: #595959;">...</span><span style="color: #595959;"> */</span>
        <span style="color: #972500;">struct</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">children</span>;
    } <span style="color: #005f5f;">val</span>;

    <span style="color: #972500;">struct</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">next</span>;
} <span style="color: #0031a9;">Expr</span>;
</pre>
</div>

<p>
Notice how <code>children</code> is a member of the union, but <code>next</code> is a member of the <code>Expr</code>
structure, so the size of each expression just increased by <code>sizeof(Expr*)</code>, not
by <code>2 * sizeof(Expr*)</code>.
</p>

<p>
The following code shows how we would manually create the list <code>(a b 1 2)</code> from C,
assuming that there is some <code>expr_new</code> function that allocates an expression with
the specified type. For readability, we will also assume that we can safely
store string literals in our expressions<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #972500;">extern</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #3f578f;">expr_new</span>(<span style="color: #972500;">enum</span> <span style="color: #0031a9;">EExprType</span> <span style="color: #005f5f;">type</span>);

<span style="color: #0031a9;">Expr</span>* <span style="color: #3f578f;">get_list</span>(<span style="color: #0031a9;">void</span>) {
    <span style="color: #595959;">/* </span><span style="color: #595959;">Create the list itself</span><span style="color: #595959;"> */</span>
    <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">list</span> = expr_new(EXPR_LIST);
    list-&gt;next = <span style="color: #2a5045;">NULL</span>;

    <span style="color: #595959;">/* </span><span style="color: #595959;">Write each element</span><span style="color: #595959;"> */</span>
    <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">elt</span>          = expr_new(EXPR_SYMBOL);
    list-&gt;val.children = elt;
    elt-&gt;val.s         = <span style="color: #005e8b;">"a"</span>;

    elt-&gt;next  = expr_new(EXPR_SYMBOL);
    elt        = elt-&gt;next;
    elt-&gt;val.s = <span style="color: #005e8b;">"b"</span>;

    elt-&gt;next  = expr_new(EXPR_INTEGER);
    elt        = elt-&gt;next;
    elt-&gt;val.n = <span style="color: #2a5045;">1</span>;

    elt-&gt;next  = expr_new(EXPR_INTEGER);
    elt        = elt-&gt;next;
    elt-&gt;val.n = <span style="color: #2a5045;">2</span>;

    <span style="color: #595959;">/* </span><span style="color: #595959;">Terminate the linked list</span><span style="color: #595959;"> */</span>
    elt-&gt;next = <span style="color: #2a5045;">NULL</span>;

    <span style="color: #972500;">return</span> list;
}
</pre>
</div>

<p>
The following diagram shows how the list would be stored in memory with our new
structure.
</p>


<div id="fig4" class="figure">
<p><img src="../img/cons-of-cons4.svg" alt="cons-of-cons4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 4: </span>Layout of a list of 4 expressions, using the linked list approach.</p>
</div>

<p>
As you can see, each expression has a <code>next</code> member, so they will always be
<i>implicitly</i> in a list, even if an expression isolated like the first one. This
has some important consequences that will be explained <a href="#advantage-context-independence-reusing-references">below</a>.
</p>

<p>
The following code shows how we would iterate each expression of a list; in this
case for adding some integers together.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #0031a9;">int</span> <span style="color: #3f578f;">sum</span>(<span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">list</span>) {
    assert(list-&gt;type == EXPR_LIST);

    <span style="color: #0031a9;">int</span> <span style="color: #005f5f;">total</span> = <span style="color: #2a5045;">0</span>;
    <span style="color: #972500;">for</span> (<span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">e</span> = list-&gt;val.children; e != <span style="color: #2a5045;">NULL</span>; e = e-&gt;next)
        <span style="color: #972500;">if</span> (e-&gt;type == EXPR_INTEGER)
            total += e-&gt;val.n;

    <span style="color: #972500;">return</span> total;
}
</pre>
</div>

<p>
Before getting into the advantages and disadvantages of the implementation, I
would like to note that the author of the book I mentioned probably chose this
approach to deliberately explain how linked lists work, since the book is also
meant for people learning C.
</p>

<p>
I would also like to mention that Clojure, a Lisp dialect<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>, uses a similar linked list approach through <i>sequences</i>, as described in
<a href="https://insideclojure.org/2015/01/02/sequences/">this article</a>. And indeed, this can be seen in the Java source code where the
<a href="https://github.com/clojure/clojure/blob/fb22fd778a272b034684a4ee94509552b46ee8a9/src/jvm/clojure/lang/Cons.java#L21-L27">Cons class</a> is defined.
</p>
</div>
</div>
</div>

<div id="outline-container-the-conventional-cons-cell-approach" class="outline-2">
<h2 id="the-conventional-cons-cell-approach"><span class="section-number-2">3.</span> The conventional cons cell approach</h2>
<div class="outline-text-2" id="text-the-conventional-cons-cell-approach">
<p>
Now that we had a look at how to combine expressions with a linked list, let&rsquo;s
go back to the cons cell approach that is used in most Lisps. Instead of adding
&ldquo;list&rdquo; expressions to our implementation, we will simply add a &ldquo;pair&rdquo; type that
contains the CAR and CDR pointers, and we will chain them to build lists.
</p>

<p>
The following code shows how we could extend our basic <code>Expr</code> structure from <a href="#a-basic-expr-structure">above</a>
to include pairs.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #972500;">enum</span> <span style="color: #0031a9;">EExprType</span> {
    <span style="color: #595959;">/* </span><span style="color: #595959;">...</span><span style="color: #595959;"> */</span>
    <span style="color: #005f5f;">EXPR_PAIR</span>,
};

<span style="color: #972500;">typedef</span> <span style="color: #972500;">struct</span> <span style="color: #0031a9;">ExprPair</span> {
    <span style="color: #972500;">struct</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">car</span>;
    <span style="color: #972500;">struct</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">cdr</span>;
} <span style="color: #0031a9;">ExprPair</span>;

<span style="color: #972500;">typedef</span> <span style="color: #972500;">struct</span> <span style="color: #0031a9;">Expr</span> {
    <span style="color: #972500;">enum</span> <span style="color: #0031a9;">EExprType</span> <span style="color: #005f5f;">type</span>;

    <span style="color: #972500;">union</span> {
        <span style="color: #595959;">/* </span><span style="color: #595959;">...</span><span style="color: #595959;"> */</span>
        <span style="color: #972500;">struct</span> <span style="color: #0031a9;">ExprPair</span> <span style="color: #005f5f;">pair</span>;
    } <span style="color: #005f5f;">val</span>;
} <span style="color: #0031a9;">Expr</span>;
</pre>
</div>

<p>
There are some details I would like to note from the previous code. First,
notice how the <code>Expr</code> structure doesn&rsquo;t have a <code>next</code> member anymore, so expressions
are <i>not</i> in an &ldquo;implicit&rdquo; list. Second, notice how the <code>pair</code> union member is an
<code>ExprPair</code> structure, not a <i>pointer</i> to that structure; this is because the pair
structure is very small, so there is no need to allocate it separately.
</p>

<p>
We (potentially<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>) increased the size of the
union by <code>sizeof(expr.val.pair.cdr)</code>, but also decreased the size of the structure
by <code>sizeof(expr.next)</code>, so the size of an individual expression was not negatively
impacted by this change.
</p>

<p>
The following code is equivalent to the one shown in the previous section for
creating the list <code>(a b 1 2)</code>. We assume that there is some <code>NIL</code> expression that is
used to uniquely identify a list terminator, but we could set the last CDR
pointer to <code>NULL</code> instead.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #972500;">extern</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #3f578f;">expr_new</span>(<span style="color: #972500;">enum</span> <span style="color: #0031a9;">EExprType</span> <span style="color: #005f5f;">type</span>);
<span style="color: #972500;">extern</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">NIL</span>;

<span style="color: #0031a9;">Expr</span>* <span style="color: #3f578f;">get_list</span>(<span style="color: #0031a9;">void</span>) {
    <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">first</span>              = expr_new(EXPR_PAIR);
    <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">cur</span>                = first;
    cur-&gt;val.pair.car        = expr_new(EXPR_SYMBOL); <span style="color: #595959;">/* </span><span style="color: #595959;">CADR</span><span style="color: #595959;"> */</span>
    cur-&gt;val.pair.car-&gt;val.s = <span style="color: #005e8b;">"a"</span>;

    cur-&gt;val.pair.cdr        = expr_new(EXPR_PAIR);
    cur                      = cur-&gt;val.pair.cdr;
    cur-&gt;val.pair.car        = expr_new(EXPR_SYMBOL); <span style="color: #595959;">/* </span><span style="color: #595959;">CADR</span><span style="color: #595959;"> */</span>
    cur-&gt;val.pair.car-&gt;val.s = <span style="color: #005e8b;">"b"</span>;

    cur-&gt;val.pair.cdr        = expr_new(EXPR_PAIR);
    cur                      = cur-&gt;val.pair.cdr;
    cur-&gt;val.pair.car        = expr_new(EXPR_INTEGER); <span style="color: #595959;">/* </span><span style="color: #595959;">CADDR</span><span style="color: #595959;"> */</span>
    cur-&gt;val.pair.car-&gt;val.n = <span style="color: #2a5045;">1</span>;

    cur-&gt;val.pair.cdr        = expr_new(EXPR_PAIR);
    cur                      = cur-&gt;val.pair.cdr;
    cur-&gt;val.pair.car        = expr_new(EXPR_INTEGER); <span style="color: #595959;">/* </span><span style="color: #595959;">CADDDR</span><span style="color: #595959;"> */</span>
    cur-&gt;val.pair.car-&gt;val.n = <span style="color: #2a5045;">2</span>;

    <span style="color: #595959;">/* </span><span style="color: #595959;">Terminate the chain of cons cells</span><span style="color: #595959;"> */</span>
    cur-&gt;val.pair.cdr = NIL;

    <span style="color: #972500;">return</span> first;
}
</pre>
</div>

<p>
The following diagram shows how the list would be stored in memory with our new
structure.
</p>


<div id="fig5" class="figure">
<p><img src="../img/cons-of-cons5.svg" alt="cons-of-cons5.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 5: </span>Layout of a list of 4 expressions, using the cons cell approach.</p>
</div>

<p>
The following code shows how we would iterate over a (proper<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>) list, accessing each element. Since the previous code is
not very readable, I added some <code>CAR</code> and <code>CDR</code> macros for (hopefully) making the
code a bit cleaner.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a0132f;">#define</span> <span style="color: #3f578f;">CAR</span>(<span style="color: #005f5f;">EXPR_PTR</span>) ((EXPR_PTR)-&gt;val.pair.car)
<span style="color: #a0132f;">#define</span> <span style="color: #3f578f;">CDR</span>(<span style="color: #005f5f;">EXPR_PTR</span>) ((EXPR_PTR)-&gt;val.pair.cdr)

<span style="color: #972500;">extern</span> <span style="color: #0031a9;">bool</span> <span style="color: #3f578f;">is_proper_list</span>(<span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">expr</span>);
<span style="color: #972500;">extern</span> <span style="color: #0031a9;">bool</span> <span style="color: #3f578f;">is_nil</span>(<span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">expr</span>);

<span style="color: #0031a9;">int</span> <span style="color: #3f578f;">sum</span>(<span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">list</span>) {
    assert(is_proper_list(list));

    <span style="color: #0031a9;">int</span> <span style="color: #005f5f;">total</span> = <span style="color: #2a5045;">0</span>;
    <span style="color: #972500;">for</span> (; <span style="color: #972500; font-weight: bold;">!</span>is_nil(list); list = CDR(list))
        <span style="color: #972500;">if</span> (CAR(list) == EXPR_INTEGER)
            total += CAR(list)-&gt;val.n;

    <span style="color: #972500;">return</span> total;
}
</pre>
</div>

<p>
Just like with <code>expr_new</code>, notice how we use two functions that we haven&rsquo;t
defined: <code>is_proper_list</code> and <code>is_nil</code>. It&rsquo;s not necessary to know how these
functions are implemented, or even what <code>nil</code> really is, as long as we have a
reliable way of checking for this unique value. This is called <i>wishful thinking</i>,
and is a key concept from <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">Structure and Interpretation of Computer Programs</a>, a
great book that I truly recommend (not just for Lisp programmers).
</p>
</div>
</div>

<div id="outline-container-comparing-the-two-methods" class="outline-2">
<h2 id="comparing-the-two-methods"><span class="section-number-2">4.</span> Comparing the two methods</h2>
<div class="outline-text-2" id="text-comparing-the-two-methods">
<p>
After considering how the two approaches could be implemented, we can finally
compare them. I will start with the disadvantages of the conventional cons cell
approach when compared with the simple linked list.
</p>
</div>

<div id="outline-container-disadvantage-memory-impact" class="outline-3">
<h3 id="disadvantage-memory-impact"><span class="section-number-3">4.1.</span> Disadvantage: Memory impact</h3>
<div class="outline-text-3" id="text-disadvantage-memory-impact">
<p>
If we compare the memory layouts for the <a href="#fig4">linked list</a> and the <a href="#fig5">cons cell</a>
implementations, we can immediately see that the latter uses more memory for
storing the same list.
</p>

<p>
Specifically, since the linked list approach needed an expression for the list
itself, we would need <code>n+1</code> expressions for building a list of <i>n</i> elements. When
using the cons cell approach, each element of the (proper) list is placed inside
a cons pair, so we would need <code>2n</code> expressions, assuming that we don&rsquo;t need to
allocate a <code>nil</code> expression for every list, since that is not usually the case.
</p>

<p>
Considering this fact, it&rsquo;s easy to conclude that the linked list implementation
is more memory-efficient, and that there is no point in using cons cells. In
that regard, I would like to say that even if the implementation uses cons cells
for building conventional lists, this doesn&rsquo;t prevent us from adding another
more optimized &ldquo;vector&rdquo; or &ldquo;array&rdquo; data structure.
</p>
</div>
</div>

<div id="outline-container-advantage-improper-lists" class="outline-3">
<h3 id="advantage-improper-lists"><span class="section-number-3">4.2.</span> Advantage: Improper lists</h3>
<div class="outline-text-3" id="text-advantage-improper-lists">
<p>
When <a href="#lists-and-syntactic-sugar">describing Lisp lists</a>, I only mentioned <i>proper lists</i>, but in most Lisp
dialects, there are also <i>improper lists</i>. One subtype of improper lists are
<i>dotted lists</i>: lists whose last CDR is not <code>nil</code>. Such a list might be defined with
the dotted pair notation described <a href="#cons-cells">above</a>, or by using <code>cons</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #a60000;">(</span>cdr '<span style="color: #695500;">(</span>a b . c<span style="color: #695500;">)</span><span style="color: #a60000;">)</span>
  &#8658; <span style="color: #a60000;">(</span>b . c<span style="color: #a60000;">)</span>

<span style="color: #a60000;">(</span>cadr '<span style="color: #695500;">(</span>a b . c<span style="color: #695500;">)</span><span style="color: #a60000;">)</span>  <span style="color: #595959;">; (car (cdr ...))</span>
  &#8658; b

<span style="color: #a60000;">(</span>cddr '<span style="color: #695500;">(</span>a b . c<span style="color: #695500;">)</span><span style="color: #a60000;">)</span>  <span style="color: #595959;">; (cdr (cdr ...))</span>
  &#8658; c

<span style="color: #a60000;">(</span>cons 'a <span style="color: #695500;">(</span>cons 'b <span style="color: #006800;">(</span>cons <span style="color: #2a5045;">3</span> <span style="color: #2a5045;">4</span><span style="color: #006800;">)</span><span style="color: #695500;">)</span><span style="color: #a60000;">)</span>
  &#8658; <span style="color: #a60000;">(</span>a b <span style="color: #2a5045;">3</span> . <span style="color: #2a5045;">4</span><span style="color: #a60000;">)</span>
</pre>
</div>

<p>
This data structure is perfectly possible with the cons cell approach, but
impossible when using a linked list, since the possible values of the <code>next</code>
member are either the address of another expression or <code>NULL</code>.
</p>

<p>
I would also like to mention <i>circular lists</i>, another type of improper list. A
circular list <a href="http://clhs.lisp.se/Body/26_glo_c.htm#circular_list">can be defined</a> as &ldquo;a chain of cons cells that has no termination
because some cell in the chain is the CDR of a later cons cell&rdquo;. To be
completely fair, we could still build circular lists with the linked list
approach, since the <code>next</code> member can point to a previous element of the list.
</p>
</div>
</div>

<div id="outline-container-advantage-context-independence-reusing-references" class="outline-3">
<h3 id="advantage-context-independence-reusing-references"><span class="section-number-3">4.3.</span> Advantage: Context independence, reusing references</h3>
<div class="outline-text-3" id="text-advantage-context-independence-reusing-references">
<p>
As mentioned above, when using linked lists, each expression is restricted to
their context, since they always have a <code>next</code> pointer.
</p>

<p>
In the book by Daniel Holden, this isn&rsquo;t a problem because most functions
returned copies, instead of references. Naturally, this is appropriate for his
book, since it would be confusing for new C programmers to implement a more
complex memory-management system like garbage collection.
</p>

<p>
Returning copies is not practical when making a real implementation,
however. Not only does it waste memory and decrease performance (with
unnecessary calls to the allocator), but it also makes some standard Lisp
functions like <code>car</code> and <code>cdr</code> counter-intuitive, since they are supposed to return
references, instead of copies.
</p>

<p>
To further illustrate why the <code>next</code> pointer is a problem, let&rsquo;s look at a
possible implementation of the <code>car</code> primitive. The following function, written
for the linked list implementation, receives an expression of type <code>EXPR_LIST</code> and
is supposed to return its first element.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #0031a9;">Expr</span>* <span style="color: #3f578f;">expr_clone</span>(<span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">e</span>) {
    <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">result</span> = expr_new(e-&gt;type);
    result-&gt;val  = e-&gt;val;
    result-&gt;next = <span style="color: #2a5045;">NULL</span>;
    <span style="color: #972500;">return</span> result;
}

<span style="color: #0031a9;">Expr</span>* <span style="color: #3f578f;">car</span>(<span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">list</span>) {
    <span style="color: #972500;">if</span> (is_nil(list))
        <span style="color: #972500;">return</span> NIL;

    assert(list-&gt;type == EXPR_LIST);
    <span style="color: #972500;">return</span> expr_clone(list-&gt;val.children);
}
</pre>
</div>

<p>
We can&rsquo;t directly return <code>list-&gt;val.children</code> because the first element still has
the rest of the list &ldquo;attached&rdquo; through its <code>next</code> pointer, and we can&rsquo;t set
<code>list-&gt;val.children-&gt;next</code> to <code>NULL</code> to &ldquo;isolate&rdquo; the first element either, because
we would be overwriting the list <code>(a b c)</code> into becoming <code>(a)</code>, and we could even be
leaking memory. Even if we wanted to directly return the reference, we can&rsquo;t do
it without breaking the structure of the list we received, so we are <i>forced</i> to
return a clone.
</p>

<p>
However, with the cons cell approach, this is primitive would be much simpler to
implement, since a list references its contents, but the contents themselves are
completely independent of their context.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #0031a9;">Expr</span>* <span style="color: #3f578f;">car</span>(<span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">expr</span>) {
    <span style="color: #972500;">if</span> (is_nil(expr))
        <span style="color: #972500;">return</span> NIL;

    assert(expr-&gt;type == EXPR_PAIR);
    <span style="color: #972500;">return</span> expr-&gt;val.pair.car;
}
</pre>
</div>

<p>
Keep in mind that, since we are returning a reference, if something overwrites
the value of the expression returned by <code>car</code>, it will also affect the contents of
the cons cell where it&rsquo;s referenced. This behavior is expected in Lisp, and we
could always write another function that returns a copy for this purpose.
</p>

<p>
Although this advantage might not look too significant, it allows us to work
with references, which can potentially save more memory than when using linked
lists, as explained in <a href="#disadvantage-memory-impact">the disadvantage above</a>.
</p>
</div>
</div>

<div id="outline-container-advantage-consistent-nil" class="outline-3">
<h3 id="advantage-consistent-nil"><span class="section-number-3">4.4.</span> Advantage: Consistent <code>nil</code></h3>
<div class="outline-text-3" id="text-advantage-consistent-nil">
<p>
In Lisp, the symbol <code>nil</code> is often used to represent the empty list. The following
quote is taken from the <a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/nil-explained.html">Emacs manual</a>:
</p>

<blockquote>
<p>
In Emacs Lisp, the symbol <code>nil</code> has two meanings. First, it means the empty
list. Second, it means <i>false</i> and is the value returned when a true-or-false-test
tests false. <code>nil</code> can be written as an empty list, <code>()</code>, or as <code>nil</code>. As far as the
Lisp interpreter is concerned, <code>()</code> and <code>nil</code> are the same. Humans, however, tend to
use <code>nil</code> for false and <code>()</code> for the empty list.
</p>
</blockquote>

<p>
When I implemented <code>nil</code> in my interpreter, back when I was using linked lists,
this description seemed very confusing. With my implementation at the time, the
symbol <code>nil</code> and the empty list <code>()</code> were two completely different expressions.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #595959;">/* </span><span style="color: #595959;">Symbol: nil</span><span style="color: #595959;"> */</span>
<span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">sym</span>  = expr_new(EXPR_SYMBOL);
sym-&gt;val.s = <span style="color: #005e8b;">"nil"</span>;

<span style="color: #595959;">/* </span><span style="color: #595959;">Empty list: ()</span><span style="color: #595959;"> */</span>
<span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">list</span>         = expr_new(EXPR_LIST);
list-&gt;val.children = <span style="color: #2a5045;">NULL</span>;
</pre>
</div>

<p>
At the time, the symbol <code>nil</code> was just like any other variable from the global
environment, bound to an empty list. However, in most Lisps, the following are
equivalent:
</p>

<div class="org-src-container">
<pre class="src src-lisp">nil
  &#8658; nil

'nil
  &#8658; nil

<span style="color: #a60000;">()</span>
  &#8658; nil

'<span style="color: #a60000;">()</span>
  &#8658; nil
</pre>
</div>

<p>
This happens because, as explained above, lists are syntactic sugar, so an empty
list is converted to the symbol <code>nil</code> by the parser. This makes many internal
functions more consistent (and efficient), since you don&rsquo;t have to check for
multiple expression types.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #595959;">/* </span><span style="color: #595959;">Old, inconsistent</span><span style="color: #595959;"> */</span>
<span style="color: #0031a9;">bool</span> <span style="color: #3f578f;">is_nil</span>(<span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">e</span>) {
    <span style="color: #972500;">return</span> (e-&gt;type == EXPR_LIST &amp;&amp; e-&gt;val.children == <span style="color: #2a5045;">NULL</span>) ||
           (e-&gt;type == EXPR_SYMBOL &amp;&amp; e-&gt;val.s != <span style="color: #2a5045;">NULL</span> &amp;&amp;
            <span style="color: #972500; font-weight: bold;">!</span>strcmp(e-&gt;val.s, <span style="color: #005e8b;">"nil"</span>));
}
</pre>
</div>

<p>
When using the new approach, <code>nil</code> is a normal symbol that evaluates to itself
(it&rsquo;s simply used as a special indicator), and the empty list <code>()</code> is just
syntactic sugar for it.
</p>
</div>
</div>

<div id="outline-container-advantage-no-list-wrappers" class="outline-3">
<h3 id="advantage-no-list-wrappers"><span class="section-number-3">4.5.</span> Advantage: No list wrappers</h3>
<div class="outline-text-3" id="text-advantage-no-list-wrappers">
<p>
When using linked lists, many wrappers had to be written for internal functions
that operated on individual expressions.
</p>

<p>
For example, assume there is an <code>expr_equal</code> function that checks whether two
expressions have the same value. When an <code>EXPR_LIST</code> is encountered, it would have
to compare each element recursively, ideally using an <code>expr_list_equal</code> wrapper.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #0031a9;">bool</span> <span style="color: #3f578f;">expr_equal</span>(<span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">a</span>, <span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">b</span>) {
    <span style="color: #595959;">/* </span><span style="color: #595959;">...</span><span style="color: #595959;"> */</span>

    <span style="color: #972500;">switch</span> (a-&gt;type) {
        <span style="color: #972500;">case</span> EXPR_LIST:
            <span style="color: #972500;">return</span> expr_list_equal(a, b);

        <span style="color: #595959;">/* </span><span style="color: #595959;">...</span><span style="color: #595959;"> */</span>
    }
}

<span style="color: #0031a9;">bool</span> <span style="color: #3f578f;">expr_list_equal</span>(<span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">a</span>, <span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">b</span>) {
    <span style="color: #595959;">/* </span><span style="color: #595959;">Similar to strcmp(3)</span><span style="color: #595959;"> */</span>
    <span style="color: #972500;">while</span> (expr_equal(a, b)) {
        <span style="color: #972500;">if</span> (a == <span style="color: #2a5045;">NULL</span>)
            <span style="color: #972500;">return</span> <span style="color: #2a5045;">true</span>;

        a = a-&gt;next;
        b = b-&gt;next;
    }

    <span style="color: #972500;">return</span> <span style="color: #2a5045;">false</span>;
}
</pre>
</div>

<p>
This pattern repeated with many internal functions, and many <code>expr_*</code> functions
ended up having a <code>expr_list_*</code> equivalent.
</p>

<p>
When using cons cells, comparing two lists (whether they are proper or not) is
as simple as comparing the CAR and CDR recursively. This is an example of how
cons cells are their own independent expression, and how most operations can be
applied without depending on their context.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #0031a9;">bool</span> <span style="color: #3f578f;">expr_equal</span>(<span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">a</span>, <span style="color: #972500;">const</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">b</span>) {
    <span style="color: #595959;">/* </span><span style="color: #595959;">...</span><span style="color: #595959;"> */</span>

    <span style="color: #972500;">switch</span> (a-&gt;type) {
        <span style="color: #972500;">case</span> EXPR_PAIR:
            <span style="color: #972500;">return</span> expr_equal(CAR(a), CAR(b))
                &amp;&amp; expr_equal(CDR(a), CDR(b));

        <span style="color: #595959;">/* </span><span style="color: #595959;">...</span><span style="color: #595959;"> */</span>
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-advantage-lisp-like-c-code" class="outline-3">
<h3 id="advantage-lisp-like-c-code"><span class="section-number-3">4.6.</span> Advantage: Lisp-like C code</h3>
<div class="outline-text-3" id="text-advantage-lisp-like-c-code">
<p>
Whether we chose to implement lists with one method or the other, the Lisp
programmer should still have access to the usual <code>cons</code>, <code>car</code> and <code>cdr</code>
procedures. By using the cons cell approach, our C code will use a similar
structure to Lisp procedures, even if we decide to define iterative functions,
rather than recursive ones.
</p>

<p>
As an example, look at how the following Lisp procedure is implemented. It is a
recursive <i>procedure</i> that implements an iterative <i>process</i><sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup> using a <a href="https://en.wikipedia.org/wiki/Tail_call">tail
call</a>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #595959;">;; </span><span style="color: #595959;">Does the function F return non-nil for all elements of LST?</span>
<span style="color: #a60000;">(</span><span style="color: #972500;">defun</span> <span style="color: #3f578f;">every</span> <span style="color: #695500;">(</span>f lst<span style="color: #695500;">)</span>
  <span style="color: #695500;">(</span><span style="color: #972500;">cond</span> <span style="color: #006800;">(</span><span style="color: #008899;">(</span>null? lst<span style="color: #008899;">)</span> tru<span style="color: #006800;">)</span>
        <span style="color: #006800;">(</span><span style="color: #008899;">(</span>not <span style="color: #0000ff;">(</span>f <span style="color: #dd22dd;">(</span>car lst<span style="color: #dd22dd;">)</span><span style="color: #0000ff;">)</span><span style="color: #008899;">)</span> nil<span style="color: #006800;">)</span>
        <span style="color: #006800;">(</span>tru <span style="color: #008899;">(</span>every f <span style="color: #0000ff;">(</span>cdr lst<span style="color: #0000ff;">)</span><span style="color: #008899;">)</span><span style="color: #006800;">)</span><span style="color: #695500;">)</span><span style="color: #a60000;">)</span>
</pre>
</div>

<p>
Now compare it to the following iterative implementation as a C primitive.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #972500;">extern</span> <span style="color: #0031a9;">Expr</span>* <span style="color: #3f578f;">funcall</span>(<span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">func</span>, <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">arg</span>);

<span style="color: #0031a9;">bool</span> <span style="color: #3f578f;">every</span>(<span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">f</span>, <span style="color: #0031a9;">Expr</span>* <span style="color: #005f5f;">lst</span>) {
    <span style="color: #972500;">for</span> (; <span style="color: #972500; font-weight: bold;">!</span>is_nil(lst); lst = CDR(lst))
        <span style="color: #972500;">if</span> (is_nil(funcall(f, CAR(lst))))
            <span style="color: #972500;">return</span> <span style="color: #2a5045;">false</span>;

    <span style="color: #972500;">return</span> <span style="color: #2a5045;">true</span>;
}
</pre>
</div>

<p>
This is a small advantage, but I was happy to notice it when I made the change,
so I decided to include it.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Since Lisp was originally implemented on
the IBM 704 computer, CAR stood for <i>Contents of the Address part of the
Register</i>, and CDR stood for <i>Contents of the Decrement part of the Register</i>. See
<a href="https://www-formal.stanford.edu/jmc/history/lisp/lisp.html">John McCarthy, History of Lisp (1979)</a>.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Generally, <code>nil</code> is a pretty special symbol: It is considered both a
symbol and a list (although it&rsquo;s not considered a cons cell according to Common
Lisp&rsquo;s <code>consp</code> or Scheme&rsquo;s <code>pair?</code>), it usually evaluates to itself, and in many
dialects both <code>(car nil)</code> and <code>(cdr nil)</code> evaluate to <code>nil</code>. It is also often used to
denote <i>false</i> in boolean operations.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">This is naturally a big assumption,
one that doesn&rsquo;t even match our previous definition of <code>Expr</code>, since string
literals are read-only, and we are storing them in a non-constant <code>char*</code>. We
would probably need to use some function that allocates the string on the heap,
like <a href="https://man.cx/strdup(3)"><code>strdup(3)</code></a>.</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Although Richard
Stallman doesn&rsquo;t agree with this statement, precisely because there aren&rsquo;t
proper cons cells in Clojure. See <a href="https://stallman.org/stallman-computing.html">How I do my computing</a>, retreived in February
2025.</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">I say &ldquo;potentially&rdquo; because, depending on how complex our
<code>Expr</code> structure was, the size of the union might have been already greater than
the size of <code>ExprPair</code>, so this change would have actually decreased the size of
an <code>Expr</code> structure (since we removed the <code>next</code> pointer). One example where the
union could be storing bigger members is if we kept track of the length of
symbols/strings along with the actual <code>char*</code> data.</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">As explained
<a href="#lists-and-syntactic-sugar">above</a>, <i>proper lists</i> are lists of cons cells whose last CDR is <code>nil</code>. This is
important because we want to stop as soon as we encounter <code>nil</code>, but an improper
list does not contain a null CDR so we would need a different loop
condition. Note that <code>nil</code> is also a proper list, and therefore a valid input for
this <code>sum</code> function.</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">See <a href="https://web.mit.edu/6.001/6.037/sicp.pdf#subsection.1.2.1">Section 1.2.1</a>
of <i>Structure and Interpretation of Computer Programs</i> for more information on how
the implementation of an iterative process can be recursive.</p></div></div>


</div>
</div></div>
</body>
</html>
