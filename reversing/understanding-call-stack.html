<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding and traversing the call stack</title>
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png" />
<link rel="stylesheet" type="text/css" href="../css/main.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Understanding and traversing the call stack</h1>
<p>
<a href="../index.html">Index</a> | <a href="index.html">Up</a>
</p>

<hr />

<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#main-uses-of-the-stack">2. Main uses of the stack</a>
<ul>
<li><a href="#implicit-push-and-pop-instructions">2.1. Implicit <code>push</code> and <code>pop</code> instructions</a></li>
</ul>
</li>
<li><a href="#stack-frames">3. Stack frames</a>
<ul>
<li><a href="#specifics-of-the-amd64-abi">3.1. Specifics of the AMD64 ABI</a></li>
<li><a href="#detailed-drawline-example">3.2. Detailed <code>DrawLine</code> example</a></li>
</ul>
</li>
<li><a href="#traversing-the-call-stack">4. Traversing the call stack</a>
<ul>
<li><a href="#the-asmprintcallstack-function">4.1. The <code>AsmPrintCallStack</code> function</a></li>
<li><a href="#note-about-position-independent-executables">4.2. Note about Position Independent Executables</a></li>
<li><a href="#calling-it-from-drawpoint">4.3. Calling it from <code>DrawPoint</code></a></li>
<li><a href="#our-main-function">4.4. Our <code>main</code> function</a></li>
<li><a href="#makefile">4.5. Makefile</a></li>
<li><a href="#checking-the-output">4.6. Checking the output</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-introduction" class="outline-2">
<h2 id="introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
This entry talks about the call stack from a very low-level perspective, so you
should be familiar with basic assembly.
</p>

<p>
First, a brief description of the <a href="https://en.wikipedia.org/wiki/Call_stack">stack</a>. The stack is a data structure used for
storing various kinds of information required by the active procedures of a
computer program. The stack is obviously a <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">LIFO</a> system, and it&rsquo;s usually
accessed by <i>pushing</i> or <i>popping</i> data (although this is not always the case, as we
will see). The stack usually <b>grows downwards</b>, which is a key detail that might
be easy to forget at first.
</p>

<p>
There are two very important registers when dealing with the stack. The <code>rsp</code>
register (stack pointer) always points to the top of the stack, and the <code>rbp</code>
register (base pointer) is used to delimit stack frames (more on this
below). The <code>rip</code> register will be mentioned as well, since it points to the
address of the next instruction to the one being executed.
</p>

<p>
When a value is <i>pushed</i> onto the stack the <code>rsp</code> register is decremented, <b>and then</b>
the value is moved onto the top of the stack. Therefore, the <code>rsp</code> register always
points to the last pushed item. Remember that the stack (usually) grows
downwards.
</p>

<p>
When a value is <i>popped</i> from the stack, the value on top of the stack is moved
into the specified register and the <code>rsp</code> register is incremented.
</p>
</div>
</div>

<div id="outline-container-main-uses-of-the-stack" class="outline-2">
<h2 id="main-uses-of-the-stack"><span class="section-number-2">2.</span> Main uses of the stack</h2>
<div class="outline-text-2" id="text-main-uses-of-the-stack">
<p>
The stack is used mainly for 3 purposes:
</p>

<ol class="org-ol">
<li>Storing some or all of the function arguments.</li>
<li>Storing the return address when calling a function.</li>
<li>Storing data local to the function (preserved registers, local variables,
etc.).</li>
</ol>

<p>
When function <code>foo</code> wants to call function <code>bar</code>, it will push some of the arguments
on the stack (this depends on the architecture). Then, it will push the address
of the next instruction (<code>rip</code> register) onto the stack, so <code>bar</code> knows where to
return once it&rsquo;s done. Then, after <code>foo</code> calls <code>bar</code>, <code>bar</code> might push some of the
registers that need to be preserved by the callee, like <code>rbp</code> or <code>r12</code>, and it will
allocate some space for storing its data, if needed. This will be explained in
more detail below, with an example.
</p>

<p>
These kind of details are specified in the Application Binary Interface (ABI) of
each architecture. For example, if we look in the System V AMD64 ABI (<a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">Wikipedia</a>,
<a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">PDF</a>), we can find the following about the usage of registers and the stack for
passing arguments.
</p>

<blockquote>
<p>
<b>System V AMD64 ABI - 3.2.3 Parameter Passing</b>
</p>

<p>
Once arguments are classified, the registers get assigned (in left-to-right
order) for passing as follows:
</p>

<ol class="org-ol">
<li>If the class is MEMORY, pass the argument on the stack.</li>

<li>If the class is INTEGER, the next available register of the sequence <code>rdi</code>,
<code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code> and <code>r9</code> is used.</li>

<li>[&#x2026;]</li>
</ol>

<p>
If there are no registers available for any eightbyte of an argument, the whole
argument is passed on the stack.
</p>
</blockquote>

<p>
As you can see, unlike in the i386 ABI (<a href="https://www.sco.com/developers/devspecs/abi386-4.pdf">PDF</a>, pg. 36-37), not all parameters are
passed through the stack.
</p>

<p>
About preserving the registers, we can also read the following.
</p>

<blockquote>
<p>
<b>System V AMD64 ABI - 3.2.1 Registers and the Stack Frame</b>
</p>

<p>
If a calling function wants to preserve such a register value across a function
call, it must save the value in its local stack frame.
</p>
</blockquote>
</div>

<div id="outline-container-implicit-push-and-pop-instructions" class="outline-3">
<h3 id="implicit-push-and-pop-instructions"><span class="section-number-3">2.1.</span> Implicit <code>push</code> and <code>pop</code> instructions</h3>
<div class="outline-text-3" id="text-implicit-push-and-pop-instructions">
<p>
About the return address, it&rsquo;s important to note that it is usually pushed
<b>implicitly</b> by the <code>call</code> instruction. The rough translation would be the
following.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #989898;">; </span><span style="color: #989898;">The following:</span>
<span style="color: #feacd0;">call</span>    <span style="color: #88ca9f;">0xDEADBEEF</span>

<span style="color: #989898;">; </span><span style="color: #989898;">Internally does:</span>
<span style="color: #feacd0;">push</span>    rip
<span style="color: #feacd0;">jmp</span>     <span style="color: #88ca9f;">0xDEADBEEF</span>
</pre>
</div>

<p>
Note that the example above is not strictly correct. First, we can&rsquo;t write or
read from <code>rip</code> directly, and second, <code>rip</code> would point to the <code>jmp</code> instruction
itself, which is not accurate. The correct form would be:
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #feacd0;">push</span>    next
<span style="color: #feacd0;">jmp</span>     <span style="color: #88ca9f;">0xDEADBEEF</span>

<span style="color: #4ae2ff;">next</span>: <span style="color: #feacd0;">nop</span>  <span style="color: #989898;">; </span><span style="color: #989898;">Continue execution...</span>
</pre>
</div>

<p>
Just like the return address is pushed implicitly, it&rsquo;s also popped implicitly
by the <code>ret</code> instruction.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #989898;">; </span><span style="color: #989898;">The following</span>
<span style="color: #feacd0;">ret</span>

<span style="color: #989898;">; </span><span style="color: #989898;">Internally does (without actually writing to RAX)</span>
<span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">rax</span>
<span style="color: #feacd0;">jmp</span>     <span style="color: #6ae4b9;">rax</span>

<span style="color: #989898;">; </span><span style="color: #989898;">Or simply (although we can't directly write to RIP)</span>
<span style="color: #feacd0;">pop</span>     rip
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-stack-frames" class="outline-2">
<h2 id="stack-frames"><span class="section-number-2">3.</span> Stack frames</h2>
<div class="outline-text-2" id="text-stack-frames">
<p>
The term <i>stack frame</i> has been mentioned, so let me explain exactly what it
is. Stack frames are used to <b>divide the stack</b> depending on the subroutine that
owns/needs the information. It&rsquo;s used to indicate, for example, that the region
that <code>foo</code> reserved on the stack belongs to <code>foo</code>, and not <code>bar</code> (since it&rsquo;s on <code>foo</code>&rsquo;s
stack frame).
</p>

<p>
You also have to understand that the specifics about who owns <i>X</i> kind of
information vary depending on the <b>convention</b>. For example, the two diagrams in
this section use different conventions when it comes to who &ldquo;owns&rdquo; the
parameters when calling a function. This is not important for understanding the
concept of the stack frame itself.
</p>

<p>
The <a href="https://en.wikipedia.org/wiki/Call_stack#STACK-FRAME">Wikipedia page</a> has a very good diagram for visualizing how a stack frame is
typically organized.
</p>


<div id="org08830cd" class="figure">
<p><img src="../img/callstack1.png" alt="callstack1.png" />
</p>
</div>

<p>
The diagram shows the call stack layout for an upward-growing stack after the
<code>DrawSquare</code> subroutine (shown in blue) called <code>DrawLine</code> (shown in green), which is
the currently executing routine.
</p>

<p>
When <code>DrawSquare</code> wants to call <code>DrawLine</code>, it pushes its arguments onto the
stack. In this convention, those belong to the stack frame of <code>DrawLine</code>. Then, as
I mentioned, the <code>call</code> instruction will push the return address onto the stack
(i.e. <code>rip</code>, which would contain the next instruction of <code>DrawSquare</code>). Finally,
<code>DrawLine</code> is free to push or allocate space on the stack for his local variables.
</p>

<p>
Usually, one of the first things a function does is preserve the <code>rbp</code> register
(containing the base pointer of the caller) by pushing it onto the stack
itself. Then, the current value of <code>rsp</code> is saved there throughout the execution
of our procedure. That&rsquo;s why the following pattern is a common way of
identifying functions from assembly.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #4ae2ff;">func</span>:
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">rbp</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rbp</span>, <span style="color: #6ae4b9;">rsp</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">...</span>

    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rsp</span>, <span style="color: #6ae4b9;">rbp</span>
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">rbp</span>
    <span style="color: #feacd0;">ret</span>
</pre>
</div>
</div>

<div id="outline-container-specifics-of-the-amd64-abi" class="outline-3">
<h3 id="specifics-of-the-amd64-abi"><span class="section-number-3">3.1.</span> Specifics of the AMD64 ABI</h3>
<div class="outline-text-3" id="text-specifics-of-the-amd64-abi">
<p>
In the last example, the stack grew upwards, which is not normally the case. The
next one (from the ABI) shows a more realistic (but perhaps more confusing)
version, where the top of the stack is in a lower address than the bottom.
</p>


<div id="org3ddf946" class="figure">
<p><img src="../img/callstack2.png" alt="callstack2.png" />
</p>
</div>

<p>
As I mentioned before, the specifics depend on the convention. Unlike in the
previous example, in the AMD64 ABI the arguments belong to the stack frame of
the <b>caller</b>, not the callee.
</p>
</div>
</div>

<div id="outline-container-detailed-drawline-example" class="outline-3">
<h3 id="detailed-drawline-example"><span class="section-number-3">3.2.</span> Detailed <code>DrawLine</code> example</h3>
<div class="outline-text-3" id="text-detailed-drawline-example">
<p>
As an example, let&rsquo;s write some of the assembly that <code>DrawLine</code> could be using. To
avoid cluttering the code with comments, I moved the explanation of each part to
the legend below.
</p>

<p>
In the following code, <code>DrawLine</code> pushes the base pointer (<code>rbp</code>) for <b>preserving the
caller&rsquo;s stack frame</b>. Then, it saves the value of <code>rsp</code> in <code>rbp</code>, creating its own
stack frame. This allows us to freely change <code>rsp</code>, while being able to access
function arguments and local variables with offsets relative to <code>rbp</code>. This might
seem a bit confusing at first, but it&rsquo;s a key detail since it essentially
creates a <b>linked list</b>, where you can follow <code>rbp</code>&rsquo;s to traverse stack frames.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #4ae2ff;">DrawLine</span>:
                                <span style="color: #989898;">; </span><span style="color: #989898;">(1)</span>
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">rbp</span>                 <span style="color: #989898;">; </span><span style="color: #989898;">(2)</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rbp</span>, <span style="color: #6ae4b9;">rsp</span>            <span style="color: #989898;">; </span><span style="color: #989898;">(3)</span>

    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">rbx</span>                 <span style="color: #989898;">; </span><span style="color: #989898;">(4)</span>
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">r12</span>

    <span style="color: #feacd0;">sub</span>     <span style="color: #6ae4b9;">rsp</span>, <span style="color: #88ca9f;">0x20</span>           <span style="color: #989898;">; </span><span style="color: #989898;">(5)</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">The real body of the procedure starts... (6)</span>
    <span style="color: #989898;">;</span><span style="color: #989898;">---------------------------------------------------------------------------</span>

    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">r12</span>, [<span style="color: #6ae4b9;">rbp</span> + <span style="color: #88ca9f;">0x16</span>]   <span style="color: #989898;">; </span><span style="color: #989898;">(7)</span>
    <span style="color: #feacd0;">mov</span>     [<span style="color: #6ae4b9;">rbp</span> - <span style="color: #88ca9f;">0x8</span>], <span style="color: #6ae4b9;">r12</span>    <span style="color: #989898;">; </span><span style="color: #989898;">(8)</span>

    <span style="color: #989898;">;</span><span style="color: #989898;">---------------------------------------------------------------------------</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">The body of the procedure ends...</span>

    <span style="color: #feacd0;">add</span>     <span style="color: #6ae4b9;">rsp</span>, <span style="color: #88ca9f;">0x20</span>           <span style="color: #989898;">; </span><span style="color: #989898;">(9)</span>

    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">r12</span>                 <span style="color: #989898;">; </span><span style="color: #989898;">(10)</span>
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">rbx</span>

    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rsp</span>, <span style="color: #6ae4b9;">rbp</span>            <span style="color: #989898;">; </span><span style="color: #989898;">(11)</span>
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">rbp</span>                 <span style="color: #989898;">; </span><span style="color: #989898;">(12)</span>
    <span style="color: #feacd0;">ret</span>                         <span style="color: #989898;">; </span><span style="color: #989898;">(13)</span>
</pre>
</div>

<ol class="org-ol">
<li>Right when we got called, <code>RSP</code> points to the return address in <code>DrawSquare</code>, and
the <code>DrawLine</code> arguments are right below it, from <code>[RSP+0x8]</code> to
<code>[RSP+(n*0x8)]</code>. Note that they are lower on the stack, but higher in memory.</li>
<li>The first thing we usually do is push the old <code>RBP</code> value that <code>DrawSquare</code> was
using. After pushing it, <code>RSP</code> will point to the old <code>RBP</code>, hence the &ldquo;linked
list&rdquo; of <code>RBP</code>&rsquo;s. The return address will be at <code>[RSP+8]</code> after the push.</li>
<li>The current value of <code>RSP</code> is saved into <code>RBP</code>, creating our stack frame. This
way, we can freely change <code>RSP</code>, and access parameters with stack offsets
relative to <code>RBP</code>.</li>
<li>Now <code>DrawLine</code> needs to push some registers that must be preserved by the
callee (according to the ABI). After this, the &ldquo;real&rdquo; body of the procedure
will be able to safely use these registers without overwriting the caller&rsquo;s
values.</li>
<li>The procedure subtracts from <code>RSP</code> to allocate <code>0x20</code> bytes some space for local
variables.</li>
<li>From the procedure body, it might access the function arguments by <b>adding</b> to
<code>RBP</code>, or it might need to store values in the reserved stack space, and access
them by <b>subtracting</b> to <code>RBP</code> (e.g. for local variables).</li>
<li>Here, it adds <code>0x16</code> to the base pointer for &ldquo;jumping&rdquo; over both the pushed <code>RBP</code>
and the return address, accessing some argument, and saving it into <code>r12</code>.</li>
<li>Then, it saves that value into some of the stack space that we reserved when
subtracting from <code>RSP</code>.</li>
<li>When we are done, we add back the space previously subtracted from <code>RSP</code>.</li>
<li>We pop back the registers that had to be preserved by the callee.</li>
<li>We restore the base pointer into <code>RSP</code>.</li>
<li>We pop the caller&rsquo;s <code>RBP</code> register.</li>
<li>Finally, <code>RSP</code> points to the return address from <code>DrawSquare</code>, which was pushed
by the <code>call</code> instruction. As I said, the <code>ret</code> instruction will pop it and jump
to it.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-traversing-the-call-stack" class="outline-2">
<h2 id="traversing-the-call-stack"><span class="section-number-2">4.</span> Traversing the call stack</h2>
<div class="outline-text-2" id="text-traversing-the-call-stack">
<p>
Let&rsquo;s look at some example C code.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6740;">#include</span> <span style="color: #00d3d0;">&lt;stdio.h&gt;</span>

<span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">DrawPoint</span>(<span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">x</span>, <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">y</span>) {
    printf(<span style="color: #00d3d0;">"Drawing point: %d, %d\n"</span>, x, y);
}

<span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">DrawLine</span>(<span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">x0</span>, <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">y0</span>, <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">x1</span>, <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">y1</span>) {
    <span style="color: #ff6f9f;">for</span> (<span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">y</span> = y0; y &lt;= y1; y++)
        <span style="color: #ff6f9f;">for</span> (<span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">x</span> = x0; x &lt;= x1; x++)
            DrawPoint(x, y);
}

<span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">DrawSquare</span>(<span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">x</span>, <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">y</span>, <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">w</span>, <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">h</span>) {
    <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">x1</span> = x + w;
    <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">y1</span> = y + h;

    DrawLine(x, y, x1, y);   <span style="color: #989898;">/* </span><span style="color: #989898;">Up</span><span style="color: #989898;"> */</span>
    DrawLine(x, y, x, y1);   <span style="color: #989898;">/* </span><span style="color: #989898;">Left</span><span style="color: #989898;"> */</span>
    DrawLine(x, y1, x1, y1); <span style="color: #989898;">/* </span><span style="color: #989898;">Down</span><span style="color: #989898;"> */</span>
    DrawLine(x1, y, x1, y1); <span style="color: #989898;">/* </span><span style="color: #989898;">Right</span><span style="color: #989898;"> */</span>
}
</pre>
</div>

<p>
The call stack for <code>DrawPoint()</code> would be the following:
</p>

<pre class="example" id="orgbdfab58">
(???)  -&gt;  DrawSquare()  -&gt;  DrawLine()  -&gt;  DrawPoint()
</pre>
</div>

<div id="outline-container-the-asmprintcallstack-function" class="outline-3">
<h3 id="the-asmprintcallstack-function"><span class="section-number-3">4.1.</span> The <code>AsmPrintCallStack</code> function</h3>
<div class="outline-text-3" id="text-the-asmprintcallstack-function">
<p>
Since we now have a deep understanding of the stack, let&rsquo;s write some assembly
code that prints the backtrace of where we were called.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #ff6f9f;">default</span> <span style="color: #79a8ff;">rel</span>
<span style="color: #ff6f9f;">extern</span> printf

<span style="color: #ff6f9f;">section</span> <span style="color: #79a8ff;">.data</span>
    <span style="color: #4ae2ff;">fmt</span>: <span style="color: #feacd0;">db</span> <span style="color: #00d3d0;">"%d: %p"</span>, <span style="color: #88ca9f;">0xA</span>, <span style="color: #88ca9f;">0x0</span>

<span style="color: #ff6f9f;">section</span> <span style="color: #79a8ff;">.text</span>

<span style="color: #989898;">; </span><span style="color: #989898;">void AsmPrintCallStack(int depth);</span>
<span style="color: #ff6f9f;">global</span> AsmPrintCallStack
<span style="color: #4ae2ff;">AsmPrintCallStack</span>:
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">rbp</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rbp</span>, <span style="color: #6ae4b9;">rsp</span>
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">r12</span>
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">r13</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">Initialize counter to the first "depth" argument</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">r13</span>, <span style="color: #6ae4b9;">rdi</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">Get address of old RBP, skip ours</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">r12</span>, [<span style="color: #6ae4b9;">rbp</span>]

<span style="color: #4ae2ff;">.loop</span>:
    <span style="color: #989898;">; </span><span style="color: #989898;">If RBP is NULL, we are done.</span>
    <span style="color: #feacd0;">test</span>    <span style="color: #6ae4b9;">r13</span>, <span style="color: #6ae4b9;">r13</span>
    <span style="color: #feacd0;">jz</span>      .done

    <span style="color: #989898;">; </span><span style="color: #989898;">Otherwise, we can print it.</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">We add 8 to the current RBP to get the current return address.</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rdx</span>, [<span style="color: #6ae4b9;">r12</span> + <span style="color: #88ca9f;">0x8</span>]
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rsi</span>, <span style="color: #6ae4b9;">r13</span>
    <span style="color: #feacd0;">lea</span>     <span style="color: #6ae4b9;">rdi</span>, [<span style="color: #79a8ff;">rel</span> fmt]
    <span style="color: #feacd0;">call</span>    printf <span style="color: #79a8ff;">wrt</span> ..plt

    <span style="color: #989898;">; </span><span style="color: #989898;">And jump to the next one</span>
    <span style="color: #feacd0;">dec</span>     <span style="color: #6ae4b9;">r13</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">r12</span>, [<span style="color: #6ae4b9;">r12</span>]
    <span style="color: #feacd0;">jmp</span>     .loop

<span style="color: #4ae2ff;">.done</span>:
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">r13</span>
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">r12</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rsp</span>, <span style="color: #6ae4b9;">rbp</span>
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">rbp</span>
    <span style="color: #feacd0;">ret</span>
</pre>
</div>

<p>
Let me briefly explain what&rsquo;s going on. First, we use <code>default rel</code> to enable
<a href="https://www.nasm.us/xdoc/2.13.02rc2/html/nasmdoc6.html#section-6.2.1">RIP-relative addressing</a> (See also <a href="https://www.nasm.us/xdoc/2.13.02rc2/html/nasmdoc3.html#section-3.3">section 3.3</a> of the NASM manual). More of this
is explained in the next section. We also declare <code>printf</code> as an <code>extern</code> symbol.
</p>

<p>
On the <code>.data</code> section, we declare our format string, that will be used later when
calling <code>printf</code>.
</p>

<p>
On the <code>.text</code> section, the function preserves the previous stack frame as we have
seen before. It also preserves <code>r12</code> and <code>r13</code>, which will be used for storing the
current base pointer and the current counter, respectively.
</p>

<p>
Then, it initializes the counter (<code>r13</code>) to the first argument of the function
(<code>rdi</code>), and the <code>r12</code> register to the base pointer <b>of the caller</b>, by dereferencing
our own base pointer. If we moved <code>rbp</code> to <code>r12</code>, instead of <code>[rbp]</code>, we would also
print the address of our caller. If you are confused about this, check the
diagram in <a href="#specifics-of-the-amd64-abi">Specifics of the AMD64 ABI</a>.
</p>

<p>
Then, the loop starts. We check if the iterator is zero, and if it is, we return
from the function. Otherwise, we will calculate the return address of the
current stack frame by adding 8 to the base pointer. We will then call <code>printf</code>
with the <code>fmt</code> string as its first argument, the iterator as the second one and
the return address we just calculated as its third argument.
</p>

<p>
After calling <code>printf</code>, we will decrease the iterator and dereference the current
base pointer, jumping to the previous stack frame. Finally, we jump back to the
<code>.loop</code> label.
</p>

<p>
The rough C translation of the loop would be the following:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">while</span> (i != <span style="color: #88ca9f;">0</span>) {
    <span style="color: #79a8ff;">void</span>* <span style="color: #6ae4b9;">ret_addr</span> = *(cur_base_ptr + <span style="color: #88ca9f;">0x8</span>);
    printf(<span style="color: #00d3d0;">"%d: %p\n"</span>, i, ret_addr);

    i--;
    cur_base_ptr = *cur_base_ptr;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-note-about-position-independent-executables" class="outline-3">
<h3 id="note-about-position-independent-executables"><span class="section-number-3">4.2.</span> Note about Position Independent Executables</h3>
<div class="outline-text-3" id="text-note-about-position-independent-executables">
<p>
You might be wondering why we had to use <code>wrt ..plt</code> when calling <code>printf</code>. It&rsquo;s for
the same reason why we have to use <code>lea rdi, [rel fmt]</code> instead of
<code>mov rdi, fmt</code>. Our GCC has <a href="https://en.wikipedia.org/wiki/Position-independent_code"><code>-fPIE</code></a> (Position Independent Executable) enabled by
default. That means that our addresses and calls have to be relative. We have
two solutions for this:
</p>

<ol class="org-ol">
<li>Disable PIE by passing <code>-no-pie</code> to GCC when linking.</li>
<li>Adapt our assembly to link with PIE.</li>
</ol>

<p>
I chose to use the second option, so I can explain how it works. If we just used
<code>call print</code> and <code>mov rdi, fmt</code>, and linked with PIE enabled, we would get the
following warnings:
</p>

<pre class="example" id="orgff9bb36">
/usr/bin/ld: obj/callstack.asm.o: warning: relocation in read-only section `.text'
/usr/bin/ld: obj/callstack.asm.o: relocation R_X86_64_PC32 against symbol `printf@@GLIBC_2.2.5' can not be used when making a PIE object; recompile with -fPIE
/usr/bin/ld: final link failed: bad value
</pre>

<p>
Before trying to understand this <i>terrible</i> error message, you need to understand
that the linker asumes <b>all</b> of our object files have been <b>compiled</b>, and not
assembled by hand. Therefore, when it says &ldquo;recompile with <code>-fPIE</code>&rdquo;, it&rsquo;s not
necessarily referring to our C object files, but also our hand-written assembly
ones. You should read the error as &ldquo;Whoever made this ASM (human or compiler),
make it PIE compatible&rdquo;.
</p>

<p>
So, how do we make our assembly PIE compatible? The most important part is that
we need to call <code>printf</code> through the <a href="https://en.wikipedia.org/wiki/Position-independent_code#Technical_details">Procedure Linkage Table</a> (PLT), instead of
using a direct call. That&rsquo;s exactly what <code>wrt ..plt</code> is doing.
</p>

<p>
That would fix the second linker error, but what about the first warning? That
happens because we are using the <code>mov</code> instruction with the absolute address of
<code>fmt</code>. This creates a 64-bit relocation, since this absolute address isn&rsquo;t known
until run time, and the dynamic linker has to fill it out. Have a look at the
following assembly.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #989898;">; </span><span style="color: #989898;">Assemble with:</span>
<span style="color: #989898;">;   </span><span style="color: #989898;">nasm -f elf64 -o file.o file.asm</span>
<span style="color: #989898;">; </span><span style="color: #989898;">Look at the generated bytes with a RE tool like rizin.</span>

<span style="color: #ff6f9f;">section</span> <span style="color: #79a8ff;">.bss</span>
<span style="color: #4ae2ff;">addr</span>: <span style="color: #feacd0;">resb</span> <span style="color: #88ca9f;">1</span>

<span style="color: #ff6f9f;">section</span> <span style="color: #79a8ff;">.text</span>
<span style="color: #4ae2ff;">_start</span>:
    <span style="color: #feacd0;">mov</span> <span style="color: #6ae4b9;">rax</span>, addr
    <span style="color: #feacd0;">lea</span> <span style="color: #6ae4b9;">rax</span>, [addr]
    <span style="color: #feacd0;">lea</span> <span style="color: #6ae4b9;">rax</span>, [<span style="color: #79a8ff;">rel</span> addr]
</pre>
</div>

<p>
The <code>addr</code> label is being accessed in 3 ways. The first two are using the absolute
address, and will produce a relocation. The third one, calculates the address by
adding (or subtracting) an offset from the instruction pointer (<code>rip</code>). If you
assemble it, and <a href="https://defuse.ca/online-x86-assembler.htm">look</a> at the instruction bytes, you can tell the difference
(note the <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a>).
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #88ca9f;">48</span> b8 <span style="color: #88ca9f;">00</span> <span style="color: #88ca9f;">02</span> <span style="color: #88ca9f;">00</span> <span style="color: #88ca9f;">08</span> <span style="color: #88ca9f;">00</span> <span style="color: #88ca9f;">00</span> <span style="color: #88ca9f;">00</span> <span style="color: #88ca9f;">00</span>  movabs <span style="color: #6ae4b9;">rax</span>, <span style="color: #88ca9f;">0x8000200</span>
<span style="color: #88ca9f;">48</span> <span style="color: #88ca9f;">8d</span> <span style="color: #88ca9f;">04</span> <span style="color: #88ca9f;">25</span> <span style="color: #88ca9f;">00</span> <span style="color: #88ca9f;">02</span> <span style="color: #88ca9f;">00</span> <span style="color: #88ca9f;">08</span>        <span style="color: #feacd0;">lea</span>    <span style="color: #6ae4b9;">rax</span>, <span style="color: #6ae4b9;">ds</span>:<span style="color: #88ca9f;">0x8000200</span>
<span style="color: #88ca9f;">48</span> <span style="color: #88ca9f;">8d</span> <span style="color: #88ca9f;">05</span> e7 ff ff ff           <span style="color: #feacd0;">lea</span>    <span style="color: #6ae4b9;">rax</span>, [rip + <span style="color: #88ca9f;">0xffffffffffffffe7</span>] <span style="color: #989898;">; </span><span style="color: #989898;">[rip - 0x19]</span>
</pre>
</div>

<p>
The linker doesn&rsquo;t like runtime relocations in <code>.text</code>, hence the &ldquo;relocation in
read-only section <code>.text</code>&rdquo; warning. Since <code>printf</code> needs an absolute address, we can
convert the RIP-relative address to an absolute one with <code>lea rdi, [rel fmt]</code>. The
<code>rel</code> stands for relative, and although we don&rsquo;t need it since we specified
<code>default rel</code> at the top, I chose to emphasize it anyway.
</p>

<p>
Sources:
</p>

<ol class="org-ol">
<li><a href="https://stackoverflow.com/a/46493456/11715554">StackOverflow 1</a></li>
<li><a href="https://stackoverflow.com/q/73275183/11715554">StackOverflow 2</a> (Check comments)</li>
<li><a href="https://www.reddit.com/r/asm/comments/1afi6nr/comment/koabzk0/">Reddit answer</a> (Skeeto saves the day once more)</li>
</ol>
</div>
</div>

<div id="outline-container-calling-it-from-drawpoint" class="outline-3">
<h3 id="calling-it-from-drawpoint"><span class="section-number-3">4.3.</span> Calling it from <code>DrawPoint</code></h3>
<div class="outline-text-3" id="text-calling-it-from-drawpoint">
<p>
Now that we have our <code>AsmPrintCallStack</code> function, we can modify our C code a bit
to call it from <code>DrawPoint</code>.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ff6f9f;">extern</span> <span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">AsmPrintCallStack</span>(<span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">depth</span>);

<span style="color: #79a8ff;">void</span> <span style="color: #4ae2ff;">DrawPoint</span>(<span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">x</span>, <span style="color: #79a8ff;">int</span> <span style="color: #6ae4b9;">y</span>) {
    printf(<span style="color: #00d3d0;">"Drawing point: %d, %d\n"</span>, x, y);

    AsmPrintCallStack(<span style="color: #88ca9f;">3</span>);
}
</pre>
</div>

<p>
We will print the last 3 return addresses, one for <code>DrawLine</code>, one for <code>DrawSquare</code>
and the last one for <code>main</code>.
</p>
</div>
</div>

<div id="outline-container-our-main-function" class="outline-3">
<h3 id="our-main-function"><span class="section-number-3">4.4.</span> Our <code>main</code> function</h3>
<div class="outline-text-3" id="text-our-main-function">
<p>
Our main function simply calls <code>DrawSquare()</code>.
</p>

<p>
We will print the addresses of each function from main, so we can verify that
the addresses from <code>AsmPrintCallStack</code> are correct.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #79a8ff;">int</span> <span style="color: #4ae2ff;">main</span>(<span style="color: #79a8ff;">void</span>) {
    printf(<span style="color: #00d3d0;">"(main) Address of DrawPoint:  %p\n"</span>, DrawPoint);
    printf(<span style="color: #00d3d0;">"(main) Address of DrawLine:   %p\n"</span>, DrawLine);
    printf(<span style="color: #00d3d0;">"(main) Address of DrawSquare: %p\n"</span>, DrawSquare);
    printf(<span style="color: #00d3d0;">"(main) Address of main:       %p\n"</span>, main);

    <span style="color: #989898;">/* </span><span style="color: #989898;">DrawPoint only gets called once</span><span style="color: #989898;"> */</span>
    DrawSquare(<span style="color: #88ca9f;">5</span>, <span style="color: #88ca9f;">5</span>, <span style="color: #88ca9f;">0</span>, <span style="color: #88ca9f;">0</span>);

    <span style="color: #ff6f9f;">return</span> <span style="color: #88ca9f;">0</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-makefile" class="outline-3">
<h3 id="makefile"><span class="section-number-3">4.5.</span> Makefile</h3>
<div class="outline-text-3" id="text-makefile">
<p>
The <code>-fPIE</code> parameter should not be necessary, but I still added it to emphasize
what I mentioned in <a href="#note-about-position-independent-executables">Note about Position Independent Executables</a>.
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #6ae4b9;">CC</span>=gcc
<span style="color: #6ae4b9;">CFLAGS</span>=-Wall -Wextra
<span style="color: #6ae4b9;">LDFLAGS</span>=-fPIE

<span style="color: #6ae4b9;">ASM</span>=nasm
<span style="color: #6ae4b9;">ASMFLAGS</span>=-f elf64

<span style="color: #6ae4b9;">OBJS</span>=obj/main.c.o obj/callstack.asm.o
<span style="color: #6ae4b9;">BIN</span>=callstack-test.out

<span style="color: #4ae2ff;">all</span>: $(<span style="color: #6ae4b9;">BIN</span>)

<span style="color: #4ae2ff;">clean</span>:
    rm -f $(<span style="color: #6ae4b9;">BIN</span>) $(<span style="color: #6ae4b9;">OBJS</span>)

<span style="color: #4ae2ff;">$(</span><span style="color: #4ae2ff;">BIN</span><span style="color: #4ae2ff;">)</span>: $(<span style="color: #6ae4b9;">OBJS</span>)
    $(<span style="color: #6ae4b9;">CC</span>) $(<span style="color: #6ae4b9;">CFLAGS</span>) -o <span style="color: #4ae2ff;">$</span><span style="color: #88ca9f;">@</span> $<span style="color: #88ca9f;">^</span> $(<span style="color: #6ae4b9;">LDFLAGS</span>)

<span style="color: #4ae2ff;">obj/main.c.o</span>: main.c
    @mkdir -p $(<span style="color: #6ae4b9;">dir</span> <span style="color: #4ae2ff;">$</span><span style="color: #88ca9f;">@</span>)
    $(<span style="color: #6ae4b9;">CC</span>) $(<span style="color: #6ae4b9;">CFLAGS</span>) -c -o <span style="color: #4ae2ff;">$</span><span style="color: #88ca9f;">@</span> $<span style="color: #88ca9f;">&lt;</span>

<span style="color: #4ae2ff;">obj/callstack.asm.o</span>: callstack.asm
    @mkdir -p $(<span style="color: #6ae4b9;">dir</span> <span style="color: #4ae2ff;">$</span><span style="color: #88ca9f;">@</span>)
    $(<span style="color: #6ae4b9;">ASM</span>) $(<span style="color: #6ae4b9;">ASMFLAGS</span>) -o <span style="color: #4ae2ff;">$</span><span style="color: #88ca9f;">@</span> $<span style="color: #88ca9f;">&lt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-checking-the-output" class="outline-3">
<h3 id="checking-the-output"><span class="section-number-3">4.6.</span> Checking the output</h3>
<div class="outline-text-3" id="text-checking-the-output">
<p>
Then, we can just run <code>make</code> and check the output:
</p>

<pre class="example" id="orga6166fe">
(main) Address of DrawPoint:  0x5a1e3d78e139
(main) Address of DrawLine:   0x5a1e3d78e170
(main) Address of DrawSquare: 0x5a1e3d78e1bf
(main) Address of main:       0x5a1e3d78e238
Drawing point: 5, 5
3: 0x5a1e3d78e1a3
2: 0x5a1e3d78e1fc
1: 0x5a1e3d78e2cd
Drawing point: 5, 5
3: 0x5a1e3d78e1a3
2: 0x5a1e3d78e20f
1: 0x5a1e3d78e2cd
Drawing point: 5, 5
3: 0x5a1e3d78e1a3
2: 0x5a1e3d78e222
1: 0x5a1e3d78e2cd
Drawing point: 5, 5
3: 0x5a1e3d78e1a3
2: 0x5a1e3d78e235
1: 0x5a1e3d78e2cd
</pre>

<p>
That looks about right. The only address that&rsquo;s changing is the second one,
since each call to <code>DrawLine</code> from <code>DrawSquare</code> increments the <code>RIP</code> register by some
bytes.
</p>

<p>
If we really want to make sure it&rsquo;s accurate, let&rsquo;s disassemble the binary and
look at the offsets inside the functions. I will be using <a href="https://rizin.re/">rizin</a>, but any similar
tool will do.
</p>

<p>
According to our output, the next instruction to the call to <code>DrawPoint</code> should be
at offset <code>+0x33</code> (<code>0x5a1e3d78e1a3-0x5a1e3d78e170</code>) inside <code>DrawLine</code>. Let&rsquo;s have a
look.
</p>


<div id="orgfd5040d" class="figure">
<p><img src="../img/callstack3.png" alt="callstack3.png" />
</p>
</div>

<p>
Indeed, the call to <code>DrawPoint</code> is at <code>+0x2e</code>, and the next instruction is at
<code>+0x33</code>. We can see that this is also the case with <code>DrawSquare</code> and <code>main</code>.
</p>


<div id="org0ac9d7b" class="figure">
<p><img src="../img/callstack4.png" alt="callstack4.png" />
</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
