#+TITLE: Challenge 3
#+AUTHOR: 8dcc
#+OPTIONS: toc:nil
#+STARTUP: showeverything
#+HTML_HEAD: <style>pre.src{background:#111111;color:white;} </style>

Original challenge link: [[https://challenges.re/3/][Click me]]

#+TOC: headlines 2

* Original assembly

This array of 32-bit integers is available to the function.

#+begin_src C
int32_t v[64] = { -1, 31, 8,  30, -1, 7,  -1, -1, 29, -1, 26, 6,  -1, -1, 2,  -1,
                  -1, 28, -1, -1, -1, 19, 25, -1, 5,  -1, 17, -1, 23, 14, 1,  -1,
                  9,  -1, -1, -1, 27, -1, 3,  -1, -1, -1, 20, -1, 18, 24, 15, 10,
                  -1, -1, 4,  -1, 21, -1, 16, 11, -1, 22, -1, 12, 13, -1, 0,  -1 };
#+end_src

This is the original function, adapted to fit the [[https://www.nasm.us/][nasm]] syntax.

#+begin_src nasm
f:
    mov     edx, edi
    shr     edx
    or      edx, edi
    mov     eax, edx
    shr     eax, 2
    or      eax, edx
    mov     edx, eax
    shr     edx, 4
    or      edx, eax
    mov     eax, edx
    shr     eax, 8
    or      eax, edx
    mov     edx, eax
    shr     edx, 16
    or      edx, eax
    imul    eax, edx, 79355661 ; 0x4badf0d
    shr     eax, 26
    mov     eax, v[0 + rax * 4]
#+end_src

* Analysis

First of all, it loads the function argument into =edx=.

#+begin_src nasm
f:
    mov     edx, edi
#+end_src

Keep in mind that this is a 64-bit program, so the [[https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf][x86-64 calling convention]] is
different from the [[https://www.sco.com/developers/devspecs/abi386-4.pdf][i386 calling convention]]:

#+begin_quote
*AMD64 System V ABI - 3.2.3 Parameter Passing*

After the argument values have been computed, they are placed either in
registers or pushed on the stack. [...]

Once arguments are classified, the registers get assigned (in left-to-right
order) for passing as follows:

- If the class is INTEGER, the next available register of the sequence =%rdi=,
  =%rsi=, =%rdx=, =%rcx=, =%r8= and =%r9= is used.
#+end_quote
