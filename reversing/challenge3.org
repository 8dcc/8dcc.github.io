#+TITLE: Challenge 3
#+AUTHOR: 8dcc
#+OPTIONS: toc:nil
#+STARTUP: showeverything
#+HTML_HEAD: <style>pre.src{background:#111111;color:white;} </style>

Original challenge link: [[https://challenges.re/3/][Click me]]

#+TOC: headlines 2

* Original assembly

This array of 32-bit integers is available to the function.

#+begin_src C
int32_t v[64] = { -1, 31, 8,  30, -1, 7,  -1, -1, 29, -1, 26, 6,  -1, -1, 2,  -1,
                  -1, 28, -1, -1, -1, 19, 25, -1, 5,  -1, 17, -1, 23, 14, 1,  -1,
                  9,  -1, -1, -1, 27, -1, 3,  -1, -1, -1, 20, -1, 18, 24, 15, 10,
                  -1, -1, 4,  -1, 21, -1, 16, 11, -1, 22, -1, 12, 13, -1, 0,  -1 };
#+end_src

This is the original function, adapted to fit the [[https://www.nasm.us/][nasm]] syntax.

#+begin_src nasm
f:
    mov     edx, edi
    shr     edx
    or      edx, edi
    mov     eax, edx
    shr     eax, 2
    or      eax, edx
    mov     edx, eax
    shr     edx, 4
    or      edx, eax
    mov     eax, edx
    shr     eax, 8
    or      eax, edx
    mov     edx, eax
    shr     edx, 16
    or      edx, eax
    imul    eax, edx, 79355661 ; 0x4badf0d
    shr     eax, 26
    mov     eax, v[0 + rax * 4]
    ret
#+end_src

* Analysis

First of all, it loads the function argument into =edx=.

#+begin_src nasm
mov     edx, edi
#+end_src

Keep in mind that this is a 64-bit program, so the [[https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf][x86-64 calling convention]] is
different from the [[https://www.sco.com/developers/devspecs/abi386-4.pdf][i386 calling convention]]:

#+begin_quote
*AMD64 System V ABI - 3.2.3 Parameter Passing*

After the argument values have been computed, they are placed either in
registers or pushed on the stack. [...]

Once arguments are classified, the registers get assigned (in left-to-right
order) for passing as follows:

- If the class is INTEGER, the next available register of the sequence =%rdi=,
  =%rsi=, =%rdx=, =%rcx=, =%r8= and =%r9= is used.
#+end_quote

After that, it shifts the value in the =edx= register (the function argument) 1
bit to the right, and it OR's it with the original unshifted value from =edi=.

#+begin_src nasm
shr     edx
or      edx, edi
#+end_src

Next, it moves the OR'd value to =eax=, and shifts it again 2 bits to the
right. Then it OR's them back into =eax=.

#+begin_src nasm
mov     eax, edx
shr     eax, 2
or      eax, edx
#+end_src

It repeats that same process, duplicating the number of bits shifted every time:

#+begin_src nasm
mov     edx, eax
shr     edx, 4
or      edx, eax

mov     eax, edx
shr     eax, 8
or      eax, edx

mov     edx, eax
shr     edx, 16
or      edx, eax
#+end_src

Let's have a look at what this is doing to the bits of our input:

| Shifted | Hex value  | Binary value                       |
|---------+------------+------------------------------------|
|       0 | =0x80000000= | =0b10000000000000000000000000000000= |
|       1 | =0xC0000000= | =0b11000000000000000000000000000000= |
|       2 | =0xF0000000= | =0b11110000000000000000000000000000= |
|       4 | =0xFF000000= | =0b11111111000000000000000000000000= |
|       8 | =0xFFFF0000= | =0b11111111111111110000000000000000= |
|      16 | =0xFFFFFFFF= | =0b11111111111111111111111111111111= |

Each value shows the number after shifting and ORing it with the previous
value. The first value would be our input, but as you can imagine, the result
ends up being the same even if there is more than one bit set on the input
value. The only thing that matters from the input is the last set bit, since
every bit from there will be set.

[[file:../img/slomo.gif]]

Finally, it multiplies the last value (In our example =0xFFFFFFFF=) by the
previous value (=0xFFFF0000=), and by 79355661 (=0x4badf0d=), and shifts the =eax=
register 26 bits to the right.

TODO: How do we get the final index? Finish this section.

#+begin_src nasm
imul    eax, edx, 79355661 ; 0x4badf0d
shr     eax, 26
#+end_src

It then uses the value stored in the =eax= register as an index for the =v=
array. To access the index, we multiply the position by the size of each
element. In this case, 4 bytes, since the exercise specifies that they are
32-bit integers.

#+begin_src nasm
mov     eax, v[0 + rax * 4]
ret
#+end_src
