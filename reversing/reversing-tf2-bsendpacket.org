#+TITLE: Reversing TF2's bSendPacket
#+AUTHOR: 8dcc
#+OPTIONS: toc:nil
#+STARTUP: nofold
#+HTML_HEAD: <link rel="icon" type="image/x-icon" href="../img/favicon.png">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css">

[[file:../index.org][Index]] | [[file:index.org][Up]]

-----

#+TOC: headlines 2

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

Team Fortress 2 (TF2) is a 2007 multiplayer first-person shooter game developed
and published by Valve Corporation ([[https://en.wikipedia.org/wiki/Team_Fortress_2][Wikipedia]]).

On [[https://github.com/8dcc/tf2-cheat/commit/0daa5bb7b03abf0ae8b150312f0147eb7ef5a148][Aug 6, 2023]], I started working on a TF2 cheat for GNU/Linux, and in over 600
commits, I was pretty happy with the result.

However, on April 19, 2024 (just a few days before writing this), Valve released
a 64-bit update. For windows, this just meant an extra architecture, but on
GNU/Linux, they entirely removed the 32-bit binaries. I decided to archive the
repository and continue developing the cheat privately.

One of the main reasons for this decision was that I wanted to avoid essentially
releasing fixes for the cheat, that would get used by people who are just
interested in copy-pasting a working cheat and selling it, or making [[https://www.theverge.com/2022/5/27/23144061/valve-team-fortress-2-bot-problem-savetf2-spam][bots]]. As I
explained in the repository's README, I made this project because I enjoyed
reversing the game in a platform with not much reference, and I enjoyed the low
level aspect of essentially having to do all the "dirty work" of reversing the
game and making everything work.

However, It is not fair to say that I was the only one involved, and obviously
some people did help me greatly. I just want to quickly mention [[https://github.com/Lak3][Lak3]] for his
time and help, and [[https://github.com/nepcat][nepcat]] for his helpful PRs, and his interest in the project.

Now that this long introduction is finished, we can get to finding =bSendPacket=.

* The problem
:PROPERTIES:
:CUSTOM_ID: the-problem
:END:

First, in case the reader is unfamiliar with game hacking in the source engine,
I need to briefly explain what =bSendPacket= is used for.

In the source engine, we run a lot of our hacks from the =CreateMove= hook (for
more information about hooking in general, see my [[file:../programming/detour-hooking.org][Detour Hooking]]
entry). However, there is not just one =CreateMove=, and some people choose to
hook one over the other. In my case, I have always hooked
=ClientModeShared::CreateMove=.

Let's have a look at where this is called by looking at the [[https://github.com/OthmanAba/TeamFortress2][leaked TF2 source]].

1. Our =ClientModeShared::CreateMove= function is defined in
   [[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/game/client/clientmode_shared.cpp#L417][=clientmode_shared.cpp=]]. As you can see, it calls another =CreateMove=
   function, but we don't care about that one.
2. This =ClientModeShared::CreateMove= function is called from =CInput::CreateMove=,
   defined in [[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/game/client/in_main.cpp#L1111][=in_main.cpp=]]. You can see it calls it from a =g_pClientMode= global
   pointer.
3. This =CInput::CreateMove= function is called from =CHLClient::CreateMove=,
   defined in [[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/game/client/cdll_client_int.cpp#L1448][=cdll_client_int.cpp=]].
4. Finally, this =CHLClient::CreateMove= function is called from =CL_Move=, defined
   in [[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2119][=cl_main.cpp=]].

So, in order, the calls would be the following:

#+begin_example text
CL_Move()  ->  CHLClient::CreateMove()  ->  CInput::CreateMove()  ->  ClientModeShared::CreateMove()
#+end_example

Okay, but why is this important? Let's have a look at this last function,
=CL_Move=. It defines a [[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2130][local variable]] called =bSendPacket=, which will later [[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2178-L2188][decide]]
if the current command should be sent or, on the other hand, choked. Being able
to control which packets are sent and which ones aren't is extremely useful for
us, so we need to find a way of changing its value.

As I said, this is a *local variable*, so we can't just treat it as a global and
get a pointer to it. This variable is declared within the [[https://en.wikipedia.org/wiki/Call_stack#STACK-FRAME][stack frame]] of
=CL_Move=, and only exists throughout its life cycle (this will be explained
bellow in more detail). We will need to find a way of somehow tricking =CL_Move=
into thinking that this variable has the value we want it to have, and ideally
do that from =ClientModeShared::CreateMove=.

* The old solution
:PROPERTIES:
:CUSTOM_ID: the-old-solution
:END:

When I started developing my cheat for the 32-bit game, I came across an
(almost) valid solution.

Since =CL_Move= only sets =bSendPacket= to true on [[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2130][once place]], we could just
overwrite this constant in memory, so that it gets initialized to true only
whenever we want.

Let's look at the *old 32-bit binary* from IDA. If we open =engine.so=, where
=CL_Move= is located, we can search for the function by looking for the strings
that it uses, and jumping to their xrefs. Then, we can hit the almighty =F5= key
to decompile the function.

[[file:../img/bsendpacket1.png]]

I renamed the variables on the decompiler window (right split), but it should be
pretty clear what does what by comparing it with the source. As we can see by
the opcode bytes on the left split (/Options > General > Number of opcode bytes/),
it's setting =esi= (=bSendPacket=) to true by moving the /immediate/ value =0x00000001=
(note that this is [[https://en.wikipedia.org/wiki/Endianness][little endian]]).

We could get a pointer to where those =01 00 00 00= bytes are in memory, and then
cast it to a =bool*=. To do this, we could, for example, look for a signature in
the game's memory (see my [[file:../programming/signature-scanning.org][Signature Scanning in C]] entry). Once we have this
pointer, we could use it for controlling the packet flow, right?  Not really.

** Flaws with this approach
:PROPERTIES:
:CUSTOM_ID: flaws-with-this-approach
:END:

This approach has a couple of flaws. The first one is that we can't force it to
true, just to false. If we leave it as it was (true), the game might set it to
false later in the function. This is not a problem in our case, but it's
something to keep in mind.

Another problem is that, if we look at the position of the value we are changing
and the position where =CL_Move= calls =CHLClient::CreateMove=, we can see that we
are overwriting the bytes of an instruction that *has already been executed in
this tick*. Therefore, our change will affect the next tick. This is a problem
that I didn't realize until the game updated to 64-bits, and it has probably
caused me a lot of unusual trouble before.

* The new problem
:PROPERTIES:
:CUSTOM_ID: the-new-problem
:END:

Let's have a look at =CL_Move= after the 64-bit update. Again, we search for
strings and check the xrefs.

[[file:../img/bsendpacket2.png]]

We can see that it's moving moving =ebx= (=v3=) into =r12d= (=bSendPacket=), but how do
we know that it's setting it to true?  Let's scroll up a bit.

[[file:../img/bsendpacket3.png]]

As you can see, it's moving the value returned by =sub_5376C0= (=eax=) into =ebx=. If
the =test al, al= is zero (function returned false), it jumps to =loc_47A007=, which
just returns.

The fact that it's moving /true/ from a register instead of an immediate value is
a slight problem, since we can't just patch some =01 00 00 00= bytes. The opcode
bytes for the =mov= instruction are now =41 89 DC=, but we /could/ still patch it.

If we look at the general purpose registers for =x86_64=, we can see that =r12d= is
the *double-word* version of the =r12= register.

| Quad-word | Double-word | Word | Upper byte | Lower byte |
|-----------+-------------+------+------------+------------|
| =rax=       | =eax=         | =ax=   | =ah=         | =al=         |
| =rbx=       | =ebx=         | =bx=   | =bh=         | =bl=         |
| ...       | ...         | ...  | ...        | ...        |
| =r12=       | =r12d=        | =r12w= | /None/       | =r12b=       |

We might be able to find another 3-byte instruction that we can write
there. After a wild guess, I found that =mov r12b, 1= does exactly what we want,
since =bSendPacket= can only be one or zero, and the instruction is only 3 bytes:
=41 b4 01=.

However, as I mentioned before, this solution does not solve the flaws of the
old 32-bit version. We still can't force it to true, and it will only apply for
the next tick, not the current one. Furthermore, it has another disadvantage
compared to the old: Since the instruction is 3 bytes long, and it's not an
immediate value, we can't treat it as a =bool*= like we did before.

* An alternative to opcode patching
:PROPERTIES:
:CUSTOM_ID: an-alternative-to-opcode-patching
:END:

First, we can see that, throughout =CL_Move=, the =r12= register is not used for
anything other than =bSendPacket=. If we look at the System V AMD64 ABI
([[https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI][Wikipedia]], [[https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf][PDF]]), we can read the following:

#+begin_quote
*System V AMD64 ABI - 3.2.1 Registers and the Stack Frame*

Registers =rbp=, =rbx= and =r12= through =r15= "belong" to the calling function and the
called function is required to preserve their values. In other words, a called
function must preserve these registers' values for its caller.
#+end_quote

That's good news. That means that /theoretically/, if the functions between
=ClientModeShared::CreateMove= and =CL_Move= don't use =r12=, it would remain
unchanged. On the other hand, if a child function want's to modify =r12=
(=bSendPacket=) it will have to push it onto the stack, and pop it before
returning.

And more good news, if we look at the source of =CL_Move=, we can see that the
[[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2178-L2192][=bSendPacket= checks]] happen after the [[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2165-L2169][=CHLClient::CreateMove= call]] is made. That
means we could change the value of =bSendPacket= and the changes would take effect
on the current tick.

Let's hope for the best and start looking at each function.

** Finding and analyzing =CHLClient::CreateMove=
:PROPERTIES:
:CUSTOM_ID: finding-and-analyzing-chlclient-createmove
:END:

If we open the 64-bit =client.so= in IDA, we can go to the =CHLClient=
[[https://en.wikipedia.org/wiki/Virtual_method_table][Virtual Method Table]] (VMT) thanks to to [[https://en.wikipedia.org/wiki/Run-time_type_information][RTTI]] and start checking those
functions. Some plugin like [[https://sourceforge.net/projects/idafunctionstringassociate/][Function String Associate]] might come in handy for
looking at the strings in surrounding functions from the VMT.

After a bit of decompiling, we can find that it's on index 21 (since
=(0x26B2178-0x26B20D0)/8= is 21).

[[file:../img/bsendpacket4.png]]

As you can see, it matches the source of [[https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/game/client/cdll_client_int.cpp#L1448][=CHLClient::CreateMove=]]. We can
probably tell that =off_2D65868[0]= is =CInput=, since it's also passing it as the
=thisptr= parameter.

If we look at the actual disassembly, we find some bad news.

[[file:../img/bsendpacket5.png]]

Indeed, the =r12= register is being pushed to the stack and then used as a local
variable for this function. Well... Shit.

Not all is lost, though. It would have been easy to just modify the unchanged
=r12= register, but we can still access its value *from the stack*.

* Understanding the stack
:PROPERTIES:
:CUSTOM_ID: understanding-the-stack
:END:

Before trying to find the variable, we have to understand how the stack
works. If you think already know how it works, you can skip to
[[Finding the right offset in the stack][Finding the right offset in the stack]].

First, a brief description of the [[https://en.wikipedia.org/wiki/Call_stack][stack]]. The stack is a data structure used for
storing various kinds of information required by the active procedures of a
computer program. The stack obviously follows a [[https://en.wikipedia.org/wiki/Stack_(abstract_data_type)][LIFO]] system, and it's usually
accessed by /pushing/ or /popping/ data (although this is not always the case, as we
will see). The stack usually *grows downwards*, which is a key detail that might
be easy to forget at first.

There are two very important registers when dealing with the stack. The =rsp=
register (stack pointer) always points to the top of the stack, and the =rbp=
register (base pointer) is used to delimit stack frames (more on this
bellow). The =rip= register will be mentioned as well, since it points to the
address of the next instruction to the one being executed.

When a value is /pushed/ onto the stack the =rsp= register is decremented, *and then*
the value is moved onto the top of the stack. Therefore, the =rsp= register always
points to the last pushed item. Remember that the stack (usually) grows
downwards.

When a value is /popped/ from the stack, the value on top of the stack is moved
into the specified register and the =rsp= register is incremented.

** Main uses of the stack
:PROPERTIES:
:CUSTOM_ID: main-uses-of-the-stack
:END:

The stack is used mainly for 3 purposes:

1. Storing some or all of the function arguments.
2. Storing the return address when calling a function.
3. Storing data local to the function (preserved registers, local variables,
   etc.).

When function =foo= wants to call function =bar=, it will push some of the arguments
on the stack (this depends on the architecture). Then, it will push the address
of the next instruction (=rip= register) onto the stack, so =bar= knows where to
return once it's done. Then, after =foo= calls =bar=, =bar= might push some of the
registers that need to be preserved by the callee, like =rbp= or =r12=, and it will
allocate some space for storing its data, if needed. This will be explained in
more detail bellow, with an example.

These kind of details are specified in the Application Binary Interface (ABI) of
each architecture. For example, about the pushed arguments in =x86_64=, we can
find the following.

#+begin_quote
*System V AMD64 ABI - 3.2.3 Parameter Passing*

Once arguments are classified, the registers get assigned (in left-to-right
order) for passing as follows:

1. If the class is MEMORY, pass the argument on the stack.

2. If the class is INTEGER, the next available register of the sequence =rdi=,
   =rsi=, =rdx=, =rcx=, =r8= and =r9= is used.

3. [...]

If there are no registers available for any eightbyte of an argument, the whole
argument is passed on the stack.
#+end_quote

And about pushing the return address, we can also read the following.

#+begin_quote
*System V AMD64 ABI - 3.2.1 Registers and the Stack Frame*

If a calling function wants to preserve such a register value across a function
call, it must save the value in its local stack frame.
#+end_quote

Note that the return address is usually pushed *implicitly* by the =call=
instruction. The following would be equivalent.

#+begin_src nasm
; The following:
call    0xDEADBEEF

; Internally does:
push    rip
jmp     0xDEADBEEF
#+end_src

Note that in the example above, =rip= would point to the =jmp= instruction itself,
which is not accurate. The correct version would be:

#+begin_src nasm
push    next
jmp     0xDEADBEEF

next: nop  ; Continue execution...
#+end_src

Just like the return address is pushed implicitly, it's also popped implicitly
by the =ret= instruction.

#+begin_src nasm
; The following
ret

; Internally does (without actually writing to RAX)
pop     rax
jmp     rax

; Or simply (although we can't directly write to RIP)
pop     rip
#+end_src

** Stack frames
:PROPERTIES:
:CUSTOM_ID: stack-frames
:END:

The term /stack frame/ has been mentioned a few times, so let me explain exactly
what it is. A stack frame is used to *divide the stack* depending on the
subroutine that owns/needs the information. The Wikipedia page has a very good
diagram for visualizing how a stack frame is organized.

[[file:../img/bsendpacket7.png]]

The diagram shows the call stack layout for an upward-growing stack after the
=DrawSquare= subroutine (shown in blue) called =DrawLine= (shown in green), which is
the currently executing routine.

When =DrawSquare= wants to call =DrawLine=, it pushes its arguments onto the
stack. Those belong to the stack frame of =DrawLine=. Then, as I mentioned, the
=call= instruction will push the return address onto the stack (i.e. =rip=, which
would contain the next instruction of =DrawSquare=). Then, =DrawLine= is free to
push or allocate space on the stack for his local variables.

Usually, we preserve the =rbp= register (containing the base pointer of the
caller) by pushing it onto the stack itself. Then, the current value of =rsp= is
saved there throughout the execution of our procedure. That's why the following
pattern is a common way of identifying functions from assembly.

#+begin_src nasm
func:
    push    rbp
    mov     rbp, rsp

    ; ...

    mov     rsp, rbp
    pop     rbp
    ret
#+end_src

A more detailed example will be provided bellow.

In the last example, the stack grew upwards, which is not normally the case. The
next one (from the ABI) shows a more realistic (but perhaps more confusing)
version, where the top of the stack is in a lower address than the bottom.

[[file:../img/bsendpacket8.png]]

As an example, let's write some of the assembly that =DrawLine= could be using.

#+begin_comment
TODO: Remove code comments, add "legend" bellow.
#+end_comment

In the following code, =DrawLine= pushes the base pointer (=rbp=) for *preserving the
caller's stack frame*. Then, it saves the value of =rsp= in =rbp=, creating its own
stack frame. This allows us to freely change =rsp=, while being able to access
function arguments and local variables with offsets relative to =rbp=. This might
seem a bit confusing at first, but it's a key detail since it essentially
creates a *linked list*, where you can follow =rbp='s to traverse stack frames.

#+begin_src nasm
DrawLine:
    ; Right when we got called, RSP points to return address in DrawSquare, and
    ; the DrawLine arguments are right bellow it, from [RSP+8] to [RSP+(n*8)].

    ; The first thing we usually do is push the old RBP value that DrawSquare
    ; was using. After pushing, RSP will point to the old RBP, therefore the
    ; mentioned "linked list" of RBP's. The return address will be at [RSP+8]
    push    rbp

    ; The current value of RSP is saved into RBP, creating our stack frame. This
    ; way, we can freely change RSP, and access parameters with stack offsets
    ; relative to RBP.
    mov     rbp, rsp

    ; Perhaps DrawLine needs to push some registers that the callee must
    ; preserve.
    push    rbx
    push    r12

    ; And maybe it subtract from RSP to allocate some space for local variables.
    sub     rsp, 0x20

    ; The real body of the procedure starts... The procedure can safely use
    ; preserved registers like r12.
    ; --------------------------------------------------------------------------

    ; Then, the procedure body might access the function arguments by adding to
    ; RBP, or it might need to store values in the reserved stack space, and
    ; access them by subtracting to RBP (e.g. for local variables).
    ; Here, it "jumps" over the pused RBP and the return address to access some
    ; argument, and saves it into r12. Then, it saves that value into some of
    ; the stack space that we reserved when subtracting from RSP.
    mov     r12, [rbp + 0x16]
    mov     [rbp - 0x8], r12

    ; --------------------------------------------------------------------------
    ; The body of the procedure ends...

    ; We can add back the space we reserved to RSP
    add     rsp, 0x20

    ; Then, we can pop the registers that had to be preserved by the callee
    pop     r12
    pop     rbx

    ; Then, we can restore the base pointer into RSP
    mov     rsp, rbp

    ; And pop the caller's RBP register
    pop     rbp

    ; Finally, RSP points to the return address from DrawSquare, the ret
    ; instruction will pop it and jump to it.
    ret
#+end_src

* Finding the right offset in the stack
:PROPERTIES:
:CUSTOM_ID: finding-the-right-offset-in-the-stack
:END:

TODO

* Getting the value with an assembly proxy
:PROPERTIES:
:CUSTOM_ID: getting-the-value-with-an-assembly-proxy
:END:

TODO

* Getting the value using GCC's built-ins
:PROPERTIES:
:CUSTOM_ID: getting-the-value-using-gccs-built-ins
:END:

TODO

#+begin_comment
https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html
#+end_comment
