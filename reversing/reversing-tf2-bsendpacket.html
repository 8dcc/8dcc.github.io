<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Reversing TF2's bSendPacket</title>
<meta name="author" content="8dcc" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/x-icon" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../css/main.css">
</head>
<body>
<div id="content" class="content">
<h1 class="title">Reversing TF2's bSendPacket</h1>
<p>
<a href="../index.html">Index</a> | <a href="index.html">Up</a>
</p>

<hr />

<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#the-problem">2. The problem</a></li>
<li><a href="#the-old-solution">3. The old solution</a>
<ul>
<li><a href="#flaws-with-this-approach">3.1. Flaws with this approach</a></li>
</ul>
</li>
<li><a href="#the-new-problem">4. The new problem</a></li>
<li><a href="#an-alternative-to-opcode-patching">5. An alternative to opcode patching</a>
<ul>
<li><a href="#finding-and-analyzing-chlclient-createmove">5.1. Finding and analyzing <code>CHLClient::CreateMove</code></a></li>
</ul>
</li>
<li><a href="#understanding-the-stack">6. Understanding the stack</a>
<ul>
<li><a href="#main-uses-of-the-stack">6.1. Main uses of the stack</a></li>
<li><a href="#stack-frames">6.2. Stack frames</a></li>
</ul>
</li>
<li><a href="#finding-the-right-offset-in-the-stack">7. Finding the right offset in the stack</a></li>
<li><a href="#getting-the-value-with-an-assembly-proxy">8. Getting the value with an assembly proxy</a></li>
<li><a href="#getting-the-value-using-gccs-built-ins">9. Getting the value using GCC's built-ins</a></li>
</ul>
</div>
</div>

<div id="outline-container-introduction" class="outline-2">
<h2 id="introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
Team Fortress 2 (TF2) is a 2007 multiplayer first-person shooter game developed
and published by Valve Corporation (<a href="https://en.wikipedia.org/wiki/Team_Fortress_2">Wikipedia</a>).
</p>

<p>
On <a href="https://github.com/8dcc/tf2-cheat/commit/0daa5bb7b03abf0ae8b150312f0147eb7ef5a148">Aug 6, 2023</a>, I started working on a TF2 cheat for GNU/Linux, and in over 600
commits, I was pretty happy with the result.
</p>

<p>
However, on April 19, 2024 (just a few days before writing this), Valve released
a 64-bit update. For windows, this just meant an extra architecture, but on
GNU/Linux, they entirely removed the 32-bit binaries. I decided to archive the
repository and continue developing the cheat privately.
</p>

<p>
One of the main reasons for this decision was that I wanted to avoid essentially
releasing fixes for the cheat, that would get used by people who are just
interested in copy-pasting a working cheat and selling it, or making <a href="https://www.theverge.com/2022/5/27/23144061/valve-team-fortress-2-bot-problem-savetf2-spam">bots</a>. As I
explained in the repository's README, I made this project because I enjoyed
reversing the game in a platform with not much reference, and I enjoyed the low
level aspect of essentially having to do all the "dirty work" of reversing the
game and making everything work.
</p>

<p>
However, It is not fair to say that I was the only one involved, and obviously
some people did help me greatly. I just want to quickly mention <a href="https://github.com/Lak3">Lak3</a> for his
time and help, and <a href="https://github.com/nepcat">nepcat</a> for his helpful PRs, and his interest in the project.
</p>

<p>
Now that this long introduction is finished, we can get to finding <code>bSendPacket</code>.
</p>
</div>
</div>

<div id="outline-container-the-problem" class="outline-2">
<h2 id="the-problem"><span class="section-number-2">2.</span> The problem</h2>
<div class="outline-text-2" id="text-the-problem">
<p>
First, in case the reader is unfamiliar with game hacking in the source engine,
I need to briefly explain what <code>bSendPacket</code> is used for.
</p>

<p>
In the source engine, we run a lot of our hacks from the <code>CreateMove</code> hook (for
more information about hooking in general, see my <a href="../programming/detour-hooking.html">Detour Hooking</a>
entry). However, there is not just one <code>CreateMove</code>, and some people choose to
hook one over the other. In my case, I have always hooked
<code>ClientModeShared::CreateMove</code>.
</p>

<p>
Let's have a look at where this is called by looking at the <a href="https://github.com/OthmanAba/TeamFortress2">leaked TF2 source</a>.
</p>

<ol class="org-ol">
<li>Our <code>ClientModeShared::CreateMove</code> function is defined in
<a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/game/client/clientmode_shared.cpp#L417"><code>clientmode_shared.cpp</code></a>. As you can see, it calls another <code>CreateMove</code>
function, but we don't care about that one.</li>
<li>This <code>ClientModeShared::CreateMove</code> function is called from <code>CInput::CreateMove</code>,
defined in <a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/game/client/in_main.cpp#L1111"><code>in_main.cpp</code></a>. You can see it calls it from a <code>g_pClientMode</code> global
pointer.</li>
<li>This <code>CInput::CreateMove</code> function is called from <code>CHLClient::CreateMove</code>,
defined in <a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/game/client/cdll_client_int.cpp#L1448"><code>cdll_client_int.cpp</code></a>.</li>
<li>Finally, this <code>CHLClient::CreateMove</code> function is called from <code>CL_Move</code>, defined
in <a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2119"><code>cl_main.cpp</code></a>.</li>
</ol>

<p>
So, in order, the calls would be the following:
</p>

<pre class="example" id="org9ca486a">
CL_Move()  -&gt;  CHLClient::CreateMove()  -&gt;  CInput::CreateMove()  -&gt;  ClientModeShared::CreateMove()
</pre>

<p>
Okay, but why is this important? Let's have a look at this last function,
<code>CL_Move</code>. It defines a <a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2130">local variable</a> called <code>bSendPacket</code>, which will later <a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2178-L2188">decide</a>
if the current command should be sent or, on the other hand, choked. Being able
to control which packets are sent and which ones aren't is extremely useful for
us, so we need to find a way of changing its value.
</p>

<p>
As I said, this is a <b>local variable</b>, so we can't just treat it as a global and
get a pointer to it. This variable is declared within the <a href="https://en.wikipedia.org/wiki/Call_stack#STACK-FRAME">stack frame</a> of
<code>CL_Move</code>, and only exists throughout its life cycle (this will be explained
bellow in more detail). We will need to find a way of somehow tricking <code>CL_Move</code>
into thinking that this variable has the value we want it to have, and ideally
do that from <code>ClientModeShared::CreateMove</code>.
</p>
</div>
</div>

<div id="outline-container-the-old-solution" class="outline-2">
<h2 id="the-old-solution"><span class="section-number-2">3.</span> The old solution</h2>
<div class="outline-text-2" id="text-the-old-solution">
<p>
When I started developing my cheat for the 32-bit game, I came across an
(almost) valid solution.
</p>

<p>
Since <code>CL_Move</code> only sets <code>bSendPacket</code> to true on <a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2130">once place</a>, we could just
overwrite this constant in memory, so that it gets initialized to true only
whenever we want.
</p>

<p>
Let's look at the <b>old 32-bit binary</b> from IDA. If we open <code>engine.so</code>, where
<code>CL_Move</code> is located, we can search for the function by looking for the strings
that it uses, and jumping to their xrefs. Then, we can hit the almighty <code>F5</code> key
to decompile the function.
</p>


<div id="org711902f" class="figure">
<p><img src="../img/bsendpacket1.png" alt="bsendpacket1.png" />
</p>
</div>

<p>
I renamed the variables on the decompiler window (right split), but it should be
pretty clear what does what by comparing it with the source. As we can see by
the opcode bytes on the left split (<i>Options &gt; General &gt; Number of opcode bytes</i>),
it's setting <code>esi</code> (<code>bSendPacket</code>) to true by moving the <i>immediate</i> value <code>0x00000001</code>
(note that this is <a href="https://en.wikipedia.org/wiki/Endianness">little endian</a>).
</p>

<p>
We could get a pointer to where those <code>01 00 00 00</code> bytes are in memory, and then
cast it to a <code>bool*</code>. To do this, we could, for example, look for a signature in
the game's memory (see my <a href="../programming/signature-scanning.html">Signature Scanning in C</a> entry). Once we have this
pointer, we could use it for controlling the packet flow, right?  Not really.
</p>
</div>

<div id="outline-container-flaws-with-this-approach" class="outline-3">
<h3 id="flaws-with-this-approach"><span class="section-number-3">3.1.</span> Flaws with this approach</h3>
<div class="outline-text-3" id="text-flaws-with-this-approach">
<p>
This approach has a couple of flaws. The first one is that we can't force it to
true, just to false. If we leave it as it was (true), the game might set it to
false later in the function. This is not a problem in our case, but it's
something to keep in mind.
</p>

<p>
Another problem is that, if we look at the position of the value we are changing
and the position where <code>CL_Move</code> calls <code>CHLClient::CreateMove</code>, we can see that we
are overwriting the bytes of an instruction that <b>has already been executed in
this tick</b>. Therefore, our change will affect the next tick. This is a problem
that I didn't realize until the game updated to 64-bits, and it has probably
caused me a lot of unusual trouble before.
</p>
</div>
</div>
</div>

<div id="outline-container-the-new-problem" class="outline-2">
<h2 id="the-new-problem"><span class="section-number-2">4.</span> The new problem</h2>
<div class="outline-text-2" id="text-the-new-problem">
<p>
Let's have a look at <code>CL_Move</code> after the 64-bit update. Again, we search for
strings and check the xrefs.
</p>


<div id="org95cbf48" class="figure">
<p><img src="../img/bsendpacket2.png" alt="bsendpacket2.png" />
</p>
</div>

<p>
We can see that it's moving moving <code>ebx</code> (<code>v3</code>) into <code>r12d</code> (<code>bSendPacket</code>), but how do
we know that it's setting it to true?  Let's scroll up a bit.
</p>


<div id="org36b2657" class="figure">
<p><img src="../img/bsendpacket3.png" alt="bsendpacket3.png" />
</p>
</div>

<p>
As you can see, it's moving the value returned by <code>sub_5376C0</code> (<code>eax</code>) into <code>ebx</code>. If
the <code>test al, al</code> is zero (function returned false), it jumps to <code>loc_47A007</code>, which
just returns.
</p>

<p>
The fact that it's moving <i>true</i> from a register instead of an immediate value is
a slight problem, since we can't just patch some <code>01 00 00 00</code> bytes. The opcode
bytes for the <code>mov</code> instruction are now <code>41 89 DC</code>, but we <i>could</i> still patch it.
</p>

<p>
If we look at the general purpose registers for <code>x86_64</code>, we can see that <code>r12d</code> is
the <b>double-word</b> version of the <code>r12</code> register.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Quad-word</th>
<th scope="col" class="org-left">Double-word</th>
<th scope="col" class="org-left">Word</th>
<th scope="col" class="org-left">Upper byte</th>
<th scope="col" class="org-left">Lower byte</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left"><code>eax</code></td>
<td class="org-left"><code>ax</code></td>
<td class="org-left"><code>ah</code></td>
<td class="org-left"><code>al</code></td>
</tr>

<tr>
<td class="org-left"><code>rbx</code></td>
<td class="org-left"><code>ebx</code></td>
<td class="org-left"><code>bx</code></td>
<td class="org-left"><code>bh</code></td>
<td class="org-left"><code>bl</code></td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
</tr>

<tr>
<td class="org-left"><code>r12</code></td>
<td class="org-left"><code>r12d</code></td>
<td class="org-left"><code>r12w</code></td>
<td class="org-left"><i>None</i></td>
<td class="org-left"><code>r12b</code></td>
</tr>
</tbody>
</table>

<p>
We might be able to find another 3-byte instruction that we can write
there. After a wild guess, I found that <code>mov r12b, 1</code> does exactly what we want,
since <code>bSendPacket</code> can only be one or zero, and the instruction is only 3 bytes:
<code>41 b4 01</code>.
</p>

<p>
However, as I mentioned before, this solution does not solve the flaws of the
old 32-bit version. We still can't force it to true, and it will only apply for
the next tick, not the current one. Furthermore, it has another disadvantage
compared to the old: Since the instruction is 3 bytes long, and it's not an
immediate value, we can't treat it as a <code>bool*</code> like we did before.
</p>
</div>
</div>

<div id="outline-container-an-alternative-to-opcode-patching" class="outline-2">
<h2 id="an-alternative-to-opcode-patching"><span class="section-number-2">5.</span> An alternative to opcode patching</h2>
<div class="outline-text-2" id="text-an-alternative-to-opcode-patching">
<p>
First, we can see that, throughout <code>CL_Move</code>, the <code>r12</code> register is not used for
anything other than <code>bSendPacket</code>. If we look at the System V AMD64 ABI
(<a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">Wikipedia</a>, <a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">PDF</a>), we can read the following:
</p>

<blockquote>
<p>
<b>System V AMD64 ABI - 3.2.1 Registers and the Stack Frame</b>
</p>

<p>
Registers <code>rbp</code>, <code>rbx</code> and <code>r12</code> through <code>r15</code> "belong" to the calling function and the
called function is required to preserve their values. In other words, a called
function must preserve these registers' values for its caller.
</p>
</blockquote>

<p>
That's good news. That means that <i>theoretically</i>, if the functions between
<code>ClientModeShared::CreateMove</code> and <code>CL_Move</code> don't use <code>r12</code>, it would remain
unchanged. On the other hand, if a child function want's to modify <code>r12</code>
(<code>bSendPacket</code>) it will have to push it onto the stack, and pop it before
returning.
</p>

<p>
And more good news, if we look at the source of <code>CL_Move</code>, we can see that the
<a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2178-L2192"><code>bSendPacket</code> checks</a> happen after the <a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/engine/cl_main.cpp#L2165-L2169"><code>CHLClient::CreateMove</code> call</a> is made. That
means we could change the value of <code>bSendPacket</code> and the changes would take effect
on the current tick.
</p>

<p>
Let's hope for the best and start looking at each function.
</p>
</div>

<div id="outline-container-finding-and-analyzing-chlclient-createmove" class="outline-3">
<h3 id="finding-and-analyzing-chlclient-createmove"><span class="section-number-3">5.1.</span> Finding and analyzing <code>CHLClient::CreateMove</code></h3>
<div class="outline-text-3" id="text-finding-and-analyzing-chlclient-createmove">
<p>
If we open the 64-bit <code>client.so</code> in IDA, we can go to the <code>CHLClient</code>
<a href="https://en.wikipedia.org/wiki/Virtual_method_table">Virtual Method Table</a> (VMT) thanks to to <a href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a> and start checking those
functions. Some plugin like <a href="https://sourceforge.net/projects/idafunctionstringassociate/">Function String Associate</a> might come in handy for
looking at the strings in surrounding functions from the VMT.
</p>

<p>
After a bit of decompiling, we can find that it's on index 21 (since
<code>(0x26B2178-0x26B20D0)/8</code> is 21).
</p>


<div id="orgc015b85" class="figure">
<p><img src="../img/bsendpacket4.png" alt="bsendpacket4.png" />
</p>
</div>

<p>
As you can see, it matches the source of <a href="https://github.com/OthmanAba/TeamFortress2/blob/1b81dded673d49adebf4d0958e52236ecc28a956/tf2_src/game/client/cdll_client_int.cpp#L1448"><code>CHLClient::CreateMove</code></a>. We can
probably tell that <code>off_2D65868[0]</code> is <code>CInput</code>, since it's also passing it as the
<code>thisptr</code> parameter.
</p>

<p>
If we look at the actual disassembly, we find some bad news.
</p>


<div id="org5b0c718" class="figure">
<p><img src="../img/bsendpacket5.png" alt="bsendpacket5.png" />
</p>
</div>

<p>
Indeed, the <code>r12</code> register is being pushed to the stack and then used as a local
variable for this function. Well&#x2026; Shit.
</p>

<p>
Not all is lost, though. It would have been easy to just modify the unchanged
<code>r12</code> register, but we can still access its value <b>from the stack</b>.
</p>
</div>
</div>
</div>

<div id="outline-container-understanding-the-stack" class="outline-2">
<h2 id="understanding-the-stack"><span class="section-number-2">6.</span> Understanding the stack</h2>
<div class="outline-text-2" id="text-understanding-the-stack">
<p>
Before trying to find the variable, we have to understand how the stack
works. If you think already know how it works, you can skip to
<a href="#finding-the-right-offset-in-the-stack">Finding the right offset in the stack</a>.
</p>

<p>
First, a brief description of the <a href="https://en.wikipedia.org/wiki/Call_stack">stack</a>. The stack is a data structure used for
storing various kinds of information required by the active procedures of a
computer program. The stack obviously follows a <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">LIFO</a> system, and it's usually
accessed by <i>pushing</i> or <i>popping</i> data (although this is not always the case, as we
will see). The stack usually <b>grows downwards</b>, which is a key detail that might
be easy to forget at first.
</p>

<p>
There are two very important registers when dealing with the stack. The <code>rsp</code>
register (stack pointer) always points to the top of the stack, and the <code>rbp</code>
register (base pointer) is used to delimit stack frames (more on this
bellow). The <code>rip</code> register will be mentioned as well, since it points to the
address of the next instruction to the one being executed.
</p>

<p>
When a value is <i>pushed</i> onto the stack the <code>rsp</code> register is decremented, <b>and then</b>
the value is moved onto the top of the stack. Therefore, the <code>rsp</code> register always
points to the last pushed item. Remember that the stack (usually) grows
downwards.
</p>

<p>
When a value is <i>popped</i> from the stack, the value on top of the stack is moved
into the specified register and the <code>rsp</code> register is incremented.
</p>
</div>

<div id="outline-container-main-uses-of-the-stack" class="outline-3">
<h3 id="main-uses-of-the-stack"><span class="section-number-3">6.1.</span> Main uses of the stack</h3>
<div class="outline-text-3" id="text-main-uses-of-the-stack">
<p>
The stack is used mainly for 3 purposes:
</p>

<ol class="org-ol">
<li>Storing some or all of the function arguments.</li>
<li>Storing the return address when calling a function.</li>
<li>Storing data local to the function (preserved registers, local variables,
etc.).</li>
</ol>

<p>
When function <code>foo</code> wants to call function <code>bar</code>, it will push some of the arguments
on the stack (this depends on the architecture). Then, it will push the address
of the next instruction (<code>rip</code> register) onto the stack, so <code>bar</code> knows where to
return once it's done. Then, after <code>foo</code> calls <code>bar</code>, <code>bar</code> might push some of the
registers that need to be preserved by the callee, like <code>rbp</code> or <code>r12</code>, and it will
allocate some space for storing its data, if needed. This will be explained in
more detail bellow, with an example.
</p>

<p>
These kind of details are specified in the Application Binary Interface (ABI) of
each architecture. For example, about the pushed arguments in <code>x86_64</code>, we can
find the following.
</p>

<blockquote>
<p>
<b>System V AMD64 ABI - 3.2.3 Parameter Passing</b>
</p>

<p>
Once arguments are classified, the registers get assigned (in left-to-right
order) for passing as follows:
</p>

<ol class="org-ol">
<li>If the class is MEMORY, pass the argument on the stack.</li>

<li>If the class is INTEGER, the next available register of the sequence <code>rdi</code>,
<code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code> and <code>r9</code> is used.</li>

<li>[&#x2026;]</li>
</ol>

<p>
If there are no registers available for any eightbyte of an argument, the whole
argument is passed on the stack.
</p>
</blockquote>

<p>
And about pushing the return address, we can also read the following.
</p>

<blockquote>
<p>
<b>System V AMD64 ABI - 3.2.1 Registers and the Stack Frame</b>
</p>

<p>
If a calling function wants to preserve such a register value across a function
call, it must save the value in its local stack frame.
</p>
</blockquote>

<p>
Note that the return address is usually pushed <b>implicitly</b> by the <code>call</code>
instruction. The following would be equivalent.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #989898;">; </span><span style="color: #989898;">The following:</span>
<span style="color: #feacd0;">call</span>    <span style="color: #88ca9f;">0xDEADBEEF</span>

<span style="color: #989898;">; </span><span style="color: #989898;">Internally does:</span>
<span style="color: #feacd0;">push</span>    rip
<span style="color: #feacd0;">jmp</span>     <span style="color: #88ca9f;">0xDEADBEEF</span>
</pre>
</div>

<p>
Note that in the example above, <code>rip</code> would point to the <code>jmp</code> instruction itself,
which is not accurate. The correct version would be:
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #feacd0;">push</span>    next
<span style="color: #feacd0;">jmp</span>     <span style="color: #88ca9f;">0xDEADBEEF</span>

<span style="color: #4ae2ff;">next</span>: <span style="color: #feacd0;">nop</span>  <span style="color: #989898;">; </span><span style="color: #989898;">Continue execution...</span>
</pre>
</div>

<p>
Just like the return address is pushed implicitly, it's also popped implicitly
by the <code>ret</code> instruction.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #989898;">; </span><span style="color: #989898;">The following</span>
<span style="color: #feacd0;">ret</span>

<span style="color: #989898;">; </span><span style="color: #989898;">Internally does (without actually writing to RAX)</span>
<span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">rax</span>
<span style="color: #feacd0;">jmp</span>     <span style="color: #6ae4b9;">rax</span>

<span style="color: #989898;">; </span><span style="color: #989898;">Or simply (although we can't directly write to RIP)</span>
<span style="color: #feacd0;">pop</span>     rip
</pre>
</div>
</div>
</div>

<div id="outline-container-stack-frames" class="outline-3">
<h3 id="stack-frames"><span class="section-number-3">6.2.</span> Stack frames</h3>
<div class="outline-text-3" id="text-stack-frames">
<p>
The term <i>stack frame</i> has been mentioned a few times, so let me explain exactly
what it is. A stack frame is used to <b>divide the stack</b> depending on the
subroutine that owns/needs the information. The Wikipedia page has a very good
diagram for visualizing how a stack frame is organized.
</p>


<div id="org21e10a1" class="figure">
<p><img src="../img/bsendpacket7.png" alt="bsendpacket7.png" />
</p>
</div>

<p>
The diagram shows the call stack layout for an upward-growing stack after the
<code>DrawSquare</code> subroutine (shown in blue) called <code>DrawLine</code> (shown in green), which is
the currently executing routine.
</p>

<p>
When <code>DrawSquare</code> wants to call <code>DrawLine</code>, it pushes its arguments onto the
stack. Those belong to the stack frame of <code>DrawLine</code>. Then, as I mentioned, the
<code>call</code> instruction will push the return address onto the stack (i.e. <code>rip</code>, which
would contain the next instruction of <code>DrawSquare</code>). Then, <code>DrawLine</code> is free to
push or allocate space on the stack for his local variables.
</p>

<p>
Usually, we preserve the <code>rbp</code> register (containing the base pointer of the
caller) by pushing it onto the stack itself. Then, the current value of <code>rsp</code> is
saved there throughout the execution of our procedure. That's why the following
pattern is a common way of identifying functions from assembly.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #4ae2ff;">func</span>:
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">rbp</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rbp</span>, <span style="color: #6ae4b9;">rsp</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">...</span>

    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rsp</span>, <span style="color: #6ae4b9;">rbp</span>
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">rbp</span>
    <span style="color: #feacd0;">ret</span>
</pre>
</div>

<p>
A more detailed example will be provided bellow.
</p>

<p>
In the last example, the stack grew upwards, which is not normally the case. The
next one (from the ABI) shows a more realistic (but perhaps more confusing)
version, where the top of the stack is in a lower address than the bottom.
</p>


<div id="orgf427ef0" class="figure">
<p><img src="../img/bsendpacket8.png" alt="bsendpacket8.png" />
</p>
</div>

<p>
As an example, let's write some of the assembly that <code>DrawLine</code> could be using.
</p>

<p>
In the following code, <code>DrawLine</code> pushes the base pointer (<code>rbp</code>) for <b>preserving the
caller's stack frame</b>. Then, it saves the value of <code>rsp</code> in <code>rbp</code>, creating its own
stack frame. This allows us to freely change <code>rsp</code>, while being able to access
function arguments and local variables with offsets relative to <code>rbp</code>. This might
seem a bit confusing at first, but it's a key detail since it essentially
creates a <b>linked list</b>, where you can follow <code>rbp</code>'s to traverse stack frames.
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #4ae2ff;">DrawLine</span>:
    <span style="color: #989898;">; </span><span style="color: #989898;">Right when we got called, RSP points to return address in DrawSquare, and</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">the DrawLine arguments are right bellow it, from [RSP+8] to [RSP+(n*8)].</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">The first thing we usually do is push the old RBP value that DrawSquare</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">was using. After pushing, RSP will point to the old RBP, therefore the</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">mentioned "linked list" of RBP's. The return address will be at [RSP+8]</span>
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">rbp</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">The current value of RSP is saved into RBP, creating our stack frame. This</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">way, we can freely change RSP, and access parameters with stack offsets</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">relative to RBP.</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rbp</span>, <span style="color: #6ae4b9;">rsp</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">Perhaps DrawLine needs to push some registers that the callee must</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">preserve.</span>
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">rbx</span>
    <span style="color: #feacd0;">push</span>    <span style="color: #6ae4b9;">r12</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">And maybe it subtract from RSP to allocate some space for local variables.</span>
    <span style="color: #feacd0;">sub</span>     <span style="color: #6ae4b9;">rsp</span>, <span style="color: #88ca9f;">0x20</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">The real body of the procedure starts... The procedure can safely use</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">preserved registers like r12.</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">--------------------------------------------------------------------------</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">Then, the procedure body might access the function arguments by adding to</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">RBP, or it might need to store values in the reserved stack space, and</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">access them by subtracting to RBP (e.g. for local variables).</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">Here, it "jumps" over the pused RBP and the return address to access some</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">argument, and saves it into r12. Then, it saves that value into some of</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">the stack space that we reserved when subtracting from RSP.</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">r12</span>, [<span style="color: #6ae4b9;">rbp</span> + <span style="color: #88ca9f;">0x16</span>]
    <span style="color: #feacd0;">mov</span>     [<span style="color: #6ae4b9;">rbp</span> - <span style="color: #88ca9f;">0x8</span>], <span style="color: #6ae4b9;">r12</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">--------------------------------------------------------------------------</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">The body of the procedure ends...</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">We can add back the space we reserved to RSP</span>
    <span style="color: #feacd0;">add</span>     <span style="color: #6ae4b9;">rsp</span>, <span style="color: #88ca9f;">0x20</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">Then, we can pop the registers that had to be preserved by the callee</span>
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">r12</span>
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">rbx</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">Then, we can restore the base pointer into RSP</span>
    <span style="color: #feacd0;">mov</span>     <span style="color: #6ae4b9;">rsp</span>, <span style="color: #6ae4b9;">rbp</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">And pop the caller's RBP register</span>
    <span style="color: #feacd0;">pop</span>     <span style="color: #6ae4b9;">rbp</span>

    <span style="color: #989898;">; </span><span style="color: #989898;">Finally, RSP points to the return address from DrawSquare, the ret</span>
    <span style="color: #989898;">; </span><span style="color: #989898;">instruction will pop it and jump to it.</span>
    <span style="color: #feacd0;">ret</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-finding-the-right-offset-in-the-stack" class="outline-2">
<h2 id="finding-the-right-offset-in-the-stack"><span class="section-number-2">7.</span> Finding the right offset in the stack</h2>
<div class="outline-text-2" id="text-finding-the-right-offset-in-the-stack">
<p>
TODO
</p>
</div>
</div>

<div id="outline-container-getting-the-value-with-an-assembly-proxy" class="outline-2">
<h2 id="getting-the-value-with-an-assembly-proxy"><span class="section-number-2">8.</span> Getting the value with an assembly proxy</h2>
<div class="outline-text-2" id="text-getting-the-value-with-an-assembly-proxy">
<p>
TODO
</p>
</div>
</div>

<div id="outline-container-getting-the-value-using-gccs-built-ins" class="outline-2">
<h2 id="getting-the-value-using-gccs-built-ins"><span class="section-number-2">9.</span> Getting the value using GCC's built-ins</h2>
<div class="outline-text-2" id="text-getting-the-value-using-gccs-built-ins">
<p>
TODO
</p>
</div>
</div>
</div>
</body>
</html>
