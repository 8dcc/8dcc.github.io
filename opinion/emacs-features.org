#+TITLE: My favorite GNU/Emacs features
#+AUTHOR: 8dcc
#+OPTIONS: toc:nil
#+STARTUP: nofold
#+HTML_HEAD: <link rel="icon" type="image/x-icon" href="../img/favicon.png">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css">

[[file:../index.org][Index]] | [[file:index.org][Up]]

-----

#+TOC: headlines 2

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

[[https://www.gnu.org/software/emacs/][Emacs]] is an amazing editor. I come from [[https://neovim.io/][neovim]] and I decided to try [[https://github.com/doomemacs/doomemacs][doom emacs]]
some years ago, and decided to eventually "doom-ify" vanilla Emacs to my liking,
removing all features I didn't like or use.

As you might have heard, Emacs /is not/ a text editor, Emacs /has/ a text editor. It
has a lot of features, and it's so easy to customize and extend that it creates
an amazing environment for programming or general text editing.

With that in mind, let me say that Emacs is not really comparable to vi-like
editors... Because they are just editors. They do one thing, and they do it
really good: They let you edit text files, and very efficiently. Emacs is much
more, which can save time but might also be an overkill for some people.

I decided to make a list of some of the Emacs features/packages I enjoy the
most, mainly because I keep forgetting some stuff even exists. I am using GNU
Emacs version 29.3, in GNU/Linux.

** Quick note about vanilla keybinds
:PROPERTIES:
:CUSTOM_ID: quick-note-about-vanilla-keybinds
:END:

I don't like the vanilla GNU Emacs keybinds. At all. I don't know them and I
don't want to, even the most experienced Emacs users say they suck, and often
change them.

I use evil mode, which allows vi-like keybinds. See [[*Evil mode][Evil mode]] bellow.

See also [[https://en.wikipedia.org/wiki/Repetitive_strain_injury][RSI]], [[http://xahlee.info/kbd/typing_rsi.html][Xah Lee's RSI page]] and [[http://xahlee.info/emacs/emacs/emacs_pinky.html][Xah Lee's Emacs pinky page]].

** Quick note about keybind notation
:PROPERTIES:
:CUSTOM_ID: quick-note-about-keybind-notation
:END:

The key notation used in the Emacs context is the following.

| Key | Description                                 |
|-----+---------------------------------------------|
| =C-=  | Press and hold the Control key              |
| =M-=  | Press and hold the Meta (Alt) key           |
| =S-=  | Press and hold the Shift key                |
| =DEL= | Press the Backspace key, *not the delete key* |
| =RET= | Press the Return or Enter key               |
| =SPC= | Press the Space bar                         |
| =ESC= | Press the Escape key                        |
| =TAB= | Press the Tab key                           |

For example:

- =C-M-s= (or, equivalently, =M-C-s=): Press and hold both *Control* and *Meta* (Alt)
  keys while hitting the *s* key.
- =SPC t c=: Press *Space*, then *t* and finally *c*.
- =M-x find-file RET=: Press and hold *Meta* (Alt), hit the *x* key, type " find-file ", and press
  *Return*.

Note that =M-x ... RET= is a common pattern, since =M-x= opens the "execute command"
menu.

** Small Emacs glosary
:PROPERTIES:
:CUSTOM_ID: small-emacs-glosary
:END:

In case anyone is very new to emacs, this list might help understanding the
difference between some terms used in this page.

*** Frames, windows and buffers
:PROPERTIES:
:CUSTOM_ID: frames-windows-and-buffers
:END:

These terms have other meanings in other contexts, so it's normal to confuse
these when starting with Emacs.

- *Frame*: Top-level Emacs display element. In the DE/WM context, this would be
  referred to as a "Window", but this term has another meaning within Emacs.
- *Window*: Contained within a Frame. Basically, the splits in which your Frame is
  divided. Each Window contains a Buffer.
- *Buffer*: The actual content of a Window. It's usually an interface between
  Emacs and a file, but it's not always the case. You can have hundreds of them
  open, but you will probably be working with only a couple at a time through
  your Windows.

For more information and visual examples, see: [[https://www.emacswiki.org/emacs/WindowsAndFrames][EmacsWiki]], [[https://smythp.com/emacs_buffers/][smythp.com]].

* General design choices
:PROPERTIES:
:CUSTOM_ID: general-design-choices
:END:

** GUI vs. Terminal
:PROPERTIES:
:CUSTOM_ID: gui-vs-terminal
:END:

Emacs is a GUI program. It can be ran in a terminal, but you will be limiting
its potential. The fact that Emacs has its own window has a lot of advantages
over terminal editors like neovim.

For example, you can display inline images, open PDF files, change the font
styles (without being limited by the terminal's styles), change the fonts
themselves for certain regions, etc.

** Emacs Lisp
:PROPERTIES:
:CUSTOM_ID: emacs-lisp
:END:

Emacs uses its own dialect of [[https://en.wikipedia.org/wiki/Lisp][Lisp]] as its programming language: [[https://en.wikipedia.org/wiki/Emacs_Lisp][Emacs Lisp]].

I started looking at Lisp languages because Richard Stallman, one of the
creators of Emacs, recommended it in one of his talks. Then I found that Emacs
is made in its own Lisp dialect.

Since using Emacs, specially since switching to vanilla, I have learned a lot
about Lisp and functional programming, and I can say I don't regret it one bit.

Even if you don't use Emacs, *check out the Lisp language family*, you will learn
a lot.

Another interesting part about Emacs Lisp is its self documentation. If you go
to the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html][Emacs manual website]], you can read the following.

#+begin_quote
Emacs is the advanced, extensible, customizable, *self-documenting* editor.
#+end_quote

They are not lying. Simply press =C-h v= and start typing a variable name to
display its documentation. You can also search for functions with =C-h f=.

See also: [[https://www.gnu.org/software/emacs/manual/pdf/elisp.pdf][Emacs Lisp manual (PDF)]].

* Built-in features
:PROPERTIES:
:CUSTOM_ID: built-in-features
:END:

These packages are currently built into vanilla GNU Emacs, but this might not be
the case in older versions, so keep that in mind.

** Org mode
:PROPERTIES:
:CUSTOM_ID: org-mode
:END:

From the [[https://www.emacswiki.org/emacs/OrgMode][EmacsWiki]]:

#+begin_quote
Org-mode is an Emacs mode for note keeping, project planning, TODO lists and
authoring. It is included from Emacs 22.1 onward as default.

Features:
- Outlines: headlines, TODO items, checklists, numbered lists, searching,
  filtering
- Filing: outlines, tagging, refiling, archiving, sorting, flexible enough to
  build a “getting things done” workflow
- Timestamp: deadlines, clocking in/out, scheduled items, repeating items,
  optionally integrated with emacs calendar and diary
- Markup: bold, italic, lists, links, images, math (via LaTeX), code
  highlighting
- Links to URLs, files, gnus, rmail, vm, news, wanderlust, bbdb, irc, shell
  commands, bookmarks, images, attachments
- Table: editing, spreadsheets, formulas
- Export: HTML, LaTeX, Markdown, iCalendar, OpenDocument, Beamer slides, PDF,
  and more via an extensible exporting system
- Babel: Literate programming, reproducible research, OrgModeSQL
- Agenda: Overview of scheduled and TODO items across files
#+end_quote

It is an extremely useful markdown format, and it can be used for a variety of
things. For example, this blog itself is written in Org, and it's exported to
HTML from within Emacs.

Org-mode can also be used for [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]]. Just like in other markdown
formats, you can embed code blocks within Org files. The interesting part is
that you can [[https://orgmode.org/org.html#Evaluating-Code-Blocks-1][evaluate them]] from Emacs, and [[https://orgmode.org/org.html#Results-of-Evaluation-1][write their output]] to the same file,
for example. Or you can choose to [[https://orgmode.org/org.html#Extracting-Source-Code-1][export the code blocks]] of your Org file to
different sources, filtering by language. I use this for my [[https://github.com/8dcc/emacs-dotfiles][emacs configuration]],
and it allows me to put the code snippets between the markdown text, rather than
using very long plain comments within a single source.

[[file:../img/emacs-org.png]]

See also: [[https://orgmode.org/manuals.html][Org-mode manual]].

** GDB
:PROPERTIES:
:CUSTOM_ID: gdb
:END:

Emacs has an excellent integration with the GNU Debugger, [[https://www.sourceware.org/gdb/][gdb]]. You can run =M-x
gud-gdb=, and you can get basically what you would get by running =gdb= on a
terminal.

The good part, however, is when you integrate =gdb= with your entire editor. Try
setting the following variables, and then running =M-x gdb=.

#+begin_src emacs-lisp
; Launch in the Many Windows layout.
(setq gdb-many-windows t)

; Restore previous windows when GDB stops
(setq gdb-restore-window-configuration-after-quit 'if-gdb-many-windows)
#+end_src

Behold, the beauty of GNU Emacs (at least since version 22.1).

[[file:../img/emacs-gdb.png]]

All 6 windows have been opened by =gdb=, but don't worry, your previous layout
will be restored when you quit out of =gdb=. Let's briefly look at what each
window is doing:

1. In the top left, you can see the =gud-gdb= prompt you would get when simply
   running =M-x gud-gdb=. From there, you can run your usual =gdb= commands, like
   =break=, =run= and =continue=.
2. On the top right, you can see how your variables are updated in real
   time. You can also click on the "Registers" tab to switch to that view.
3. On the middle left, you can see the source where the current instruction is,
   which obviously gets updated whenever your program jumps to an instruction in
   a different file.
4. On the middle right, you can write the input and see the output of your
   program.
5. On the bottom left, you can see the call stack of the instruction being
   debugged. You can click on each line to jump to that position.
6. On the bottom right, you can see and interact with your breakpoints and
   threads. You can enable and disable breakpoints, jump at their positions in
   the code, etc.

If you look closely at the =gud= window, you can see that the third breakpoint was
added without a =break= command. That's because you can click the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Fringes.html][fringes]] of
source buffers to add breakpoints on those lines. The red dots represent
breakpoints, and the gray arrow represents the current instruction. If you are
wondering about the green and blue lines, they show the [[https://github.com/emacsorphanage/git-gutter-fringe][git changes]] of the
current file.

Are you [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Other-GDB-Buffers.html][missing]] the assembly window? In that case, you have my respect. From the
=gud= window (top left), you can replace the /source/ buffer (middle left) with the
/assembly/ buffer by running =M-x gdb-display-disassembly-buffer=.

You messed the windows up? No problem, simply run =M-x gdb-restore-windows=.

** Eshell
:PROPERTIES:
:CUSTOM_ID: eshell
:END:

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]] is a shell written in Emacs Lisp. It was added officially to Emacs 21.

When I first tried it, I didn't like it, because it was a bit different from
other shells like [[https://github.com/akermu/emacs-libvterm/][vterm]]. The general feeling and some particular keybinds
(e.g. =M-r= instead of =^R= for accessing the history) might feel weird at first,
but it's really nice once you get the hang of it.

Since it's a normal Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Buffers.html][buffer]], you can yank text, paste it, delete it, write
it anywhere, etc. Eshell allows you to re-run commands by pressing =RET= on a
previous line where it was called (by checking against the =eshell-prompt-regex=
variable). This also allows you to save the output of an eshell session into a
file, for example.

It's capable of running Emacs Lisp code, and calling Emacs functions. So you can
not only call normal system programs, but you can also use, for example,
=find-file a.txt= to open a file in that window.

** Grep
:PROPERTIES:
:CUSTOM_ID: grep
:END:

You can run =grep= commands from within Emacs. The basic form is with =M-x grep=,
which simply runs a grep command (or a command with a similar output) and
displays the matches in an interactive buffer.

[[file:../img/emacs-grep.png]]

You can jump to each of those lines.

The =M-x rgrep= command is one of my favorites, because it allows you to grep for
a term recursively in the specified folder.

See also [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Grep-Searching.html][GNU Emacs Manual]].

** Compilation
:PROPERTIES:
:CUSTOM_ID: compilation
:END:

TODO

Links to errors in files

** Browser and external documentation
:PROPERTIES:
:CUSTOM_ID: browser-and-external-documentation
:END:

TODO

- eww (not a replacement for browsers)
- man

** ERC
:PROPERTIES:
:CUSTOM_ID: erc
:END:

TODO

** C macro expansion
:PROPERTIES:
:CUSTOM_ID: c-macro-expansion
:END:

TODO

** Calculator
:PROPERTIES:
:CUSTOM_ID: calculator
:END:

TODO

I dont know much about it, but its very interesting

** Misc
:PROPERTIES:
:CUSTOM_ID: misc
:END:

TODO

Games:
- Zone
- ...

Emms.

* External packages
:PROPERTIES:
:CUSTOM_ID: external-packages
:END:

These packages are currently not built into vanilla GNU Emacs, but this might
change in the future, so keep that in mind.

** Evil mode
:PROPERTIES:
:CUSTOM_ID: evil-mode
:END:

TODO

** Magit
:PROPERTIES:
:CUSTOM_ID: magit
:END:

TODO

** Ediff
:PROPERTIES:
:CUSTOM_ID: ediff
:END:

TODO

Integration with magit

* Honorable mentions
:PROPERTIES:
:CUSTOM_ID: honorable-mentions
:END:

TODO

Which-key, consult packages, etc.
