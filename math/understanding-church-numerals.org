#+TITLE: Understanding Church numerals
#+AUTHOR: 8dcc
#+STARTUP: nofold
#+HTML_HEAD: <link rel="icon" type="image/x-icon" href="../img/favicon.png">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css">
#+HTML_LINK_UP: index.html
#+HTML_LINK_HOME: ../index.html
#+LATEX_HEADER: \usepackage{svg}

#+begin_comment org
TODO: Move section about lambda calculus from Y combinator. Rename article to
"Understanding lambda calculus and Church numerals". Update introduction.
#+end_comment

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

Church numerals are a representation of the natural numbers in the context of
/lambda calculus/ (\lambda-calculus). Although encoding numbers as functions may
not be the most practical method, it has some interesting properties, specially
when computing arithmetical operations.

Church numerals, as well as \lambda-calculus itself, was invented by the
mathematician and computer scientist [[https://en.wikipedia.org/wiki/Alonzo_Church][Alonzo Church]].

This article was mainly motivated by [[https://web.mit.edu/6.001/6.037/sicp.pdf#section*.65][Exercise 2.6]] of [[https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs][Structure and
Interpretation of Computer Programs]].

#+begin_comment org
TODO: Furthermore, the original explanation about lambda calculus was moved from
my article on [[file:../programming/understanding-y-combinator.org][the Y combinator.]]
#+end_comment

#+begin_comment org
TODO: (About beta reduction in lambda calculus section)

The expression $(\lambda p. b) a$ reduces to $b[p := a]$, where the notation
$b[p := a]$ indicates the operation of substituting the parameter $p$ with the
argument $a$ in the body $b$.
#+end_comment

* Church numerals
:PROPERTIES:
:CUSTOM_ID: church-numerals
:END:

Since \lambda-calculus does not support the decimal representation of numbers,
they have to be encoded as functions. Usually, the value of the number number
depends on the number of calls that are performed from the body of the
function. The general method of encoding data as functions is called /Church
encoding/, and the representation of a natural number in this context is called a
/Church numeral/.

The following table shows the first four numbers encoded as church numerals in
lambda notation and conventional function notation (after /uncurrying/ them into
two-argument functions).

| Decimal | \lambda-notation                       | Function notation                 |
|---------+----------------------------------------+-----------------------------------|
| <l>     | <l>                                    | <l>                               |
| 0       | $\lambda f. \lambda x. x$              | $\text{zero}(f, x) = x$           |
| 1       | $\lambda f. \lambda x. f\ x$           | $\text{one}(f, x) = f(x)$         |
| 2       | $\lambda f. \lambda x. f\ (f\ x)$      | $\text{two}(f, x) = f(f(x))$      |
| 3       | $\lambda f. \lambda x. f\ (f\ (f\ x))$ | $\text{three}(f, x) = f(f(f(x)))$ |
| ...     | ...                                    | ...                               |

Note how the decimal value matches the number of nested applications of $f$
inside the body of the innermost lambda. Therefore, a Church numeral with a
value of 3 is simply a function that does something three times. This notion of
a number as a series of repeated operations will be referenced below.

* Increasing a number
:PROPERTIES:
:CUSTOM_ID: increasing-a-number
:END:

As mentioned in the introduction, this article was motivated by Exercise 2.6 of
SICP. The exercise provides the reader with the previous definition of =zero=
along with an =add-1= procedure, which increases its input; from those
definitions, the reader is expected to calculate =one=.

Although the value of =one= was shown in the previous section for illustrating
Church numerals, it's worth going over the expansion of =add-1= in detail.

** Definition of =add-1=
:PROPERTIES:
:CUSTOM_ID: definition-of-add-1
:END:

#+begin_comment org
TODO: Remove currying comment after mentioning it in section above.
TODO: Mention origin of term /currying/ (Haskell Brooks Curry).
#+end_comment

This is the definition of =add-1= in \lambda-notation[fn::The expression can be
simplified through [[https://en.wikipedia.org/wiki/Currying][currying]], that is, by transforming multiple lambdas that
receive one argument into a single lambda that receives multiple arguments (in
this case, both $f$ and $x$). The simplified definition would be
$\lambda n. \lambda f\ x. f (n f x)$.].

$$
\lambda n. \lambda f. \lambda x. f (n\ f\ x)
$$

This is the equivalent definition of =add-1= in Lisp.

#+begin_src scheme
(define add-1
  (lambda (n)
    (lambda (f)
      (lambda (x)
        (f ((n f) x))))))
#+end_src


** Beta reduction
:PROPERTIES:
:CUSTOM_ID: beta-reduction
:END:

A call to =add-1= with an argument of =zero= can be examined through \beta-reduction
to understand why the Church numeral for =one= is returned. Each step of the
reduction will be highlighted and explained using Lisp syntax.

First, the call to =add-1= is expanded, replacing each symbol with its bound
expression.

#+NAME: fig1
[[file:../img/understanding-church-numerals1.svg]]

Then, the outermost call is evaluated, replacing the =n= parameter in the body of
=add-1= with the value of =zero=. Specifically, to avoid naming collisions, =n= is
replaced with the \alpha-conversion of =zero=, where the =f= and =x= symbols are
substituted with =g= and =y=, respectively.

#+NAME: fig2
[[file:../img/understanding-church-numerals2.svg]]

Once the outer call has been evaluated, the expression can be simplified by
evaluating the call to =zero=, that is, the call to the lambda whose parameter is
=y=, and whose argument is =f=. Since the parameter =g= does not appear in the body,
is is essentially discarded, resulting in =(lambda (y) y)=, the /identity/ function.

#+NAME: fig3
[[file:../img/understanding-church-numerals3.svg]]

Finally, the call to the identity lambda can be evaluated, that is, the call to
the lambda whose parameter is =z= and whose argument is =x=. A call to this function
simply evaluates to the argument, in this case, =x=.

#+NAME: fig4
[[file:../img/understanding-church-numerals4.svg]]

This final expression matches the definition of =one= from the previous section: a
function that receives a function =f=, and returns another function that applies =f=
to its argument =x=.

Naturally, the same \beta-reduction process can be expressed in
\lambda-notation.

\begin{align*}
\text{one} &= (\lambda n. \lambda f. \lambda x. f\ (n\ f\ x))
              (\lambda f. \lambda x. x) \\
           &= \lambda f. \lambda x. f\ ((\lambda g. \lambda y. y)\ f\ x) \\
           &= \lambda f. \lambda x. f\ ((\lambda y. y)\ x) \\
           &= \lambda f. \lambda x. f\ x
\end{align*}

** Calculating =two=
:PROPERTIES:
:CUSTOM_ID: calculating-two
:END:

The same process can be done to \beta-reduce a call to =add-1= with an argument of
=one=. From the previous definitions:

\begin{align*}
\text{add-1} &= \lambda n. \lambda f. \lambda x. f\ (n\ f\ x) \\
\text{one} &= \lambda f. \lambda x. f\ x \\
\end{align*}

The following \beta-reduction process can be performed:

\begin{align}
\text{two} &= (\lambda n. \lambda f. \lambda x. f\ (n\ f\ x))
              (\lambda f. \lambda x. f\ x) \label{eq:definition} \\
           &= \lambda f. \lambda x. f\ ((\lambda g. \lambda y. g\ y)\ f\ x) \label{eq:reduction} \\
           &= \lambda f. \lambda x. f\ ((\lambda y. f\ y)\ x) \label{eq:reduction2} \\
           &= \lambda f. \lambda x. f\ (f\ x) \label{eq:solution}
\end{align}

The initial expression $\eqref{eq:definition}$ is simply the call to =add-1=,
replacing the symbols with the values defined above. Then, the call is
\beta-reduced in $\eqref{eq:reduction}$ by replacing the parameter $n$ with the
argument =one=, which was \alpha-converted to avoid parameter collisions, just
like in the example from the previous section. The call to the innermost lambda
is \beta-reduced in $\eqref{eq:reduction2}$ produce $(\lambda y. f\ y)$, that
is, a function that applies $f$ to its argument. Finally, the call to that
lambda, whose argument is $x$, is also reduced into $(f\ x)$; this result
$\eqref{eq:solution}$ matches the [[#church-numerals][previous]] definition of =two=.

* Arbitrary addition
:PROPERTIES:
:CUSTOM_ID: arbitrary-addition
:END:

Although the previous section explained how to increase a Church numeral, the
=add-1= function was already provided. The second part of the exercise asks for a
definition of the addition procedure, avoiding repeated calls to =add-1=.

It is helpful to analyze the inputs of this new addition function, along with
the expected output. In Lisp, these would be defined as the following three
expressions.

#+begin_src scheme
(lambda (f) (lambda (x) (f (f x))))              ; Input `a': Two
(lambda (f) (lambda (x) (f (f (f x)))))          ; Input `b': Three
(lambda (f) (lambda (x) (f (f (f (f (f x)))))))  ; Result: Five
#+end_src

** The abstract objective
:PROPERTIES:
:CUSTOM_ID: the-abstract-objective
:END:

From the previous expressions, it can be concluded that the new addition
function should essentially replace =x= (in either expression, since addition is
[[https://en.wikipedia.org/wiki/Commutative_property][commutative]]) with the entire body of the other expression's innermost
lambda. This abstract process is represented in the following figure, which
shows the expected behavior when adding the Church numeral representation of 2
and 3.

#+NAME: fig5
[[file:../img/understanding-church-numerals5.svg]]

For simplicity, this approach will be used for the rest of the section, where
the body of the first argument =a= is "placed" in the second argument =b=.

** Building the procedure
:PROPERTIES:
:CUSTOM_ID: building-the-procedure
:END:

Since the parameters of =add= are known, its initial structure can be defined. The
following figure shows the partial definition, which will evolve trough this
section.

#+NAME: fig6
[[file:../img/understanding-church-numerals6.svg]]

Since the function will manipulate the bodies of the innermost lambdas, it must
be able to access them. Specifically, it needs to:

1. Extract the innermost body from =a=, that is, =(f (f x))=.
2. Replace =x= in the innermost body of =b=.

Since the numbers themselves are functions, replacing =x= in the inner body of =b=
should be as simple as calling its inner lambda with the desired value as an
argument. To access and call the inner lambda, the outer lambda, whose parameter
is =f=, needs to be called first, but it obviously needs some value as its
argument.

As noted above, Church numerals express "repeated operations", and their =f=
argument represents the function that performs the operation itself. Since the
result of adding two Church numerals must be another Church numeral, which will
also express some "repeated operation", there is no way for =add= to know the
operation that the result is expected to repeat; therefore, the result must also
be a function with an =f= parameter, which lets the caller specify the function to
be repeated.

Since the result of =add= now contains a lambda with an =f= parameter, the
(currently unknown) value of =f= can be used to call =b=, accessing the inner
lambda.

#+NAME: fig7
[[file:../img/understanding-church-numerals7.svg]]

Although there is now a way of calling the inner lambda of =b= for altering =x=,
it's still not clear how to obtain the argument: the body of =a=.

The inner body of =a= can be obtained through a similar process. Just like when
calling =b=, the value of =f= can be used for calling the outer lambda; however,
in this case the inner lambda needs to be called for retrieving the body.

A similar problem emerges: what value should be used as the =x= argument of the
inner lambda of =a=? Going back to the "repeated operations", =x= represents the
input of the operation, in other words, the value to which the operation should
be applied. Just like with the function itself, =add= cannot know this value when
computing its result, so it must use another generic lambda that receives =x=.

With this, the previous two steps of /extraction/ and /replacement/ can be
performed. The following figure shows the final definition of =add= in Lisp.

#+NAME: fig8
[[file:../img/understanding-church-numerals8.svg]]

Note that the previous Lisp definition "replaces" the body of =a= into =b=, but the
conventional definition in \lambda-notation is:

$$
\text{add} = \lambda ab. \lambda f. \lambda x. a\ f\ (b\ f\ x)
$$

Which would move the body of =b= into =a=. Again, this is not an issue because
addition is commutative.

* Calling Church numerals
:PROPERTIES:
:CUSTOM_ID: calling-church-numerals
:END:

To further illustrate why Church numerals are functions that represent repeated
operations, a call to one of them will be made below. First, a simple definition
of =increase=, which adds one to its argument:

#+begin_src scheme
(define increase
  (lambda (val)
    (+ val 1)))

(increase 5)  ; Returns 6
#+end_src

This =increase= function can be used as the =f= argument when calling a Church numeral,
and the result will be another function which applies the operation /N/ times.

#+begin_src scheme
(define church-three
  (lambda (f)
    (lambda (x)
      (f (f (f x))))))

(define increase-by-three (church-three increase))
#+end_src

In the previous example, =increase-by-three= is a function which receives an
argument =x= and applies =increase= to it 3 times. Therefore, these two expressions
are equivalent:

#+begin_src scheme
(increase-by-three 10)               ; Returns 13
(increase (increase (increase 10)))  ; Returns 13
#+end_src

Naturally, this is extremely versatile, as it can be done with any functions as
an argument:

#+begin_src scheme
(define square
  (lambda (val)
    (* val val)))

;; The following expression is equivalent to:
;;
;;   (square (square (square 3)))
;;
;; Which returns:
;;
;;   ((3^2)^2)^2 = 3^(2*2*2) = 3^8 = 6561
;;
((church-three square) 3)
#+end_src
