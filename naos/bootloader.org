#+TITLE: Bootloader
#+AUTHOR: 8dcc
#+STARTUP: nofold
#+HTML_HEAD: <link rel="icon" type="image/x-icon" href="../img/favicon.png">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css">
#+HTML_LINK_UP: index.html
#+HTML_LINK_HOME: ../index.html

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

The [[https://en.wikipedia.org/wiki/Bootloader][bootloader]] is a computer program responsible for booting the operating
system. The main responsibilities of the bootloader are:

1. Obtain information about the system. This information usually needs to be
   provided to the kernel somehow.
2. Switch to the specific environment that is expected by the kernel. This
   normally includes switching to [[https://en.wikipedia.org/wiki/Protected_mode][Protected Mode]] (i.e. 32-bit mode) and enabling
   the [[https://en.wikipedia.org/wiki/A20_line][A20 line]].
3. Load the kernel into memory, and jump to it.

#+begin_comment org
TODO: Link =kernel.org= file above after it's added.
#+end_comment

This project uses a tiny bootloader written from scratch, that aims to be
compliant with the [[https://www.gnu.org/software/grub/manual/multiboot/html_node/Specification.html#Specification][Multiboot 1 protocol]]. This way, since the kernel is also
compliant with this protocol, the kernel and the bootloader should work with any
other component that follows the Multiboot 1 standard.

The bootloader is divided into two stages, Stage 1 and Stage 2. This division is
mainly needed because of size restrictions of the Stage 1 binary, as explained
below.

* Startup and BIOS
:PROPERTIES:
:CUSTOM_ID: startup-and-bios
:END:

When the machine is turned on, the CPU immediately starts execution at the [[https://en.wikipedia.org/wiki/BIOS][BIOS
program]], which usually stored in some [[https://en.wikipedia.org/wiki/Read-only_memory][Read-Only Memory]] (ROM). This program
performs basic hardware initialization, before transferring control to a
bootable device.

To find a valid bootable device, the BIOS looks for bytes ~0x55~ and ~0xAA~ in
offsets 510 and 511 of each possible device. The order in which the BIOS
searches for bootable devices (called the /boot sequence/) is stored in the
[[https://en.wikipedia.org/wiki/Nonvolatile_BIOS_memory][CMOS]]. If the BIOS doesn't find a valid bootable device, it will show an error
and halt.

Once the BIOS has found a valid bootable device[fn::Actually, the BIOS starts by
loading the first 512 bytes, and then checks for the boot signature.], it will
load its first 512 bytes into the physical address ~0x7C00~, and jump there,
executing the instructions it just loaded. In our case, the first 510 bytes of
the device can be used for the Stage 1 bootloader, which will then load the
Stage 2 binary.

#+begin_comment org
TODO: Mention that some BIOSes load the sector at =0000:7C00= but some at
=07c0:0000=.
#+end_comment

* Stage 1
:PROPERTIES:
:CUSTOM_ID: stage-1
:END:

TODO

* COMMENT Stage 2
:PROPERTIES:
:CUSTOM_ID: stage-2
:END:

TODO

** Enabling the A20 line
:PROPERTIES:
:CUSTOM_ID: enabling-the-a20-line
:END:

In order to understand what the [[https://en.wikipedia.org/wiki/A20_line][A20 line]] is, and how it can be enabled, it's
important to understand how [[https://en.wikipedia.org/wiki/X86_memory_segmentation][segmentation]] works in 16-bit [[https://en.wikipedia.org/wiki/Real_mode][real mode]]. The Intel
8086 processor had 20 address lines, numbered A0 to A19; with these, the
processor could access 2^20 bytes, or 1 MB. Internal address registers of this
processor were 16 bits wide. To access a 20-bit address space, an external
memory reference was made up of a 16-bit offset address added to a 16-bit
segment number[fn::For more information on 16-bit segmentation, see [[https://courses.cs.umbc.edu/undergraduate/CMSC211/fall01/burt/lectures/Chap12/segmentsOffsets.html][this article]]
by [[https://userpages.cs.umbc.edu/burt/][Gary Burt]].], shifted 4 bits to the left so as to produce a 20-bit physical
address.

The following code shows how the real address would be calculated from a segment
and an offset.

#+begin_src nasm
; Set data segment (DS) through intermediate register (AX).
mov     ax, 0x13A5
mov     ds, ax

; Write offset to the source index (SI), since not all registers can
; be used for addressing.
mov     si, 0x3327

;   13A5   (Segment: DS)
; +  3327  (Offset: SI)
; -------
;   16D77  (Address)
mov     ax, [ds:si]
#+end_src

* COMMENT Building the disk image
:PROPERTIES:
:CUSTOM_ID: comment-building-the-disk-image
:END:

TODO
